NIST Special Publication 800-208 Recommendation for Stateful Hash-Based Signature Schemes David A. Cooper Daniel C. Apon Quynh H. Dang Michael S. Davidson Morris J. Dworkin Carl A. Miller This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208NIST Special Publication 800-208 Recommendation for Stateful Hash-Based Signature Schemes David A. Cooper Daniel C. Apon Quynh H. Dang Michael S. Davidson Morris J. Dworkin Carl A. Miller Computer Security Division Information Technology Laboratory This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 October 2020 U.S. Department of Commerce Wilbur L. Ross, Jr., Secretary National Institute of Standards and Technology Walter Copan, NIST Director and Under Secretary of Commerce for Standards and TechnologyAuthority This publication has been developed by NIST in accordance with its statutory responsibilities under the Federal Information Security Modernization Act (FISMA) of 2014, 44 U.S.C. Â§ 3551 et seq., Public Law (P.L.) 113-283. NIST is responsible for developing information security standards and guidelines, including minimum requirements for federal information systems, but such standards and guidelines shall not apply to national security systems without the express approval of appropriate federal officials exercising policy authority over such systems. This guideline is consistent with the requirements of the Office of Management and Budget (OMB) Circular A-130. Nothing in this publication should be taken to contradict the standards and guidelines made mandatory and binding on federal agencies by the Secretary of Commerce under statutory authority. Nor should these guidelines be interpreted as altering or superseding the existing authorities of the Secretary of Commerce, Director of the OMB, or any other federal official. This publication may be used by nongovernmental organizations on a voluntary basis and is not subject to copyright in the United States. Attribution would, however, be appreciated by NIST. National Institute of Standards and Technology Special Publication 800-208 Natl. Inst. Stand. Technol. Spec. Publ. 800-208, 59 pages (October 2020) CODEN: NSPUE2 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Certain commercial entities, equipment, or materials may be identified in this document in order to describe an experimental procedure or concept adequately. Such identification is not intended to imply recommendation or endorsement by NIST, nor is it intended to imply that the entities, materials, or equipment are necessarily the best available for the purpose. There may be references in this publication to other publications currently under development by NIST in accordance with its assigned statutory responsibilities. The information in this publication, including concepts and methodologies, may be used by federal agencies even before the completion of such companion publications. Thus, until each publication is completed, current requirements, guidelines, and procedures, where they exist, remain operative. For planning and transition purposes, federal agencies may wish to closely follow the development of these new publications by NIST. Organizations are encouraged to review all draft publications during public comment periods and provide feedback to NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at https://csrc.nist.gov/publications. Comments on this publication may be submitted to: National Institute of Standards and Technology Attn: Computer Security Division, Information Technology Laboratory 100 Bureau Drive (Mail Stop 8930) Gaithersburg, MD 20899-8930 Email: pqc-comments@nist.gov All comments are subject to release under the Freedom of Information Act (FOIA).NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES ii This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Reports on Computer Systems Technology The Information Technology Laboratory (ITL) at the National Institute of Standards and Technology (NIST) promotes the U.S. economy and public welfare by providing technical leadership for the Nationâ€™s measurement and standards infrastructure. ITL develops tests, test methods, reference data, proof of concept implementations, and technical analyses to advance the development and productive use of information technology. ITLâ€™s responsibilities include the development of management, administrative, technical, and physical standards and guidelines for the cost-effective security and privacy of other than national security-related information in federal information systems. The Special Publication 800-series reports on ITLâ€™s research, guidelines, and outreach efforts in information system security, and its collaborative activities with industry, government, and academic organizations. Abstract This recommendation specifies two algorithms that can be used to generate a digital signature, both of which are stateful hash-based signature schemes: the Leighton-Micali Signature (LMS) system and the eXtended Merkle Signature Scheme (XMSS), along with their multi-tree variants, the Hierarchical Signature System (HSS) and multi-tree XMSS (XMSSMT). Keywords cryptography; digital signatures; hash-based signatures; public-key cryptography.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES iii This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Document Conventions The terms â€œshallâ€ and â€œshall notâ€ indicate requirements to be followed strictly in order to conform to the publication and from which no deviation is permitted. The terms â€œshouldâ€ and â€œshould notâ€ indicate that, among several possibilities, one is recommended as particularly suitable without mentioning or excluding others, that a certain course of action is preferred but not necessarily required, or that (in the negative form) a certain possibility or course of action is discouraged but not prohibited. The terms â€œmayâ€ and â€œneed notâ€ indicate a course of action permissible within the limits of the publication. The terms â€œcanâ€ and â€œcannotâ€ indicate a possibility and capability, whether material, physical, or causal. Conformance Testing Conformance testing for implementations of the functions that are specified in this publication will be conducted within the framework of the Cryptographic Algorithm Validation Program (CAVP) and the Cryptographic Module Validation Program (CMVP). The requirements that apply to these implementations are indicated by the word â€œshall.â€ Some of these requirements may be out-of-scope for CAVP or CMVP validation testing and, thus, are the responsibility of entities using, implementing, installing, or configuring applications that incorporate this Recommendation.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES iv This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Patent Disclosure Notice NOTICE: The Information Technology Laboratory (ITL) has requested that holders of patent claims whose use may be required for compliance with the guidance or requirements of this publication disclose such patent claims to ITL. However, holders of patents are not obligated to respond to ITL calls for patents and ITL has not undertaken a patent search in order to identify which, if any, patents may apply to this publication. As of the date of publication and following call(s) for the identification of patent claims whose use may be required for compliance with the guidance or requirements of this publication, no such patent claims have been identified to ITL. No representation is made or implied by ITL that licenses are not required to avoid patent infringement in the use of this publication.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES v This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table of Contents 1 Introduction ............................................................................................................ 1 1.1 Intended Applications for Stateful HBS Schemes ........................................... 1 1.2 The Importance of the Proper Maintenance of State ...................................... 1 1.3 Outline of Text ................................................................................................ 2 2 Glossary of Terms, Acronyms, and Mathematical Symbols .............................. 4 2.1 Terms and Definitions ..................................................................................... 4 2.2 Acronyms ........................................................................................................ 4 2.3 Mathematical Symbols .................................................................................... 5 3 General Discussion ................................................................................................ 7 3.1 One-Time Signature Systems ......................................................................... 7 3.2 Merkle Trees ................................................................................................... 8 3.3 Two-Level Trees ............................................................................................. 9 3.4 Prefixes and Bitmasks .................................................................................. 10 4 Leighton-Micali Signatures (LMS) Parameter Sets ........................................... 12 4.1 LMS with SHA-256 ........................................................................................ 12 4.2 LMS with SHA-256/192 ................................................................................. 13 4.3 LMS with SHAKE256/256 ............................................................................. 14 4.4 LMS with SHAKE256/192 ............................................................................. 14 5 eXtended Merkle Signature Scheme (XMSS) Parameter Sets .......................... 16 5.1 XMSS and XMSSMT with SHA-256 ............................................................... 16 5.2 XMSS and XMSSMT with SHA-256/192 ........................................................ 17 5.3 XMSS and XMSSMT with SHAKE256/256 ..................................................... 18 5.4 XMSS and XMSSMT with SHAKE256/192 ..................................................... 19 6 Random Number Generation for Keys and Signatures .................................... 21 6.1 LMS and HSS Random Number Generation Requirements ......................... 21 6.2 XMSS and XMSSMT Random Number Generation Requirements ................ 21 7 Distributed Multi-Tree Hash-Based Signatures ................................................. 22 7.1 HSS .............................................................................................................. 23 7.2 XMSSMT ........................................................................................................ 23 7.2.1 Modified XMSS Key Generation and Signature Algorithms ................ 24 7.2.2 XMSSMT External Device Operations ................................................. 26NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES vi This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 8 Conformance ........................................................................................................ 28 8.1 Key Generation and Signature Generation ................................................... 28 8.2 Signature Verification .................................................................................... 29 9 Security Considerations ...................................................................................... 30 9.1 One-Time Signature Key Reuse ................................................................... 30 9.2 Hash Collisions ............................................................................................. 30 9.3 Revocation .................................................................................................... 31 References ................................................................................................................... 32 List of Appendices Appendix Aâ€” LMS XDR Syntax Additions ............................................................... 35 Appendix Bâ€” XMSS XDR Syntax Additions ............................................................. 39 B.1 WOTS+ .......................................................................................................... 39 B.2 XMSS ............................................................................................................ 39 B.3 XMSSMT ........................................................................................................ 42 Appendix Câ€” Provable Security Analysis ................................................................ 48 C.1 The Random Oracle Model ........................................................................... 48 C.2 The Quantum Random Oracle Model ........................................................... 48 C.3 LMS Security Proof ....................................................................................... 49 C.4 XMSS Security Proof .................................................................................... 49 C.5 Comparison of the Security Models and Proofs of LMS and XMSS.............. 50 List of Figures Figure 1: A sample Winternitz chain for b = 4.................................................................. 7 Figure 2: A sample Winternitz signature generation and verification ............................... 7 Figure 3: A sample Winternitz signature .......................................................................... 8 Figure 4: A Merkle Hash Tree ......................................................................................... 9 Figure 5: A two-Level Merkle tree ................................................................................. 10 Figure 6: XMSS hash computation with prefix and bitmask .......................................... 11 List of Tables Table 1: LM-OTS parameter sets for SHA-256 ............................................................. 12NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES vii This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table 2: LMS parameter sets for SHA-256 ................................................................... 13 Table 3: LM-OTS parameter sets for SHA-256/192 ...................................................... 13 Table 4: LMS parameter sets for SHA-256/192 ............................................................ 13 Table 5: LM-OTS parameter sets for SHAKE256/256 ................................................... 14 Table 6: LMS parameter sets for SHAKE256/256 ......................................................... 14 Table 7: LM-OTS parameter sets for SHAKE256/192 ................................................... 14 Table 8: LMS parameter sets for SHAKE256/192 ......................................................... 15 Table 9: WOTS+ parameter sets ................................................................................... 16 Table 10: XMSS parameter sets for SHA-256 ............................................................... 16 Table 11: XMSSMT parameter sets for SHA-256 ........................................................... 17 Table 12: XMSS parameter sets for SHA-256/192 ........................................................ 17 Table 13: XMSSMT parameter sets for SHA-256/192 .................................................... 18 Table 14: XMSS parameter sets for SHAKE256/256 .................................................... 18 Table 15: XMSSMT parameter sets for SHAKE256/256 ................................................. 19 Table 16: XMSS parameter sets for SHAKE256/192 .................................................... 19 Table 17: XMSSMT parameter sets for SHAKE256/192 ................................................. 20NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 1 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 1 Introduction This publication supplements FIPS 186  by specifying two additional digital signature schemes, both of which are stateful hash-based signature (HBS) schemes: the Leighton-Micali Signature (LMS) system  and the eXtended Merkle Signature Scheme (XMSS) , along with their multi-tree variants, the Hierarchical Signature System (HSS) and multi-tree XMSS (XMSSMT). All of the digital signature schemes specified in FIPS 186 will be broken if large- scale quantum computers are ever built. The security of the stateful HBS schemes in this publication depends only on the security of the underlying hash functionsâ€”in particular, the infeasibility of finding a preimage or a second preimageâ€”and it is believed that the security of hash functions will not be broken by the development of large-scale quantum computers . This recommendation specifies profiles of LMS, HSS, XMSS, and XMSSMT that are appropriate for use by the U.S. Federal Government. This publication approves the use of some but not all of the parameter sets defined in  and  and also defines some new parameter sets. The approved parameter sets use 192- or 256-bit outputs with either SHA-256  or SHAKE256 . This recommendation requires that key and signature generation be performed in hardware cryptographic modules that do not allow secret keying material to be exported, even in encrypted form. 1.1 Intended Applications for Stateful HBS Schemes NIST is in the process of developing standards for post-quantum secure digital signature schemes  that can be used as replacements for the schemes that are specified in . Stateful HBS schemes are not suitable for general use because they require careful state management that is often difficult to assure, as summarized in Section 1.2 and described in detail in . Instead, stateful HBS schemes are primarily intended for applications with the following characteristics: 1) it is necessary to implement a digital signature scheme in the near future; 2) the implementation will have a long lifetime; and 3) it would not be practical to transition to a different digital signature scheme once the implementation has been deployed. An application that may fit this profile is the authentication of firmware updates for constrained devices. Some constrained devices that will be deployed in the near future will be in use for decades. These devices will need to have a secure mechanism for receiving firmware updates, and it may not be practical to change the code for verifying signatures on updates once the devices have been deployed. 1.2 The Importance of the Proper Maintenance of State In a stateful HBS scheme, an HBS private key consists of a large set of one-time signature (OTS) private keys. The signer needs to ensure that no individual OTS key is ever used to sign more than one message. If an attacker were able to obtain digital signatures for two different messages that were created using the same OTS key, then it would become computationally feasible for that attacker to forge signatures on arbitrary messages . Therefore, as described in , when a stateful HBS scheme is implemented, extreme care needs to be taken in order to ensure that no OTS key is ever reused.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 2 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 In order to obtain assurance that OTS keys are not reused, the signing process should be performed in a highly controlled environment. As described in , there are many ways in which seemingly routine operations could lead to the risk of one-time key reuse. The conformance requirements imposed in Section 8.1 on cryptographic modules that implement stateful HBS schemes are intended to help prevent one-time key reuse. 1.3 Outline of Text The remainder of this document is divided into the following sections and appendices: â€¢ Section 2, Glossary of Terms, Acronyms, and Mathematical Symbols, defines the terms, acronyms, and mathematical symbols used in this document. This section is informative. â€¢ Section 3, General Discussion, gives a conceptual explanation of the elements used in stateful hash-based signature schemes (including hash chains, Merkle trees, and hash prefixes). This section may be used as either a high-level overview of stateful hash-based signature schemes or as an introduction to the detailed descriptions of LMS and XMSS provided in  and . This section is informative. â€¢ Section 4, Leighton-Micali Signatures (LMS) Parameter Sets, describes the parameter sets that are approved for use by this Special Publication with LMS and HSS. â€¢ Section 5, eXtended Merkle Signature Scheme (XMSS) Parameter Sets, describes the parameter sets that are approved for use by this Special Publication with XMSS and XMSSMT. â€¢ Section 6, Random Number Generation for Keys and Signatures, states how the random data used in XMSS and LMS must be generated. â€¢ Section 7, Distributed Multi-Tree Hash-Based Signatures, provides recommendations for distributing the implementation of a single HSS or XMSSMT instance over multiple cryptographic modules. â€¢ Section 8, Conformance, specifies requirements for cryptographic algorithm and module validation that are specific to modules that implement the algorithms in this document. â€¢ Section 9, Security Considerations, enumerates security risks in various scenarios for stateful HBS schemes (with a focus on the problem of key reuse) and describes steps that should be taken to maximize the security of an implementation. This section is informative. â€¢ Appendix A, LMS XDR Syntax Additions, describes additions that are required for the External Data Representation (XDR) syntax for LMS in order to support the new parameter sets specified in this document. â€¢ Appendix B, XMSS XDR Syntax Additions, describes additions that are required for the XDR syntax for XMSS and XMSSMT in order to support the new parameter sets specified in this document.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 3 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 â€¢ Appendix C, Provable Security Analysis, provides information about the security proofs that are available for LMS and XMSS. This section is informative.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 4 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 2 Glossary of Terms, Acronyms, and Mathematical Symbols 2.1 Terms and Definitions approved FIPS-approved or NIST-recommended. An algorithm or technique that is either 1) specified in a FIPS or NIST Recommendation or 2) adopted in a FIPS or NIST Recommendation and specified either (a) in an appendix to the FIPS or NIST Recommendation or (b) in a document referenced by the FIPS or NIST Recommendation. 2.2 Acronyms Selected acronyms and abbreviations used in this publication are defined below. EEPROM Electronically erasable programmable read-only memory EUF-CMA Existential unforgeability under adaptive chosen message attacks FIPS Federal Information Processing Standard HBS Hash-based signature HSS Hierarchical Signature Scheme IRTF Internet Research Task Force LM-OTS Leighton-Micali One-Time Signature LMS Leighton-Micali signature NIST National Institute of Standards and Technology OTS One-time signature QROM Quantum random oracle model RAM Random access memory RFC Request for Comments ROM Random oracle model SHA Secure Hash Algorithm SHAKE Secure Hash Algorithm KECCAK SP Special PublicationNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 5 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 VM Virtual machine WOTS+ Winternitz One-Time Signature Plus XDR External Data Representation XMSS eXtended Merkle Signature Scheme XMSSMT Multi-tree XMSS 2.3 Mathematical Symbols SHA-256(M) SHA-256 hash function as specified in . SHA-256/192(M) T (SHA-256(M)), the most significant (i.e., leftmost) 192 bits of the 192 SHA-256 hash of M. SHAKE256/256(M) SHAKE256(M, 256), where SHAKE256 is specified in Section 6.2 of . The output length is 256 bits. SHAKE256/192(M) SHAKE256(M, 192), where SHAKE256 is specified in Section 6.2 of . The output length is 192 bits. T (X) A truncation function that outputs the most significant (i.e., leftmost) 192 192 bits of the input bit string X. n The number of bytes in the output of a hash function. m In LMS, the number of bytes associated with each node of a Merkle tree. w 1. In XMSS, the length of a Winternitz chain. A single Winternitz chain uses log (w) bits from the hash or checksum. 2 2. In LMS, the number of bits from the hash or checksum used in a single Winternitz chain. The length of a Winternitz chain is 2w. (Note that using a Winternitz parameter of w = 4 in LMS would be comparable to using a parameter of w = 16 in XMSS.) p The number of n-byte string elements in an LM-OTS private key, public key, and signature. Len The number of n-byte string elements in a WOTS+ private key, public key, and signature. H In LMS and XMSS, the height of the tree. In XMSSMT, the total height of the multi-tree (the trees at each level have a height of H/D).NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 6 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 D The number of levels of trees in XMSSMT. L The number of levels of trees in HSS. I A 16-byte string used in LMS as a key pair identifier. C In LMS, the n-byte randomizer used for randomized message hashing. R In XMSS, the n-byte randomizer used for randomized message hashing. SK_PRF An n-byte key used to pseudorandomly generate the randomizer r. S_XMSS A secret random value used for pseudorandom key generation in XMSS. ADRS A 32-byte data structure used in XMSS when generating prefixes (keys) and bitmasks. SEED 1. In XMSS, the public, random, unique identifier for the long-term key. 2. In LMS, a secret random value used for pseudorandom key generation.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 7 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 3 General Discussion At a high level, XMSS and LMS are very similar. They each consist of two componentsâ€”a one- time signature (OTS) scheme and a method for creating a single, long-term public key from a large set of OTS public keys. A brief explanation of OTS schemes and the method for creating a long-term public key from a large set of OTS public keys can be found in Sections 3 and 4 of . 3.1 One-Time Signature Systems Both LMS and XMSS make use of variants of the Winternitz signature scheme. In the Winternitz signature scheme, the message to be signed is hashed to create a digest; the digest is encoded as a base number;1 and then each digit of the digest is signed using a hash chain, as follows. A hbash chain is created by first randomly generating a secret value, , which is the private key. The size of should generally correspond to the targeted security strength of the scheme. So, for the parameter sets approved by this recommendation, will be eitxher 192 or 256 bits in length. The publicx key, , is then created by applying the hash function, , to the secret times, . Figure 1 shows an example of a hash chaixn for the th digit of a digest where is 4. pub H b â€“ 1 ğ‘ğ‘âˆ’1 ğ»ğ» (ğ‘¥ğ‘¥) k b ğ‘¥ğ‘¥ ğ‘˜ğ‘˜ H ğ»ğ»(ğ‘¥ğ‘¥ğ‘˜ğ‘˜ ) FigureH 1: A samplğ»ğ»e Wï¿½ğ»ğ»in( teğ‘¥ğ‘¥rğ‘˜ğ‘˜ n) itï¿½z chaiHn for b = 4 ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘˜ğ‘˜ = ğ»ğ»ï¿½ğ»ğ»ï¿½ğ»ğ»(ğ‘¥ğ‘¥ğ‘˜ğ‘˜)ï¿½ï¿½ The th digit of the digest, , is signed by applying the hash function, , to the private key times, . Figure 2 shows an example of a signature for the th digit of the digest created k k usikng theğ‘ğ‘ Wğ‘˜ğ‘˜ internitz chaiNn in Figure 1 when is 1. As shown, the sigHnature is N .ğ»ğ» Fig(uğ‘¥ğ‘¥reğ‘˜ğ‘˜ )2 also shows how the signature, , can be verifiedk. The hash function, 1, is applied to twice, and if the resulting valuNe k is the same as the public key, ğ‘ ğ‘ ,ğ‘˜ğ‘˜ th=enğ»ğ» th(eğ‘¥ğ‘¥ ğ‘˜ğ‘˜) = sğ»ğ»ig(nğ‘¥ğ‘¥ağ‘˜ğ‘˜ t)ure is valid. In general, the signature fors tk he th digit of a digest can be verifieHd by k k checkings that . pub k ğ‘ğ‘âˆ’1âˆ’ğ‘ğ‘ğ‘˜ğ‘˜ ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘˜ğ‘˜ = ğ»ğ» (ğ‘ ğ‘ ğ‘˜ğ‘˜) ğ‘¥ğ‘¥ ğ‘˜ğ‘˜ H ğ‘ ğ‘ ğ‘˜ğ‘˜ = ğ»ğ»(ğ‘¥ğ‘¥ğ‘˜ğ‘˜ ) Figure 2: Ağ‘ ğ‘  ğ‘˜ğ‘˜ sampleH W internitz sğ»ğ»ign(ğ‘ ğ‘ ağ‘˜ğ‘˜t u)re generHat ion and verificğ‘ğ‘ağ‘ğ‘tiğ‘ğ‘oğ‘˜ğ‘˜ n â‰Ÿ ğ»ğ»ï¿½ğ»ğ»(ğ‘ ğ‘ ğ‘˜ğ‘˜)ï¿½ As noted in , simply signing the individual digits of the digest is not sufficient because an 1 The base b is referred to as the Winternitz parameter in this publication. RFC 8391  specifies that the Winternitz parameter, denoted by w there, may be either 4 or 16 but only specifies parameter sets for w = 16. In RFC 8554 , the term â€œWinternitz parameter,â€ also denoted by w, refers to a different but related quantity: the number of bits of the digest that is encoded by b. RFC 8554 specifies that w may be 1, 2, 4, or 8, which corresponds to a b of 2, 4, 16, or 256, respectively.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 8 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 attacker would be able to generate valid signatures for other message digests. For example, given , as in Figure 2, an attacker would be able to generate a signature for a message digest with a th digit of 2 by applying to once or to a message digest with a th digit of 3 ğ‘ ğ‘ bğ‘˜ğ‘˜ y =appğ»ğ»ly(ğ‘¥ğ‘¥inğ‘˜ğ‘˜ g) to twice. An attacker could not, however, generate a signature for a message digest with ka th digit of 0 as this wo uHld requğ‘ ğ‘ iğ‘˜ğ‘˜ re finding some value such that k , which wou Hld not ğ‘ ğ‘ bğ‘˜ğ‘˜ e feasible as long as is preimage-resistant. k y ğ»ğ»(ğ‘¦ğ‘¦) = ğ‘ ğ‘ ğ‘˜ğ‘˜ In order to protect against the above aHttack, the Winternitz signature scheme computes a checksum of the message digest and signs the checksum along with the digest. For an -digit message digest, the checksum is computed as . The checksum is designed so that the value is non-negative, and any increase ğ‘›ğ‘›inâˆ’ 1a digit in the message digest will rnesult in the checksum becoming smaller. This prevents anâˆ‘ ağ‘˜ğ‘˜ tt= a0 c(kğ‘ğ‘erâˆ’ fr1omâˆ’ cğ‘ğ‘rğ‘˜ğ‘˜ ea)ting an effective forgery from a message signature since the attacker can only increase values within the message digest and cannot decrease values within the checksum. Figure 3 shows an example of a signature for a 32-bit message digest using b = 16. The digest is written as eight hexadecimal digits, and a separate hash chain is used to sign each digit with each hash chain having its own private key.2 Digest Checksum Digest 6 3 F 1 E 9 0 B 3 D Private x x x x x x x x x x 0 1 2 3 4 5 6 7 8 9 Key Signature H6(x ) H3(x ) H15(x ) H(x ) H14(x ) H9(x ) x H11(x ) H3(x ) H13(x ) 0 1 2 3 4 5 6 7 8 9 Public H15(x ) H15(x ) H15(x ) H15(x ) H15(x ) H15(x ) H15(x ) H15(x ) H15(x ) H15(x ) 0 1 2 3 4 5 6 7 8 9 Key Figure 3: A sample Winternitz signature 3.2 Merkle Trees While a single, long-term public key could be created from a large set of OTS public keys by simply concatenating the keys together, the resulting public key would be unacceptably large. XMSS and LMS instead use Merkle hash trees , which allow for the long-term public key to be very short in exchange for requiring a small amount of additional information to be provided with each OTS key. To create a hash tree, the OTS public keys are hashed once to form the leaves of the tree, and these hashes are then hashed together in pairs to form the next level up. Those hash values are then hashed together in pairs, the resulting hash values are hashed together, and so on until all of the public keys have been used to generate a single hash value (the root of the tree), which will be used as the long-term public key. 2 If SHA-256 were used as the hash function, then the message digest would be encoded as 64 hexadecimal digits, and the checksum would be encoded as three hexadecimal digits.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 9 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Figure 4: A Merkle Hash Tree Figure 4 depicts a hash tree that contains eight OTS public keys (k â€¦ k ). The eight keys are 0 7 each hashed to form the leaves of the tree (h â€¦ h ), and the eight leaf values are hashed in pairs 0 7 to create the next level up in the tree (h h h h ). These four hash values are again hashed in 01, 23, 45, 67 pairs to create h and h , which are hashed together to create the long-term public key, h . 0âˆ’3 4âˆ’7 0âˆ’7 In order for an entity that had already received h in a secure manner to verify a message 0âˆ’7 signed using k , the signer would need to provide h , h , and h in addition to k . The verifier 2 3 01 4âˆ’7 2 would compute , , , and . Ifâ€² is the sâ€²ame as h 0â€²âˆ’7, then kâ€²2 may be used toâ€² verify theâ€² message signature. â„2 = ğ»ğ»(ğ‘˜ğ‘˜2) â„23 = ğ»ğ»(â„2||â„3) â„0âˆ’3 = ğ»ğ»(â„01||â„23) â„0âˆ’7 = â€² â€² ğ»ğ»3.(3â„ 0âˆ’ T3 w||oâ„-4 Lâˆ’ e7 v)el Tâ„re0âˆ’ e7 s Both  and  define single tree and multi-tree variants of their signature schemes. In an instance that involves two levels of trees, as shown in Figure 5, the OTS keys that form the leaves of the top-level tree sign the roots of the trees at the bottom level, and the OTS keys that form the leaves of the bottom-level trees are used to sign the messages. The root of the top-level tree is the long-term public key for the signature scheme.3 3 While this section only describes two-level trees, HSS allows for up to eight levels of trees, and XMSSMT allows for up to 12 levels of trees.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 10 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 As described in Section 7, the use of two levels of trees can make it easier to distribute OTS keys across multiple cryptographic modules in order to protect against private key loss. A set of OTS keys can be created in one cryptographic module, and the root of the Merkle tree formed from these keys can be published as the public key for the signature scheme. OTS keys can then be created on multiple other cryptographic modules with a separate Merkle tree created for the OTS keys of each of the other cryptographic modules, and a different OTS key from the first cryptographic module can be used to sign each of the roots of the other cryptographic modules. root a k a,0 k a,1 k a,2 k a,3 root b,0 root b,1 root b,2 root b,3 k b,0 k b,1 k b,2 k b,3 k b,4 k b,5 k b,6 k b,7 k b,8 k b,9 k b,10 k b,11 k b,12 k b,13 k b,14 k b,15 Figure 5: A two-Level Merkle tree While there are benefits in the use of a two-level tree, it results in larger signatures and slower signature verification as each message signature will need to include two OTS signatures. For example, if a message were signed using OTS key k in Figure 5, the signature would need to b,6 include the signature on root using k in addition to the signature on the message using k . b,1 a,1 b,6 3.4 Prefixes and Bitmasks In order to strengthen the security of the schemes in both XMSS and LMS, a prefix is prepended whenever a value is hashed. For example, when computing the public key for a Winternitz signature from the private key in LMS as described in Section 3.1, rather than just computing , the public key is computed as 3 ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘ğ‘˜ğ‘˜ = ğ»ğ» (ğ‘¥ğ‘¥ğ‘˜ğ‘˜) = ğ»ğ»ï¿½ğ»ğ»ï¿½ğ»ğ»(ğ‘¥ğ‘¥ğ‘˜ğ‘˜, )w ï¿½ï¿½here p 1, p 2, and p 3 are each differ ğ‘ğ‘e ğ‘ğ‘nt ğ‘ğ‘ pğ‘˜ğ‘˜r =efix values. The prefix is formed by concatenating together various pieces of information, including a unique identifier for ğ»ğ»ï¿½ğ‘ğ‘3 || ğ»ğ»ï¿½ğ‘ğ‘2 || ğ»ğ»(ğ‘ğ‘1 || ğ‘¥ğ‘¥ğ‘˜ğ‘˜)ï¿½ï¿½ the long-term public key and an indicator of the purpose of the hash (e.g., Winternitz chain or Merkle tree). If the hash is part of a Winternitz chain, then the prefix also includes the number of the OTS key, which digit of the digest or checksum is being signed, and where in the chain the hash appears. The goal is to ensure that every single hash that is computed within the LMS scheme uses a different prefix. XMSS generates its prefixes in a similar way. The information described above is used to form an address, which uniquely identifies where a particular hash invocation occurs within theNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 11 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 scheme. This address is then hashed along with a unique identifier (SEED) for the long-term public key to create the prefix. Unlike LMS, XMSS also uses bitmasks. Similar to the generation of the prefix, a slightly different address is hashed along with the SEED to create a bitmask, which is exclusive-ORed with the value to be hashed (the input). The prefix and masked input value are concatenated as specified in  to form the input to the hash function.4 Figure 6 illustrates an example of this computation when the input is a Winternitz chaining value. In , the hash function is referred to as H, H_msg, F, or PRF, depending on where it is being used. However, in each case, it is the same function, just with a different prefix prepended in order to ensure separation between the uses. 3 || SEED || ADDR H 0 || prefix || bitmasked input output âŠ• H 3 || SEED || ADDR' bitmask input H Figure 6: XMSS hash computation with prefix and bitmask 4 When hashing values within a Merkle tree, two bitmasks are created, one for the left input and one for the right input, and the two bitmasked values are concatenated along with the prefix.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 12 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 4 Leighton-Micali Signatures (LMS) Parameter Sets The LMS and HSS algorithms are described in RFC 8554 . This Special Publication approves the use of LMS and HSS with four different hash functions: SHA-256, SHA-256/192, SHAKE256/256, and SHAKE256/192 (see Section 2.3). The parameter sets that use SHA-256 are defined in RFC 8554 . The parameter sets that use SHA-256/192, SHAKE256/256, and SHAKE256/192 are defined in this publication. When generating a key pair for an LMS instance, each LM-OTS key in the system shall use the same parameter set, and the hash function used for the LMS system shall be the same as the hash function used in the LM-OTS keys. The height of the tree (h) shall be 5, 10, 15, 20, or 25. When generating a key pair for an HSS instance, the requirements specified in the previous paragraph apply to each LMS tree in the instance. If the HSS instance has more than one level, then the hash function used for the tree at level 0 shall be used for every LMS tree at every other level. For each level, the same LMS and LM-OTS parameter sets shall be used for every LMS tree at that level. Different LMS and LM-OTS parameter sets may be used at different levels, as long as all chosen parameter sets use the same hash function. The LMS and LM-OTS parameter sets that are approved for use by this Special Publication are specified in tables in Sections 4.1 through 4.4. The parameters n, w, p, m, and h specified in the tables are defined in Sections 4.1 and 5.1 of . Extensions to the XDR syntax in Section 3.3 of  needed to support the parameter sets defined in Sections 4.2 through 4.4 of this document are specified in Appendix A. The numeric identifiers for these parameter sets are marked as â€œTBDâ€ since they had not yet been assigned at the time this document was published. Once they are assigned, the numeric identifiers may be found at https://www.iana.org/assignments/leighton-micali-signatures/leighton-micali- signatures.xhtml. 4.1 LMS with SHA-256 When generating LMS or HSS key pairs using SHA-256, the LMS and LM-OTS parameter sets shall be selected from the following two tables, which come from Sections 4 and 5 of . Table 1: LM-OTS parameter sets for SHA-256 Numeric LM-OTS Parameter Sets Identifier n w P LMOTS_SHA256_N32_W1 0x00000001 32 1 265 LMOTS_SHA256_N32_W2 0x00000002 32 2 133 LMOTS_SHA256_N32_W4 0x00000003 32 4 67 LMOTS_SHA256_N32_W8 0x00000004 32 8 34NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 13 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table 2: LMS parameter sets for SHA-256 LMS Parameter Sets Numeric Identifier m h LMS_SHA256_M32_H5 0x00000005 32 5 LMS_SHA256_M32_H10 0x00000006 32 10 LMS_SHA256_M32_H15 0x00000007 32 15 LMS_SHA256_M32_H20 0x00000008 32 20 LMS_SHA256_M32_H25 0x00000009 32 25 4.2 LMS with SHA-256/192 When generating LMS or HSS key pairs using SHA-256/192, the LMS and LM-OTS parameter sets shall be selected from the following two tables. Table 3: LM-OTS parameter sets for SHA-256/192 Numeric LM-OTS Parameter Sets Identifier n w P LMOTS_SHA256_N24_W1 TBD 24 1 200 LMOTS_SHA256_N24_W2 TBD 24 2 101 LMOTS_SHA256_N24_W4 TBD 24 4 51 LMOTS_SHA256_N24_W8 TBD 24 8 26 Table 4: LMS parameter sets for SHA-256/192 LMS Parameter Sets Numeric Identifier m h LMS_SHA256_M24_H5 TBD 24 5 LMS_SHA256_M24_H10 TBD 24 10 LMS_SHA256_M24_H15 TBD 24 15 LMS_SHA256_M24_H20 TBD 24 20 LMS_SHA256_M24_H25 TBD 24 25NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 14 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 4.3 LMS with SHAKE256/256 When generating LMS or HSS key pairs using SHAKE256/256, the LMS and LM-OTS parameter sets shall be selected from the following two tables. Table 5: LM-OTS parameter sets for SHAKE256/256 Numeric LM-OTS Parameter Sets Identifier n w p LMOTS_SHAKE_N32_W1 TBD 32 1 265 LMOTS_SHAKE_N32_W2 TBD 32 2 133 LMOTS_SHAKE_N32_W4 TBD 32 4 67 LMOTS_SHAKE_N32_W8 TBD 32 8 34 Table 6: LMS parameter sets for SHAKE256/256 LMS Parameter Sets Numeric Identifier m h LMS_ SHAKE_M32_H5 TBD 32 5 LMS_ SHAKE_M32_H10 TBD 32 10 LMS_ SHAKE_M32_H15 TBD 32 15 LMS_ SHAKE_M32_H20 TBD 32 20 LMS_ SHAKE_M32_H25 TBD 32 25 4.4 LMS with SHAKE256/192 When generating LMS or HSS key pairs using SHAKE256/192, the LMS and LM-OTS parameter sets shall be selected from the following two tables. Table 7: LM-OTS parameter sets for SHAKE256/192 Numeric LM-OTS Parameter Sets Identifier n w p LMOTS_SHAKE_N24_W1 TBD 24 1 200 LMOTS_SHAKE_N24_W2 TBD 24 2 101 LMOTS_SHAKE_N24_W4 TBD 24 4 51 LMOTS_SHAKE_N24_W8 TBD 24 8 26NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 15 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table 8: LMS parameter sets for SHAKE256/192 LMS Parameter Sets Numeric Identifier m h LMS_ SHAKE_M24_H5 TBD 24 5 LMS_ SHAKE_M24_H10 TBD 24 10 LMS_ SHAKE_M24_H15 TBD 24 15 LMS_ SHAKE_M24_H20 TBD 24 20 LMS_ SHAKE_M24_H25 TBD 24 25NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 16 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 5 eXtended Merkle Signature Scheme (XMSS) Parameter Sets The XMSS and XMSSMT algorithms are described in RFC 8391 . This Special Publication approves the use of XMSS and XMSSMT with four different hash functions: SHA-256, SHA- 256/192, SHAKE256/256, and SHAKE256/192 (see Section 2.3).5 The parameter sets that use SHA-256 are defined in RFC 8391 . The parameter sets that use SHA-256/192, SHAKE256/256, and SHAKE256/192 are defined below. The WOTS+ parameters that correspond to the use of each of these hash functions are specified in the following table. Table 9: WOTS+ parameter sets Parameter Sets Numeric Identifier F / PRF n w len WOTSP-SHA2_256 0x00000001 See Section 5.1 32 16 67 WOTSP-SHA2_192 0x00000005 See Section 5.2 24 16 51 WOTSP-SHAKE256_256 0x00000006 See Section 5.3 32 16 67 WOTSP-SHAKE256_192 0x00000007 See Section 5.4 24 16 51 The XMSS and XMSSMT parameter sets that are approved for use by this Special Publication are specified in Sections 5.1 through 5.4. The parameters n, w, len, h, and d specified in the tables are defined in Sections 3.1.1, 4.1.1, and 4.2.1 of . Extensions to the XDR syntax in Appendices A, B, and C of  needed to support the parameter sets defined in Sections 5.2 through 5.4 of this document are specified in Appendix B. 5.1 XMSS and XMSSMT with SHA-256 When generating XMSS or XMSSMT key pairs using SHA-256, the parameter sets shall be selected from the following two tables, which come from Section 5 of . Each of these uses the WOTSP-SHA2_256 parameter set. Table 10: XMSS parameter sets for SHA-256 Parameter Sets Numeric Identifier n w len h XMSS-SHA2_10_256 0x00000001 32 16 67 10 XMSS-SHA2_16_256 0x00000002 32 16 67 16 XMSS-SHA2_20_256 0x00000003 32 16 67 20 5 The parameter sets specified in RFC 8391  that use SHAKE128, SHAKE256, and SHA-512 are not approved for use by this Special Publication.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 17 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table 11: XMSSMT parameter sets for SHA-256 Parameter Sets Numeric Identifier n w len h d XMSSMT-SHA2_20/2_256 0x00000001 32 16 67 20 2 XMSSMT-SHA2_20/4_256 0x00000002 32 16 67 20 4 XMSSMT-SHA2_40/2_256 0x00000003 32 16 67 40 2 XMSSMT-SHA2_40/4_256 0x00000004 32 16 67 40 4 XMSSMT-SHA2_40/8_256 0x00000005 32 16 67 40 8 XMSSMT-SHA2_60/3_256 0x00000006 32 16 67 60 3 XMSSMT-SHA2_60/6_256 0x00000007 32 16 67 60 6 XMSSMT-SHA2_60/12_256 0x00000008 32 16 67 60 12 For the parameter sets in this section, the functions F, H, H_msg, and PRF are as defined in Section 5.1 of  for SHA2 with n = 32. The function PRF , which is used for key keygen generation as specified in Section 6.2, is defined as follows: PRF (KEY, M): SHA-256(toByte(4, 32) || KEY || M). keygen 5.2 XMSS and XMSSMT with SHA-256/192 When generating XMSS or XMSSMT key pairs using SHA-256/192, the parameter sets shall be selected from the following two tables. Each of these uses the WOTSP-SHA2_192 parameter set. Table 12: XMSS parameter sets for SHA-256/192 Parameter Sets Numeric Identifier n w len h XMSS-SHA2_10_192 0x0000000D 24 16 51 10 XMSS-SHA2_16_192 0x0000000E 24 16 51 16 XMSS-SHA2_20_192 0x0000000F 24 16 51 20NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 18 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table 13: XMSSMT parameter sets for SHA-256/192 Parameter Sets Numeric Identifier n w len h d XMSSMT-SHA2_20/2_192 0x00000021 24 16 51 20 2 XMSSMT-SHA2_20/4_192 0x00000022 24 16 51 20 4 XMSSMT-SHA2_40/2_192 0x00000023 24 16 51 40 2 XMSSMT-SHA2_40/4_192 0x00000024 24 16 51 40 4 XMSSMT-SHA2_40/8_192 0x00000025 24 16 51 40 8 XMSSMT-SHA2_60/3_192 0x00000026 24 16 51 60 3 XMSSMT-SHA2_60/6_192 0x00000027 24 16 51 60 6 XMSSMT-SHA2_60/12_192 0x00000028 24 16 51 60 12 For the parameter sets in this section, the functions F, H, H_msg, PRF, and PRF are defined keygen as follows: â€¢ F(KEY, M): T (SHA-256(toByte(0, 4) || KEY || M)) 192 â€¢ H(KEY, M): T (SHA-256(toByte(1, 4) || KEY || M)) 192 â€¢ H_msg(KEY, M): T (SHA-256(toByte(2, 4) || KEY || M)) 192 â€¢ PRF(KEY, M): T (SHA-256(toByte(3, 4) || KEY || M)) 192 â€¢ PRF (KEY, M): T (SHA-256(toByte(4, 4) || KEY || M)) keygen 192 5.3 XMSS and XMSSMT with SHAKE256/256 When generating XMSS or XMSSMT key pairs using SHAKE256/256, the parameter sets shall be selected from the following two tables. Each of these uses the WOTSP-SHAKE256_256 parameter set. Table 14: XMSS parameter sets for SHAKE256/256 Parameter Sets Numeric Identifier n w len h XMSS-SHAKE256_10_256 0x00000010 32 16 67 10 XMSS-SHAKE256_16_256 0x00000011 32 16 67 16 XMSS-SHAKE256_20_256 0x00000012 32 16 67 20NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 19 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table 15: XMSSMT parameter sets for SHAKE256/256 Parameter Sets Numeric Identifier n w len h d XMSSMT-SHAKE256_20/2_256 0x00000029 32 16 67 20 2 XMSSMT-SHAKE256_20/4_256 0x0000002A 32 16 67 20 4 XMSSMT-SHAKE256_40/2_256 0x0000002B 32 16 67 40 2 XMSSMT-SHAKE256_40/4_256 0x0000002C 32 16 67 40 4 XMSSMT-SHAKE256_40/8_256 0x0000002D 32 16 67 40 8 XMSSMT-SHAKE256_60/3_256 0x0000002E 32 16 67 60 3 XMSSMT-SHAKE256_60/6_256 0x0000002F 32 16 67 60 6 XMSSMT-SHAKE256_60/12_256 0x00000030 32 16 67 60 12 For the parameter sets in this section, the functions F, H, H_msg, PRF, and PRF are defined keygen as follows: â€¢ F(KEY, M): SHAKE256(toByte(0, 32) || KEY || M, 256) â€¢ H(KEY, M): SHAKE256(toByte(1, 32) || KEY || M, 256) â€¢ H_msg(KEY, M): SHAKE256(toByte(2, 32) || KEY || M, 256) â€¢ PRF(KEY, M): SHAKE256(toByte(3, 32) || KEY || M, 256) â€¢ PRF (KEY, M): SHAKE256(toByte(4, 32) || KEY || M, 256) keygen 5.4 XMSS and XMSSMT with SHAKE256/192 When generating XMSS or XMSSMT key pairs using SHAKE256/192, the parameter sets shall be selected from the following two tables. Each of these uses the WOTSP-SHAKE256_192 parameter set. Table 16: XMSS parameter sets for SHAKE256/192 Parameter Sets Numeric Identifier n w len h XMSS-SHAKE256_10_192 0x00000013 24 16 51 10 XMSS-SHAKE256_16_192 0x00000014 24 16 51 16 XMSS-SHAKE256_20_192 0x00000015 24 16 51 20NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 20 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Table 17: XMSSMT parameter sets for SHAKE256/192 Parameter Sets Numeric Identifier n w len h d XMSSMT-SHAKE256_20/2_192 0x00000031 24 16 51 20 2 XMSSMT-SHAKE256_20/4_192 0x00000032 24 16 51 20 4 XMSSMT-SHAKE256_40/2_192 0x00000033 24 16 51 40 2 XMSSMT-SHAKE256_40/4_192 0x00000034 24 16 51 40 4 XMSSMT-SHAKE256_40/8_192 0x00000035 24 16 51 40 8 XMSSMT-SHAKE256_60/3_192 0x00000036 24 16 51 60 3 XMSSMT-SHAKE256_60/6_192 0x00000037 24 16 51 60 6 XMSSMT-SHAKE256_60/12_192 0x00000038 24 16 51 60 12 For the parameter sets in this section, the functions F, H, H_msg, PRF, and PRF are defined keygen as follows: â€¢ F(KEY, M): SHAKE256(toByte(0, 4) || KEY || M, 192) â€¢ H(KEY, M): SHAKE256(toByte(1, 4) || KEY || M, 192) â€¢ H_msg(KEY, M): SHAKE256(toByte(2, 4) || KEY || M, 192) â€¢ PRF(KEY, M): SHAKE256(toByte(3, 4) || KEY || M, 192) â€¢ PRF (KEY, M): SHAKE256(toByte(4, 4) || KEY || M, 192) keygenNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 21 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 6 Random Number Generation for Keys and Signatures This section specifies requirements for the generation of random data that apply in addition to the requirements that are specified in  for LMS and HSS and in  for XMSS and XMSSMT. Note: Variables and notations used in this section are defined in the relevant documents mentioned above. 6.1 LMS and HSS Random Number Generation Requirements The LMS key pair identifier, I, shall be generated using an approved random bit generator (see the SP 800-90 series of publications ), where the instantiation of the random bit generator supports at least 128 bits of security strength. The n-byte private elements of the LM-OTS private keys (x[i] in Section 4.2 of ) shall be generated using the pseudorandom key generation method specified in Appendix A of . The same SEED value shall be used to generate every private element in a single LMS instance, and SEED shall be generated using an approved random bit generator , where the instantiation of the random bit generator supports at least 8n bits of security strength. If more than one LMS instance is being created (e.g., for an HSS instance), then a separate key pair identifier, I, and SEED shall be generated for each LMS instance. When generating a signature, the n-byte randomizer C (see Section 4.5 of ) shall be generated using an approved random bit generator , where the instantiation of the random bit generator supports at least 8n bits of security strength. 6.2 XMSS and XMSSMT Random Number Generation Requirements The n-byte values SK_PRF and SEED shall be generated using an approved random bit generator (see the SP 800-90 series of publications ), where the instantiation of the random bit generator supports at least 8n bits of security strength. The private n-byte strings in the WOTS+ private keys (sk[i] in Section 3.1.3 of ) shall be generated using the pseudorandom key generation method specified in Algorithm 10' in Section 7.2.1: sk[j] = PRF (S_XMSS, SEED || ADRS), where PRF is as defined in Section 5 for keygen keygen the parameter set being used.6 The private seed, S_XMSS, shall be generated using an approved random bit generator , where the instantiation of the random bit generator supports at least 8n bits of security strength. If more than one XMSS key pair is being created within a cryptographic module (including XMSS keys that belong to a single XMSSMT instance), then a separate random S_XMSS shall be generated for each XMSS key pair. 6 For an XMSS key that is not part of an XMSSMT instance, d = 1, L = 0, and t = 0.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 22 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 7 Distributed Multi-Tree Hash-Based Signatures If a digital signature key will be used to generate signatures over a long period of time and replacing the public key would be difficult, then it will be necessary to prepare for the possibility that a cryptographic module holding the private key may fail during the keyâ€™s lifetime. In the case of most digital signature schemes, a common solution is to make copies of the private key. However, in the case of stateful HBS schemes, simply copying the private key would create a risk of OTS key reuse. While it would be possible to have one cryptographic module generate all of the OTS keys and then distribute different OTS keys to each of the other cryptographic modules, doing so is not an option for cryptographic modules that conform to this recommendation: due to the risks associated with copying OTS keys, this recommendation prohibits exporting private keying material (Section 8). One option would be to create multiple stateful HBS keys on different cryptographic modules and then configure clients to accept signatures created using any of these keys. These keys could be distributed to clients all at once or using a mechanism such as the Hash Of Root Key certificate extension , which provides a mechanism for distributing new public keys over time. Another option would be to create a single stateful HBS key in which the OTS private keys are distributed across multiple cryptographic modules. The easiest way to have OTS keys on multiple cryptographic modules without exporting private keys is to use HSS or XMSSMT with two levels of trees where the trees are instantiated on different cryptographic modules. First, a top-level LMS or XMSS key pair would be created in a cryptographic module. The top levelâ€™s OTS keys would only be used to sign the roots of other trees. Then, bottom-level LMS or XMSS key pairs would be created, and the public keys from those key pairs (i.e., the roots of their Merkle trees) would be signed by OTS keys of the top-level key pair. The OTS keys of the bottom-level key pairs would be used to sign ordinary messages. The number of bottom-level key pairs that could be created would be limited only by the number of OTS keys in the top-level key pair. As an example, suppose that an organization wishes to have a single XMSSMT key with the OTS private keys being distributed across two cryptographic modules (in case one fails), and the organization has determined that, at most, 10000 signatures will need to be generated over the lifetime of the XMSSMT key. The organization could create a top-level XMSS key pair in one cryptographic module using the XMSSMT-SHA2_20/2_256 parameter set and then create 10 bottom-level XMSS keys in that same cryptographic module. An additional 10 bottom-level XMSS keys could be created in a second cryptographic module with all 20 of the bottom-levelâ€™s keys being signed by OTS keys of the top-level key pair. When working with distributed multi-tree hash-based signatures, the cryptographic module that holds the top-level tree is a potential single point of failure. Once this cryptographic module fails, it is no longer possible to sign additional bottom-level key pairs. Consequently, all of the bottom-level keys should be generated up front as part of the initial key generation ceremony. Once the top-level key has been used to sign all of the bottom-level keys, the top-level key is noNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 23 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 longer needed, as copies of the signatures created using OTS keys of the top-level key pair may be stored outside of the cryptographic module. In order to avoid the top-level key being a single point of failure, the two options described above could be combined to create multiple distributed multi-tree HBS keys. Multiple top-level keys pairs would initially be created, each on a different cryptographic module, and clients would be configured to accept signatures created using any of these keys. Then, whenever a new bottom-level key needed to be created, it could be signed by any one of the top-level keys. This would allow for new bottom-level keys to be created as long as at least one of the cryptographic modules that contains a top-level key remained operational. Of course, the same level of care should be used when signing a bottom-level key as would be used during the initial key generation ceremony (or as would be used in making a copy of an RSA or ECDSA private key). 7.1 HSS In the case of HSS, the distributed multi-tree scheme described above can be implemented using multiple cryptographic modules that individually implement LMS without modifications. The top-level LMS public key can be converted to an HSS public key by an external, non- cryptographic device. This device can also submit the public keys of the bottom-level LMS keys for signature by the top-level LMS key. In HSS, the operation for signing the root of a lower- level tree is the same as the operation for signing an ordinary message. Finally, this external device can submit ordinary messages to cryptographic modules that hold the bottom-level LMS keys for signing and then combine the resulting LMS signatures with the top-level keyâ€™s signature on the bottom-level LMS public key in order to create the HSS signature for the ordinary messages (see Algorithm 7 and Algorithm 8 in ). 7.2 XMSSMT Distributing the implementation of an XMSSMT instance across multiple cryptographic modules requires each cryptographic module to implement slightly modified versions of the XMSS key and signature generation algorithms provided in . The modified versions of these algorithms are provided in Section 7.2.1. The modifications are primarily intended to ensure that each XMSS key uses the appropriate values for its layer and tree addresses when computing prefixes and bitmasks. The modifications also ensure that every XMSS key uses the same value for SEED and that the root of the top-level tree is used when computing the hashes of messages to be signed. Note that while Algorithm 15 in  indicates that an XMSSMT secret key has a single SK_PRF value that is shared by all of the XMSS secret keys, Algorithm 10' in Section 7.2.1 has each cryptographic module generate its own value for SK_PRF. While generating a different SK_PRF for each cryptographic module does not exactly align with the specification in , doing so does not affect either interoperability or security. SK_PRF is only used to pseudorandomly generate the value r in Algorithm 16, which is used for randomized hashing, and any secure method for generating random values could be used to generate r. Section 7.2.2 describes the steps that an external, non-cryptographic device needs to perform in order to implement XMSSMT key and signature generation using a set of cryptographic modules that implement the algorithms in Section 7.2.1. While Algorithms 10' and 12' in Section 7.2.1NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 24 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 have been designed to work with XMSSMT instances that have more than two layers, the algorithms in Section 7.2.2 assume that an XMSSMT instance with exactly two layers is being created. 7.2.1 Modified XMSS Key Generation and Signature Algorithms Algorithm 10': XMSS'_keyGen // L needs to be in the range [0 â€¦ d-1] // t needs to be in the range [0 â€¦ 2^((d-1-L)(h/d)) - 1] Input: level L, tree t, public key of top-level tree PK_MT (if L d - 1) Output: XMSS public key PK â‰  Initialize S_XMSS with an n-byte string using an approved random bit generator , where the instantiation of the random bit generator supports at least 8n bits of security strength; // SEED needs to be generated for the top-level XMSS key. // For all other XMSS keys, the value needs to be copied from // the top-level XMSS key. if ( L = d â€“ 1 ) { Initialize SEED with an n-byte string using an approved random bit generator , where the instantiation of the random bit generator supports at least 8n bits of security strength; } else { SEED = getSEED(PK_MT); } setSEED(SK, SEED); ADRS = toByte(0, 32); ADRS.setLayerAddress(L); ADRS.setTreeAddress(t); // Initialization for SK-specific contents idx = t * 2^(h / d); for ( i = 0; i < 2^(h / d); i++ ) { ADRS.setOTSAddress(i); // For each OTS key, i, generate the private key value for // chain in the OTS key. for ( j=0; j < len; j++) { ADRS.setChainAddress(j); PRF sk[j] = keygen(S_XMSS, SEED || ADRS); } // Set the secret key for OTS key i to the array of len // private key values generated for that key.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 25 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 wots_sk[i] = sk; } setWOTS_SK(SK, wots_sk); Initialize SK_PRF with an n-byte string using an approved random bit generator , where the instantiation of the random bit generator supports at least 8n bits of security strength; setSK_PRF(SK, SK_PRF); root = treeHash(SK, 0, h / d, ADRS); setLayerAddress(SK, L); setTreeAddress(SK, t); setIdx(SK, idx); // The "root" value in SK needs to be the root of the top-level // XMSS tree, as this is the value used when hashing the message // to be signed. if ( L = d â€“ 1 ) { setRoot(SK, root); SK = L || t || idx || wots_sk || SK_PRF || root || SEED; } else { setRoot(SK, getRoot(PK_MT)); SK = L || t || idx || wots_sk || SK_PRF || getRoot(PK_MT) || SEED; } // The public key should be encoded using the XDR for // xmssmt_public_key in Appendix C.3 of  with the additions // specified in Appendix B.3 of this document. PK = OID || root || SEED; return PK; Algorithm 12': XMSS'_sign Input: Message M Output: signature Sig idx_sig = getIdx(SK); setIdx(SK, idx_sig + 1); L = getLayerAddress(SK); t = getTreeAddress(SK); ADRS = toByte(0, 32); ADRS.setLayerAddress(L); ADRS.setTreeAddress(t); if ( L > 0 ) { // M must be the n-byte root from an XMSS public key byte[n] r = 0; // n-byte string of zerosNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 26 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 byte[n] M' = M; } else { byte[n] r = PRF(getSK_PRF(SK), toByte(idx_sig, 32)); byte[n] M' = H_msg(r || getRoot(SK) || (toByte(idx_sig, n)), M); } idx_leaf = idx_sig - t * 2^(h / d); Sig = idx_sig || r || treeSig(M', SK, idx_leaf, ADRS); return Sig; 7.2.2 XMSSMT External Device Operations XMSS^MT external device keygen Input: No input // Generate top-level key pair on a cryptographic module PK_MT = XMSS'_keyGen(1, 0, NULL); t = 0; for each bottom-level key pair to be created { // Generate bottom-level key pair on a cryptographic module PK[t] = XMSSâ€™_keygen(0, t, PK_MT); // Submit root of bottom-level key pairâ€™s public key // to be signed by the top-level key pair. SigPK[t] = XMSS'_sign(getRoot(PK[t])); // If the public key on the bottom-level tree was created using // a tree address of t, then its root needs to be signed by OTS 7 // key t of the top-level tree. If it was not, then try again. while ( getIdx(SigPK[t]) t ) { t = getIdx(SigPK[t]) + 1; â‰  PK[t] = XMSS'_keygen(0, t, PK_MT); SigPK[t] = XMSS'_sign(getRoot(PK[t])); } t = t + 1; } XMSS^MT external device sign Input: Message M 7 While the signing cryptographic module should use its one-time keys sequentially, making it possible for the external device to determine in advance which one-time key will be used to sign the public key of the bottom-level tree, the external device cannot specify to the signing cryptographic module which one-time key it should use. So, there is a small chance that an internal glitch in the signing cryptographic module will cause it to skip over one or more key indices and sign the bottom- levelâ€™s public key using an unexpected key index. While this event should be rare, if it does happen, the only option is to regenerate the bottom-level key pair, set the tree address to the next expected key index, and then try again.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 27 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Output: signature Sig // Send XMSS'_sign() command to one of the bottom-level key pairs Sig_tmp = XMSS'_sign(M); idx_sig = getIdx(Sig_tmp); // Determine which bottom-level tree was used to sign the message // by extracting the most significant bits of idx_sig. t = [idx_sig â€“ (idx_sig mod 2^(h / d))]/ 2^(h / d)); // Append the signature of the signing key pair's root // (just the output of treeSig, not idx_sig or r). Sig = Sig_tmp || getSig(SigPK[t]); return Sig;NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 28 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 8 Conformance 8.1 Key Generation and Signature Generation Cryptographic modules that implement signature generation for a parameter set shall also implement key generation for that parameter set. Implementations of the key generation and signature algorithms in this document shall only be validated for use within hardware cryptographic modules. The cryptographic modules shall be validated to provide FIPS 140-2 or FIPS 140-3  Level 3 or higher physical security, and the operational environment shall be non-modifiable or limited.8 In addition, a cryptographic module that implements the key generation or signature algorithms shall only operate in an approved mode of operation and shall not implement a bypass mode. The cryptographic module shall not allow for the export of private keying material. The entropy source for any approved random bit generator  used in the implementation shall be located inside the cryptographic moduleâ€™s physical boundary. In order to prevent the possible reuse of an OTS key, when the cryptographic module accepts a request to sign a message, the cryptographic module shall increment the leaf index of the private key (q in LMS, idx in XMSS, idx_sig in XMSSMT) and shall store the incremented leaf index value in nonvolatile storage before exporting a signature value or accepting another request to sign a message. The cryptographic module shall not use an OTS key to generate a digital signature more than one time.9 Cryptographic modules that implement LMS key and signature generation shall support at least one of the LM-OTS parameter sets in Section 4. For each LM-OTS parameter set supported by a cryptographic module, the cryptographic module shall support at least one LMS parameter set from Section 4 that uses the same hash function as the LM-OTS parameter set. Cryptographic modules that implement LMS key and signature generation shall generate random data in accordance with Section 6.1. Cryptographic modules that implement XMSS key and signature generation shall implement Algorithm 10 and Algorithm 12 from  for at least one of the XMSS parameter sets in Section 5. (The WOTS+ key generation method specified in Algorithm 10' in Section 7.2.1 shall be used.) Cryptographic modules that support implementation of XMSSMT key and signature generation shall implement Algorithm 10' and Algorithm 12' from Section 7.2.1 of this document for at least one of the XMSSMT parameter sets in Section 5. Cryptographic modules that implement XMSS or XMSSMT key and signature generation shall generate random data in accordance with Section 6.2. 8 See Section 4.6 of FIPS 140-2  and Section 7.6 of ISO/IEC 19790. 9 In some implementations of HSS or XMSSMT (e.g., Algorithm 16 in ), the root of the LMS or XMSS tree used to create the signature is signed by its parent each time a signature is generated. This results in an OTS key being used to generate a digital signature more than once. While the OTS key is used more than once, the message being signed is the same, so the result is to just recreate the same signature (as long as the randomizer value is the same each time). However, as noted in  and , such implementations are vulnerable to fault injection attacks. Implementations compliant with this publication must sign the root of each tree only once. The resulting signature may be stored within the cryptographic module, or it may be exported from the cryptographic module for storage elsewhere.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 29 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 8.2 Signature Verification Cryptographic modules that implement LMS signature verification shall support at least one of the LM-OTS parameter sets in Section 4. For each LM-OTS parameter set supported by a cryptographic module, the cryptographic module shall support at least one LMS parameter set from Section 4 that uses the same hash function as the LM-OTS parameter set. Cryptographic modules that implement XMSS signature verification shall implement Algorithm 14 of  for at least one of the parameter sets in Section 5. Cryptographic modules that implement XMSSMT signature verification shall implement Algorithm 17 of  for at least one of the parameter sets in Section 5.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 30 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 9 Security Considerations 9.1 One-Time Signature Key Reuse Both LMS and XMSS are stateful signature schemes. If an attacker were able to obtain signatures for two different messages created using the same one-time signature (OTS) key, then it would become computationally feasible for that attacker to create forgeries . As noted in , extreme care needs to be taken in order to avoid the risk that an OTS key will be reused accidentally. While the conformance requirements in Section 8.1 prevent many of the actions that could result in accidental OTS key reuse, cryptographic modules still need to be carefully designed to ensure that unexpected behavior cannot result in an OTS key being reused. In order to avoid reuse of an OTS key, the state of the private key must be updated each time a signature is generated. If the private key is stored in non-volatile memory, then the state of the key must be updated in the nonvolatile memory to mark an OTS key as unavailable before the corresponding signature that was generated using the OTS key is exported. Depending on the environment, this can be nontrivial to implement. With many operating systems, simply writing the update to a file is not sufficient because the write operation will be cached with the actual write to non-volatile memory occurring later. If the cryptographic module loses power or crashes before the write to non-volatile memory occurs, then the state update will be lost. If a signature were exported after the write operation was issued, but before the update was written to non- volatile memory, there would be a risk that the OTS key would be used again after the cryptographic module restarts. Some hardware cryptographic modules implement monotonic counters, which are guaranteed to increment each time the counterâ€™s value is read. When available, using the current value of a monotonic counter to determine which OTS key to use for a signature may be very helpful in avoiding unintentional reuse of an OTS key. 9.2 Hash Collisions For LMS and XMSS, as for the other approved digital signature schemes , the signature generation algorithm is not applied directly to the message but to a message digest generated by the underlying hash function. The security of any signature scheme depends on the inability of an attacker to find distinct messages with the same message digest. There are two ways that an attacker might find these distinct messages. The attacker could look for a message that has the same message digest as a message that has already been signed (a second preimage), or the attacker could look for any two messages that have the same message digest (a generic collision) and then try to get the private key holder (i.e., signer) to sign one of them . Finding a second preimage is much more difficult than finding a generic collision, and it would be infeasible for an attacker to find a second preimage with any of the hash functions allowed by this recommendation. LMS and XMSS both use randomized hashing. When a message is presented to be signed, a random value is created and prepended to the message, and the hash function is applied to this expanded message to produce the message digest. Prepending the random value makes it infeasible for anyone other than the signer to find a generic collision because finding a collisionNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 31 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 would require predicting the randomizing value. The randomized hashing process does not, however, impact the ability of a signer to create a generic collision since the signer, knowing the private key, can choose the random value to prepend to the message. The 192-bit hash functions described in this recommendation, SHA-256/192 and SHAKE256/192, offer significantly less resistance to generic collision searches than their 256-bit counterparts. In particular, a collision of the 192-bit functions may be found as the number of sampled inputs approaches 296, as opposed to 2128 for the 256-bit functions, and it may be possible for a signer with access to an extremely large amount of computing resources to sample 296 inputs. Consequently, one trade-off for the use of 192-bit hash functions in LMS and XMSS is the weakening of the verifierâ€™s assurance that the signer will not be able to change the message once the signature is revealed. This possibility does not affect the formal security properties of the schemes because it remains the case that only the signer could produce a valid signature on a message. 9.3 Revocation Although procedures for the revocation of a compromised key are outside the scope of this publication, the implementation of any signature scheme, in principle, should include such a procedure . For implementations of stateful hash-based signature schemes, which would be vulnerable in the event of OTS key reuse, revocation procedures would arguably be even more important. In practice, however, procedures for revocation that are timely, efficient, and robust are often difficult to implement. For applications with the characteristics described in Section 1.1, the difficulties would likely be magnified.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 32 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 References  Huelsing A, Butin D, Gazdag S, Rijneveld J, Mohaisen A (2018) XMSS: eXtended Merkle Signature Scheme. (Internet Research Task Force (IRTF)), IRTF Request for Comments (RFC) 8391. https://doi.org/10.17487/RFC8391  McGrew D, Curcio M, Fluhrer S (2019) Leighton-Micali Hash-Based Signatures. (Internet Research Task Force (IRTF)), IRTF Request for Comments (RFC) 8554. https://doi.org/10.17487/RFC8554  National Institute of Standards and Technology (2015) Secure Hash Standard (SHS). (U.S. Department of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 180-4. https://doi.org/10.6028/NIST.FIPS.180-4  National Institute of Standards and Technology (2013) Digital Signature Standard (DSS). (U.S. Department of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 186-4. https://doi.org/10.6028/NIST.FIPS.186-4  National Institute of Standards and Technology (2015) SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions. (U.S. Department of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/NIST.FIPS.202  Special Publication 800-90 series: Barker EB, Kelsey JM (2015) Recommendation for Random Number Generation Using Deterministic Random Bit Generators. (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP.800-90Ar1 SÃ¶nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recommendation for the Entropy Sources Used for Random Bit Generation. (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B. https://doi.org/10.6028/NIST.SP.800-90B Barker EB, Kelsey JM (2016) Recommendation for Random Bit Generator (RBG) Constructions. (National Institute of Standards and Technology, Gaithersburg, MD), (Second Draft) NIST Special Publication (SP) 800-90C. Available at https://csrc.nist.gov/publications/detail/sp/800-90c/draft  National Institute of Standards and Technology (2019) Post-Quantum Cryptography. Available at https://csrc.nist.gov/projects/post-quantum- cryptographyNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 33 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208  McGrew D, Kampanakis P, Fluhrer S, Gazdag S, Butin D, Buchmann J (2016) State Management for Hash-Based Signatures. Cryptology ePrint Archive, Report 2016/357. https://eprint.iacr.org/2016/357.pdf  GenÃªt A, Kannwischer MJ, Pelletier H, McLauchlan A (2018) Practical Fault Injection Attacks on SPHINCS. Cryptology ePrint Archive, Report 2018/674. https://eprint.iacr.org/2018/674  Castelnovi L, Martinelli A, Prest T (2018) Grafting trees: A fault attack against the SPHINCS framework. Post-Quantum Cryptography - 9th International Conference (PQCrypto 2018), Lecture Notes in Computer Science 10786, pp 165â€“184. https://doi.org/10.1007/978-3-319-79063-3_8  Fluhrer S (2017) Further Analysis of a Proposed Hash-Based Signature Standard. Cryptology ePrint Archive, Report 2017/553. https://eprint.iacr.org/2017/553.pdf  Buchmann J, Dahmen E, Hulsing A (2011) XMSS â€“ A Practical Forward Secure Signature Scheme based on Minimal Security Assumptions. Cryptology ePrint Archive, Report 2011/484. https://eprint.iacr.org/2011/484.pdf  Bruinderink LG, HÃ¼lsing A (2016) â€œOops, I did it againâ€ â€“ Security of One- Time Signatures under Two-Message Attacks. Cryptology ePrint Archive, Report 2016/1042. https://eprint.iacr.org/2016/1042.pdf  Perlner R, Cooper D (2009) Quantum Resistant Public Key Cryptography: A Survey. 8th Symposium on Identity and Trust on the Internet (IDtrust 2009), pp 85-93. https://doi.org/10.1145/1527017.1527028  Eaton E (2017) Leighton-Micali Hash-Based Signatures in the Quantum Random-Oracle Model. Cryptology ePrint Archive, Report 2017/607. https://eprint.iacr.org/2017/607  Bernstein DJ, HÃ¼lsing A, KÃ¶lbl S, Niederhagen R, Rijneveld J, Schwabe P (2019) The SPHINCS+ Signature Framework. Cryptology ePrint Archive, Report 2019/1086. https://eprint.iacr.org/2019/1086.pdf  Malkin T, Micciancio D, Miner S (2002) Efficient generic forward-secure signatures with an unbounded number of time periods. Advances in Cryptology â€” EUROCRYPT 2002, Lecture Notes in Computer Science 2332, pp 400â€“417. https://doi.org/10.1007/3-540-46035-7_27  Merkle RC (1979) Security, Authentication, and Public Key Systems. PhD thesis, Stanford University, June 1979. Available at https://www.merkle.com/papers/Thesis1979.pdfNIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 34 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208  National Institute of Standards and Technology (2001) Security Requirements for Cryptographic Modules. (U.S. Department of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 140-2, Change Notice 2 December 03, 2002. https://doi.org/10.6028/NIST.FIPS.140-2 National Institute of Standards and Technology (2019) Security Requirements for Cryptographic Modules. (U.S. Department of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 140-3. https://doi.org/10.6028/NIST.FIPS.140-3  Chen L, Jordan S, Liu Y-K, Moody D, Peralta R, Perlner RA, Smith-Tone D (2016) Report on Post-Quantum Cryptography. (National Institute of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report (IR) 8105. https://doi.org/10.6028/NIST.IR.8105  Sotirov A, Stevens M, Appelbaum J, Lenstra A, Molnar D, Osvik DA, de Weger B (2008) MD5 considered harmful today: Creating a rogue CA certificate. Available at https://www.win.tue.nl/hashclash/rogue-ca  Special Publication 800-57 series: Barker EB (2020) Recommendation for Key Management, Part 1: General. (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part 1, Rev. 5. https://doi.org/10.6028/NIST.SP.800-57pt1r5 Barker EB, Barker WC (2019) Recommendation for Key Management: Part 2 â€“ Best Practices for Key Management Organizations. (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part 2, Rev. 1. https://doi.org/10.6028/NIST.SP.800-57pt2r1 Barker EB, Dang QH (2015) Recommendation for Key Management, Part 3: Application-Specific Key Management Guidance. (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part 3, Rev. 1. https://doi.org/10.6028/NIST.SP.800-57pt3r1  Housley R (2019) Hash Of Root Key Certificate Extension. (Internet Engineering Task Force (IETF)), IETF Request for Comments (RFC) 8649. https://doi.org/10.17487/RFC8649NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 35 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Appendix Aâ€”LMS XDR Syntax Additions In order to support the LM-OTS and LMS parameter sets defined in Sections 4.2 through 4.4, the XDR syntax in Section 3.3 of  is extended as follows. For data structures of type or enum below, the values or case statements specified in this appendix are to be added to the union ones specified in Section 3.3 of . The numeric identifiers for the parameter sets defined in Sections 4.2 through 4.4 are marked as â€œTBD,â€ as they had not yet been assigned at the time this document was published. Once they are assigned, the numeric identifiers may be found at https://www.iana.org/assignments/leighton- micali-signatures/leighton-micali-signatures.xhtml. /* one-time signatures */ enum lmots_algorithm_type { lmots_sha256_n24_w1 = TBD, lmots_sha256_n24_w2 = TBD, lmots_sha256_n24_w4 = TBD, lmots_sha256_n24_w8 = TBD, lmots_shake_n32_w1 = TBD, lmots_shake_n32_w2 = TBD, lmots_shake_n32_w4 = TBD, lmots_shake_n32_w8 = TBD, lmots_shake_n24_w1 = TBD, lmots_shake_n24_w2 = TBD, lmots_shake_n24_w4 = TBD, lmots_shake_n24_w8 = TBD }; typedef opaque bytestring24; struct lmots_signature_n24_p200 { bytestring24 C; bytestring24 y; }; struct lmots_signature_n24_p101 { bytestring24 C; bytestring24 y; }; struct lmots_signature_n24_p51 { bytestring24 C; bytestring24 y; }; struct lmots_signature_n24_p26 {NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 36 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 bytestring24 C; bytestring24 y; }; union lmots_signature switch (lmots_algorithm_type type) { case lmots_sha256_n24_w1: lmots_signature_n24_p200 sig_n24_p200; case lmots_sha256_n24_w2: lmots_signature_n24_p101 sig_n24_p101; case lmots_sha256_n24_w4: lmots_signature_n24_p51 sig_n24_p51; case lmots_sha256_n24_w8: lmots_signature_n24_p26 sig_n24_p26; case lmots_shake_n32_w1: lmots_signature_n32_p265 sig_n32_p265; case lmots_shake_n32_w2: lmots_signature_n32_p133 sig_n32_p133; case lmots_shake_n32_w4: lmots_signature_n32_p67 sig_n32_p67; case lmots_shake_n32_w8: lmots_signature_n32_p34 sig_n32_p34; case lmots_shake_n24_w1: lmots_signature_n24_p200 sig_n24_p200; case lmots_shake_n24_w2: lmots_signature_n24_p101 sig_n24_p101; case lmots_shake_n24_w4: lmots_signature_n24_p51 sig_n24_p51; case lmots_shake_n24_w8: lmots_signature_n24_p26 sig_n24_p26; }; /* hash-based signatures (hbs) */ enum lms_algorithm_type { lms_sha256_n24_h5 = TBD, lms_sha256_n24_h10 = TBD, lms_sha256_n24_h15 = TBD, lms_sha256_n24_h20 = TBD, lms_sha256_n24_h25 = TBD, lms_shake_n32_h5 = TBD, lms_shake_n32_h10 = TBD, lms_shake_n32_h15 = TBD, lms_shake_n32_h20 = TBD, lms_shake_n32_h25 = TBD, lms_shake_n24_h5 = TBD, lms_shake_n24_h10 = TBD, lms_shake_n24_h15 = TBD,NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 37 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 lms_shake_n24_h20 = TBD, lms_shake_n24_h25 = TBD }; /* leighton-micali signatures (lms) */ union lms_path switch (lms_algorithm_type type) { case lms_sha256_n24_h5: case lms_shake_n24_h5: bytestring24 path_n24_h5; case lms_sha256_n24_h10: case lms_shake_n24_h10: bytestring24 path_n24_h10; case lms_sha256_n24_h15: case lms_shake_n24_h15: bytestring24 path_n24_h15; case lms_sha256_n24_h20: case lms_shake_n24_h20: bytestring24 path_n24_h20; case lms_sha256_n24_h25: case lms_shake_n24_h25: bytestring24 path_n24_h25; case lms_shake_n32_h5: bytestring32 path_n32_h5; case lms_shake_n32_h10: bytestring32 path_n32_h10; case lms_shake_n32_h15: bytestring32 path_n32_h15; case lms_shake_n32_h20: bytestring32 path_n32_h20; case lms_shake_n32_h25: bytestring32 path_n32_h25; }; struct lms_key_n24 { lmots_algorithm_type ots_alg_type; opaque I; opaque K; }; union lms_public_key switch (lms_algorithm_type type) { case lms_sha256_n24_h5: case lms_sha256_n24_h10: case lms_sha256_n24_h15: case lms_sha256_n24_h20: case lms_sha256_n24_h25:NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 38 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 case lms_shake_n24_h5: case lms_shake_n24_h10: case lms_shake_n24_h15: case lms_shake_n24_h20: case lms_shake_n24_h25: lms_key_n24 z_n24; case lms_shake_n32_h5: case lms_shake_n32_h10: case lms_shake_n32_h15: case lms_shake_n32_h20: case lms_shake_n32_h25: lms_key_n32 z_n32; };NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 39 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Appendix Bâ€”XMSS XDR Syntax Additions In order to support the XMSS parameter sets defined in Sections 5.2 through 5.4, the XDR syntax in Appendices A, B, and C of  is extended as follows. For data structures of type enum or below, the values or case statements specified in this appendix are to be added to the union ones specified in Appendices A, B, and C of . B.1 WOTS+ /* ots_algorithm_type identifies a particular signature algorithm */ enum ots_algorithm_type { wotsp-sha2_192 = 0x00000005, wotsp-shake256_256 = 0x00000006, wotsp-shake256_192 = 0x00000007, }; /* Byte strings */ typedef opaque bytestring24; union ots_signature switch (ots_algorithm_type type) { case wotsp-sha2_192: case wotsp-shake256_192: bytestring24 ots_sig_n24_len51; case wotsp-shake256_256: bytestring32 ots_sig_n32_len67; }; union ots_pubkey switch (ots_algorithm_type type) { case wotsp-sha2_192: case wotsp-shake256_192: bytestring24 ots_pubk_n24_len51; case wotsp-shake256_256: bytestring32 ots_pubk_n32_len67; }; B.2 XMSS /* Definition of parameter sets */ enum xmss_algorithm_type { xmss-sha2_10_192 = 0x0000000D, xmss-sha2_16_192 = 0x0000000E,NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 40 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 xmss-sha2_20_192 = 0x0000000F, xmss-shake256_10_256 = 0x00000010, xmss-shake256_16_256 = 0x00000011, xmss-shake256_20_256 = 0x00000012, xmss-shake256_10_192 = 0x00000013, xmss-shake256_16_192 = 0x00000014, xmss-shake256_20_192 = 0x00000015, }; /* Authentication path types */ union xmss_path switch (xmss_algorithm_type type) { case xmss-sha2_10_192: case xmss-shake256_10_192: bytestring24 path_n24_t10; case xmss-shake256_10_256: bytestring32 path_n32_t10; case xmss-sha2_16_192: case xmss-shake256_16_192: bytestring24 path_n24_t16; case xmss-shake256_16_256: bytestring32 path_n32_t16; case xmss-sha2_20_192: case xmss-shake256_20_192: bytestring24 path_n24_t20; case xmss-shake256_20_256: bytestring32 path_n32_t20; }; /* Types for XMSS random strings */ union random_string_xmss switch (xmss_algorithm_type type) { case xmss-sha2_10_192: case xmss-sha2_16_192: case xmss-sha2_20_192: case xmss-shake256_10_192: case xmss-shake256_16_192: case xmss-shake256_20_192: bytestring24 rand_n24;NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 41 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 case xmss-shake256_10_256: case xmss-shake256_16_256: case xmss-shake256_20_256: bytestring32 rand_n32; }; /* Corresponding WOTS+ type for given XMSS type */ union xmss_ots_signature switch (xmss_algorithm_type type) { case xmss-sha2_10_192: case xmss-sha2_16_192: case xmss-sha2_20_192: wotsp-sha2_192; case xmss-shake256_10_256: case xmss-shake256_16_256: case xmss-shake256_20_256: wotsp-shake256_256; case xmss-shake256_10_192: case xmss-shake256_16_192: case xmss-shake256_20_192: wotsp-shake256_192; }; /* Types for bitmask seed */ union seed switch (xmss_algorithm_type type) { case xmss-sha2_10_192: case xmss-sha2_16_192: case xmss-sha2_20_192: case xmss-shake256_10_192: case xmss-shake256_16_192: case xmss-shake256_20_192: bytestring24 seed_n24; case xmss-shake256_10_256: case xmss-shake256_16_256: case xmss-shake256_20_256: bytestring32 seed_n32; }; /* Types for XMSS root node */ union xmss_root switch (xmss_algorithm_type type) { case xmss-sha2_10_192: case xmss-sha2_16_192:NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 42 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 case xmss-sha2_20_192: case xmss-shake256_10_192: case xmss-shake256_16_192: case xmss-shake256_20_192: bytestring24 root_n24; case xmss-shake256_10_256: case xmss-shake256_16_256: case xmss-shake256_20_256: bytestring32 root_n32; }; B.3 XMSSMT /* Definition of parameter sets */ enum xmssmt_algorithm_type { xmssmt-sha2_20/2_192 = 0x00000021, xmssmt-sha2_20/4_192 = 0x00000022, xmssmt-sha2_40/2_192 = 0x00000023, xmssmt-sha2_40/4_192 = 0x00000024, xmssmt-sha2_40/8_192 = 0x00000025, xmssmt-sha2_60/3_192 = 0x00000026, xmssmt-sha2_60/6_192 = 0x00000027, xmssmt-sha2_60/12_192 = 0x00000028, xmssmt-shake256_20/2_256 = 0x00000029, xmssmt-shake256_20/4_256 = 0x0000002A, xmssmt-shake256_40/2_256 = 0x0000002B, xmssmt-shake256_40/4_256 = 0x0000002C, xmssmt-shake256_40/8_256 = 0x0000002D, xmssmt-shake256_60/3_256 = 0x0000002E, xmssmt-shake256_60/6_256 = 0x0000002F, xmssmt-shake256_60/12_256 = 0x00000030, xmssmt-shake256_20/2_192 = 0x00000031, xmssmt-shake256_20/4_192 = 0x00000032, xmssmt-shake256_40/2_192 = 0x00000033, xmssmt-shake256_40/4_192 = 0x00000034, xmssmt-shake256_40/8_192 = 0x00000035, xmssmt-shake256_60/3_192 = 0x00000036, xmssmt-shake256_60/6_192 = 0x00000037, xmssmt-shake256_60/12_192 = 0x00000038, }; /* Type for XMSS^MT key pair index */NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 43 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 /* Depends solely on h */ union idx_sig_xmssmt switch (xmss_algorithm_type type) { case xmssmt-sha2_20/2_192: case xmssmt-sha2_20/4_192: case xmssmt-shake256_20/2_256: case xmssmt-shake256_20/4_256: case xmssmt-shake256_20/2_192: case xmssmt-shake256_20/4_192: bytestring3 idx3; case xmssmt-sha2_40/2_192: case xmssmt-sha2_40/4_192: case xmssmt-sha2_40/8_192: case xmssmt-shake256_40/2_256: case xmssmt-shake256_40/4_256: case xmssmt-shake256_40/8_256: case xmssmt-shake256_40/2_192: case xmssmt-shake256_40/4_192: case xmssmt-shake256_40/8_192: bytestring5 idx5; case xmssmt-sha2_60/3_192: case xmssmt-sha2_60/6_192: case xmssmt-sha2_60/12_192: case xmssmt-shake256_60/3_256: case xmssmt-shake256_60/6_256: case xmssmt-shake256_60/12_256: case xmssmt-shake256_60/3_192: case xmssmt-shake256_60/6_192: case xmssmt-shake256_60/12_192: bytestring8 idx8; }; union random_string_xmssmt switch (xmssmt_algorithm_type type) { case xmssmt-sha2_20/2_192: case xmssmt-sha2_20/4_192: case xmssmt-sha2_40/2_192: case xmssmt-sha2_40/4_192: case xmssmt-sha2_40/8_192: case xmssmt-sha2_60/3_192: case xmssmt-sha2_60/6_192: case xmssmt-sha2_60/12_192: case xmssmt-shake256_20/2_192: case xmssmt-shake256_20/4_192: case xmssmt-shake256_40/2_192: case xmssmt-shake256_40/4_192:NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 44 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 case xmssmt-shake256_40/8_192: case xmssmt-shake256_60/3_192: case xmssmt-shake256_60/6_192: case xmssmt-shake256_60/12_192: bytestring24 rand_n24; case xmssmt-shake256_20/2_256: case xmssmt-shake256_20/4_256: case xmssmt-shake256_40/2_256: case xmssmt-shake256_40/4_256: case xmssmt-shake256_40/8_256: case xmssmt-shake256_60/3_256: case xmssmt-shake256_60/6_256: case xmssmt-shake256_60/12_256: bytestring32 rand_n32; }; /* Type for reduced XMSS signatures */ union xmss_reduced (xmss_algorithm_type type) { case xmssmt-sha2_20/2_192: case xmssmt-sha2_40/4_192: case xmssmt-sha2_60/6_192: case xmssmt-shake256_20/2_192: case xmssmt-shake256_40/4_192: case xmssmt-shake256_60/6_192: bytestring24 xmss_reduced_n24_t61; case xmssmt-sha2_20/4_192: case xmssmt-sha2_40/8_192: case xmssmt-sha2_60/12_192: case xmssmt-shake256_20/4_192: case xmssmt-shake256_40/8_192: case xmssmt-shake256_60/12_192: bytestring24 xmss_reduced_n24_t56; case xmssmt-sha2_40/2_192: case xmssmt-sha2_60/3_192: case xmssmt-shake256_40/2_192: case xmssmt-shake256_60/3_192: bytestring24 xmss_reduced_n24_t71; case xmssmt-shake256_20/2_256: case xmssmt-shake256_40/4_256: case xmssmt-shake256_60/6_256: bytestring32 xmss_reduced_n32_t77;NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 45 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 case xmssmt-shake256_20/4_256: case xmssmt-shake256_40/8_256: case xmssmt-shake256_60/12_256: bytestring32 xmss_reduced_n32_t72; case xmssmt-shake256_40/2_256: case xmssmt-shake256_60/3_256: bytestring32 xmss_reduced_n32_t87; }; /* xmss_reduced_array depends on d */ union xmss_reduced_array (xmss_algorithm_type type) { case xmssmt-sha2_20/2_192: case xmssmt-sha2_40/2_192: case xmssmt-shake256_20/2_256: case xmssmt-shake256_40/2_256: case xmssmt-shake256_20/2_192: case xmssmt-shake256_40/2_192: xmss_reduced xmss_red_arr_d2; case xmssmt-sha2_60/3_192: case xmssmt-shake256_60/3_256: case xmssmt-shake256_60/3_192: xmss_reduced xmss_red_arr_d3; case xmssmt-sha2_20/4_192: case xmssmt-sha2_40/4_192: case xmssmt-shake256_20/4_256: case xmssmt-shake256_40/4_256: case xmssmt-shake256_20/4_192: case xmssmt-shake256_40/4_192: xmss_reduced xmss_red_arr_d4; case xmssmt-sha2_60/6_192: case xmssmt-shake256_60/6_256: case xmssmt-shake256_60/6_192: xmss_reduced xmss_red_arr_d6; case xmssmt-sha2_40/8_192: case xmssmt-shake256_40/8_256: case xmssmt-shake256_40/8_192: xmss_reduced xmss_red_arr_d8; case xmssmt-sha2_60/12_192: case xmssmt-shake256_60/12_256: case xmssmt-shake256_60/12_192:NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 46 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 xmss_reduced xmss_red_arr_d12; }; /* Types for bitmask seed */ union seed switch (xmssmt_algorithm_type type) { case xmssmt-sha2_20/2_192: case xmssmt-sha2_20/4_192: case xmssmt-sha2_40/2_192: case xmssmt-sha2_40/4_192: case xmssmt-sha2_40/8_192: case xmssmt-sha2_60/3_192: case xmssmt-sha2_60/6_192: case xmssmt-sha2_60/12_192: case xmssmt-shake256_20/2_192: case xmssmt-shake256_20/4_192: case xmssmt-shake256_40/2_192: case xmssmt-shake256_40/4_192: case xmssmt-shake256_40/8_192: case xmssmt-shake256_60/3_192: case xmssmt-shake256_60/6_192: case xmssmt-shake256_60/12_192: bytestring24 seed_n24; case xmssmt-shake256_20/2_256: case xmssmt-shake256_20/4_256: case xmssmt-shake256_40/2_256: case xmssmt-shake256_40/4_256: case xmssmt-shake256_40/8_256: case xmssmt-shake256_60/3_256: case xmssmt-shake256_60/6_256: case xmssmt-shake256_60/12_256: bytestring32 seed_n32; }; /* Types for XMSS^MT root node */ union xmssmt_root switch (xmssmt_algorithm_type type) { case xmssmt-sha2_20/2_192: case xmssmt-sha2_20/4_192: case xmssmt-sha2_40/2_192: case xmssmt-sha2_40/4_192: case xmssmt-sha2_40/8_192: case xmssmt-sha2_60/3_192: case xmssmt-sha2_60/6_192: case xmssmt-sha2_60/12_192:NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 47 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 case xmssmt-shake256_20/2_192: case xmssmt-shake256_20/4_192: case xmssmt-shake256_40/2_192: case xmssmt-shake256_40/4_192: case xmssmt-shake256_40/8_192: case xmssmt-shake256_60/3_192: case xmssmt-shake256_60/6_192: case xmssmt-shake256_60/12_192: bytestring24 root_n24; case xmssmt-shake256_20/2_256: case xmssmt-shake256_20/4_256: case xmssmt-shake256_40/2_256: case xmssmt-shake256_40/4_256: case xmssmt-shake256_40/8_256: case xmssmt-shake256_60/3_256: case xmssmt-shake256_60/6_256: case xmssmt-shake256_60/12_256: bytestring32 root_n32; };NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 48 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 Appendix Câ€”Provable Security Analysis This appendix briefly summarizes the formal security model and proofs of security of the LMS and XMSS signature schemes and provides a short discussion comparing these models and proofs. C.1 The Random Oracle Model In the random oracle model (ROM), there is a publicly accessible random oracle that both the user and the adversary can send queries to and receive responses from at any time. A random oracle H is a hypothetical, interactive black-box algorithm that obeys the following rules: 1. Every time the algorithm H receives a new input string s, it generates an output t uniformly at random from its output space and returns the response t. The algorithm H then records the pair (s, t) for future use. 2. If the algorithm H is ever queried in the future with some prior input s, it will always return the same output t according to its recorded memory. Alternatively, the random oracle H can be described as a non-interactive but exponentially large look-up table initialized with truly random outputs t for each possible input string s. To say that a cryptographic security proof is done in the random oracle model means that every use of a particular function (e.g., in the case here, the compression function that is used to perform hashes) is replaced by a query to the random oracle H. This simplifies security claims because, for example, it becomes easy to prove upper bounds on the likelihood of producing a second preimage within a fixed number of queries to H. On the other hand, (compression) functions in the real world are neither interactive nor have exponentially large descriptions, so they cannot truly behave like a random oracle. It is therefore desirable to have a cryptographic security proof that avoids using the random oracle model. However, this often leads to less efficient cryptographic systems, or it is not yet known how to perform a proof without appealing to the random oracle model, or both. So, as a matter of real-world pragmatism, the ROM is commonly used. C.2 The Quantum Random Oracle Model The quantum random oracle model (QROM) is similar to the ROM, except that it is additionally assumed that all parties (in particular, the adversary) have quantum computers and can query the random oracle H in superposition. (In the real world, the random oracle H is still instantiated as a compression function or something similar, in accordance with the cryptosystemâ€™s specification.) While this complicates security claims as compared to the ROM, it more accurately models the power of an adversary that has access to a large-scale quantum device for its cryptanalysis when attacking a real-world scheme.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 49 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 C.3 LMS Security Proof In , the author considers a particular experiment in the random oracle model in which the adversary is given a series of strings with prefixes (in a randomly chosen but structured manner) and hash targets. The attackerâ€™s goal is to find one more string that has the same prefix and hash target as any of its input strings. The author proves an upper bound on the adversaryâ€™s ability to compute first or second preimages from these strings (by querying the compression function modeled as a random oracle). Then, the author reduces the problem of forging a signature in LMS to this stated experiment, concluding that the same upper bounds apply to the problem of producing forgeries against LMS. This random oracle model proof critically depends on the randomness of the prefixes used in LMS, which means that LMS in the real world critically depends on the pseudorandomness of the prefixes. Further, in , the same proof is carried out in the QROM. C.4 XMSS Security Proof In , a security analysis for the original (academic publication) version of XMSS is given under the following assumptions: 1. The function family {f } used to construct Winternitz signatures is pseudorandom. This k means that if the bit string k is chosen uniformly at random, then an adversary given black-box access to the function f cannot distinguish this black box from a random k function within a polynomial number of queries (except with negligible probability). 2. The hash function family {h } is second preimage-resistant. This means that if bit strings k k and m are chosen uniformly at random, then an adversary given k and m cannot construct m' â‰  m such that h (m') = h (m) in polynomial time (except with negligible k k probability). The proof in  asserts that if both of these assumptions are true, then XMSS is existentially unforgeable under adaptive chosen message attacks (EUF-CMA) in the standard model. However, in the current version of XMSSMT , the security analysis differs somewhat. In the standard model,  shows that XMSSMT is EUF-CMA. Further,  shows that XMSSMT is post-quantum existentially unforgeable under adaptive chosen message attacks with respect to the QROM. In a little more detail, the current version of XMSS uses two types of assumptions: 1. A standard model assumption that the hash function h , used for the one-time signatures k and tree node computations, is post-quantum, multi-function, multi-target decisional second-preimage-resistant.NIST SP 800-208 RECOMMENDATION FOR STATEFUL HASH-BASED SIGNATURE SCHEMES 50 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-208 2. A (quantum) random oracle model assumption that the pseudorandom function f , used to k generate pseudorandom values for randomized hashing and computing bitmasks as blinding keys, may be validly modeled as a quantum random oracle H. C.5 Comparison of the Security Models and Proofs of LMS and XMSS Generally speaking, both LMS and XMSS are supported by sound security proofs under commonly used cryptographic hardness assumptions. That is, if these cryptographic assumptions are true, then both schemes are provably shown to be existentially unforgeable under chosen message attack, even against an adversary that has access to a large-scale quantum computer for use in its forgery attack. The main difference between these schemesâ€™ security analyses comes down to the use (and the degree of use) of the random oracle or quantum random oracle models. Along these lines, the difference between the (standard model/real world) cryptographic assumption that some function family {f } is pseudorandom and the use of the random oracle model is briefly pointed out. For a k function f to be a pseudorandom function in the real world, it should be the case that the bit k string k used as the key to the function remains private, meaning that it is not in the view of the adversary at any point of the security experiment. On the other hand, a random oracle H achieves the same pseudorandomness (or even randomness) properties of a pseudorandom function f , but k no key k is necessarily associated with the random oracle. Indeed, all inputs to the random oracle H may be known to all parties and, in particular, to the adversary. Therefore, using the random oracle model clearly involves making a stronger assumption about the (limits of the) cryptanalytic power of the adversary. That said, a security proof is either entirely a â€œreal-world proof,â€ which does not use the random oracle model, or it appeals to the random oracle methodology in some manner. The security analysis of the current version of XMSS only uses the random oracle H when performing randomized hashing and computing bitmasks, whereas LMS uses the random oracle H to a greater degree (modeling the compression function as a random oracle). However, it remains the case that both schemes in their modern form are ultimately proven secure using the ROM and QROM. Therefore, the cryptographic hardness assumptions made by LMS and XMSS in order to achieve existential unforgeability under chosen message attack (EUF-CMA) may be viewed as substantially similar and worthy of essentially equal confidence. As such, the practitionerâ€™s decision to deploy one scheme or the other should primarily depend on other factors, such as the efficiency demands for a given deployment environment or the other security considerations enumerated earlier in this document.