FIPS 203 Federal Information Processing Standards Publication Module-Lattice-Based Key-Encapsulation Mechanism Standard Category: Computer Security Subcategory: Cryptography Information Technology Laboratory National Institute of Standards and Technology Gaithersburg, MD 20899-8900 This publication is available free of charge from: https://doi.org/10.6028/NIST.FIPS.203 Published August 13, 2024 U.S. Department of Commerce Gina M. Raimondo, Secretary National Institute of Standards and Technology Laurie E. Locascio, NIST Director and Under Secretary of Commerce for Standards and TechnologyForeword The Federal Information Processing Standards (FIPS) Publication Series of the National Institute of Stan- dards and Technology is the official series of publications relating to standards and guidelines developed under 15 U.S.C. 278g-3, and issued by the Secretary of Commerce under 40 U.S.C. 11331. Comments concerning this Federal Information Processing Standard publication are welcomed and should be submitted using the contact information in the â€œInquiries and Commentsâ€ clause of the announcement section. Kevin M. Stine, Director Information Technology LaboratoryFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Abstract A key-encapsulation mechanism (KEM) is a set of algorithms that, under certain conditions, can be used by two parties to establish a shared secret key over a public channel. A shared secret key that is securely established using a KEM can then be used with symmetric-key cryptographic algorithms to perform basic tasks in secure communications, such as encryption and authentication. This standard specifies a key-encapsulation mechanism called ML-KEM. The security of ML-KEM is related to the computational difficulty of the Module Learning with Errors problem. At present, ML-KEM is believed to be secure, even against adversaries who possess a quantum computer. This standard specifies three parameter sets for ML-KEM. In order of increasing security strength and decreasing performance, these are ML-KEM-512, ML-KEM-768, and ML-KEM-1024. Keywords: computer security; cryptography; encryption; Federal Information Processing Stan- dards; key-encapsulation mechanism; lattice-based cryptography; post-quantum; public-key cryptography.FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Federal Information Processing Standards Publication 203 Published: August 13, 2024 Effective: August 13, 2024 Announcing the Module-Lattice-Based Key-Encapsulation Mechanism Standard Federal Information Processing Standards (FIPS) publications are developed by the National Institute of Standards and Technology (NIST) under 15 U.S.C. 278g-3 and issued by the Secretary of Commerce under 40 U.S.C. 11331. 1. Name of Standard. Module-Lattice-Based Key-Encapsulation Mechanism Standard (FIPS 203). 2. Category of Standard. Computer Security. Subcategory. Cryptography. 3. Explanation. A cryptographic key (or simply â€œkeyâ€) is represented in a computer as a string of bits. A shared secret key is a cryptographic key that is computed jointly by two parties (e.g., Alice and Bob) using a set of algorithms. Under certain conditions, these algorithms ensure that both parties will produce the same key and that this key is secret from adversaries. Such a shared secret key can then be used with symmetric-key cryptographic algorithms (specified in other NIST standards) to perform tasks such as encryption and authentication of digital information. This standard specifies a set of algorithms for establishing a shared secret key. While there are many methods for establishing a shared secret key, the particular method described in this standard is a key-encapsulation mechanism (KEM). In a KEM, the computation of the shared secret key begins with Alice generating a decapsu- lation key and an encapsulation key. Alice keeps the decapsulation key private and makes the encapsulation key available to Bob. Bob then uses Aliceâ€™s encapsulation key to generate one copy of a shared secret key along with an associated ciphertext. Bob then sends the ciphertext to Alice. Finally, Alice uses the ciphertext from Bob along with Aliceâ€™s private decapsulation key to compute another copy of the shared secret key. The security of the particular KEM specified in this standard is related to the computational difficulty of solving certain systems of noisy linear equations, specifically the Module Learn- ing With Errors (MLWE) problem. At present, it is believed that this particular method of establishing a shared secret key is secure, even against adversaries who possess a quantum computer. In the future, additional KEMs may be specified and approved in FIPS publications or in NIST Special Publications. 4. Approving Authority. Secretary of Commerce. 5. Maintenance Agency. Department of Commerce, National Institute of Standards and Tech- nology, Information Technology Laboratory (ITL). iFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 6. Applicability. Federal Information Processing Standards apply to information systems used or operated by federal agencies or by a contractor of an agency or other organization on behalf of an agency. They do not apply to national security systems as defined in 44 U.S.C. 3552. This standard, or other FIPS or NIST Special Publications that specify alternative mechanisms, shall be used wherever the establishment of a shared secret key (or shared secret from which keying material can be generated) is required for federal applications, including the use of such a key with symmetric-key cryptographic algorithms, in accordance with applicable Office of Management and Budget and agency policies. The adoption and use of this standard are available to private and commercial organizations. 7. Implementations. A key-encapsulation mechanism may be implemented in software, firmware, hardware, or any combination thereof. For every computational procedure that is specified in this standard, a conforming implementation may replace the given set of steps with any mathematically equivalent set of steps. In other words, different procedures that produce the correct output for every input are permitted. NIST will develop a validation program to test implementations for conformance to the algorithms in this standard. Information about validation programs is available at https: //csrc.nist.gov/projects/cmvp. Example values will be available at https://csrc.nist.gov/proj ects/cryptographic-standards-and-guidelines/example-values. 8. Other Approved Security Functions. Implementations that comply with this standard shall employ cryptographic algorithms that have been approved for protecting Federal Government-sensitive information. Approved cryptographic algorithms and techniques include those that are either: (a) Specified in a Federal Information Processing Standards (FIPS) publication, (b) Adopted in a FIPS or NIST recommendation, or (c) Specified in the list of approved security functions in SP 800-140C. 9. Export Control. Certain cryptographic devices and technical data regarding them are subject to federal export controls. Exports of cryptographic modules that implement this standard and technical data regarding them must comply with all federal laws and regulations and be licensed by the Bureau of Industry and Security of the U.S. Department of Commerce. Information about export regulations is available at https://www.bis.doc.gov. 10. Patents. NIST has entered into two patent license agreements to facilitate the adoption of NISTâ€™s announced selection of the PQC key-encapsulation mechanism CRYSTALS-KYBER. NIST and the licensing parties share a desire, in the public interest, the licensed patents be freely available to be practiced by any implementer of the ML-KEM algorithm as published by NIST. ML-KEM is the name given to the algorithm in this standard derived from CRYSTALS-KYBER. For a summary and extracts from the license, please see https://csrc.nist.gov/csrc/media/P rojects/post-quantum-cryptography/documents/selected-algos-2022/nist-pqc-license-sum mary-and-excerpts.pdf. Implementation of the algorithm specified in the standard may be covered by U.S. and foreign patents of which NIST is not aware. iiFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 11. Implementation Schedule. This standard becomes effective immediately upon final publica- tion. 12. Specifications. Federal Information Processing Standards (FIPS) 203, Module-Lattice-Based Key-Encapsulation Mechanism Standard (affixed). 13. Qualifications. In applications, the security guarantees of a KEM only hold under certain conditions (see SP 800-227 ). One such condition is the secrecy of several values, including the randomness used by the two parties, the decapsulation key, and the shared secret key itself. Users shall, therefore, guard against the disclosure of these values. While it is the intent of this standard to specify general requirements for implementing ML-KEM algorithms, conformance to this standard does not ensure that a particular imple- mentation is secure. It is the responsibility of the implementer to ensure that any module that implements a key establishment capability is designed and built in a secure manner. Similarly, the use of a product containing an implementation that conforms to this standard does not guarantee the security of the overall system in which the product is used. The re- sponsible authority in each agency or department shall ensure that an overall implementation provides an acceptable level of security. NIST will continue to follow developments in the analysis of the ML-KEM algorithm. As with its other cryptographic algorithm standards, NIST will formally reevaluate this standard every five years. Both this standard and possible threats that reduce the security provided through the use of this standard will undergo review by NIST as appropriate, taking into account newly available analysis and technology. In addition, the awareness of any breakthrough in technology or any mathematical weakness of the algorithm will cause NIST to reevaluate this standard and provide necessary revisions. 14. Waiver Procedure. The Federal Information Security Management Act (FISMA) does not allow for waivers to Federal Information Processing Standards (FIPS) that are made mandatory by the Secretary of Commerce. 15. Where to Obtain Copies of the Standard. This publication is available by accessing https: //csrc.nist.gov/publications. Other computer security publications are available at the same website. 16. How to Cite This Publication. NIST has assigned NIST FIPS 203 as the publication identifier for this FIPS, per the NIST Technical Series Publication Identifier Syntax. NIST recommends that it be cited as follows: National Institute of Standards and Technology (2024) Module-Lattice-Based Key- Encapsulation Mechanism Standard. (Department of Commerce, Washington, D.C.), Federal Information Processing Standards Publication (FIPS) NIST FIPS 203. https://doi.org/10.6028/NIST.FIPS.203 17. Inquiries and Comments. Inquiries and comments about this FIPS may be submitted to fips-203-comments@nist.gov. iiiFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Federal Information Processing Standards Publication 203 Specification for the Module-Lattice-Based Key-Encapsulation Mechanism Standard Table of Contents 1 Introduction 1 1.1 Purpose and Scope 1 1.2 Context 1 2 Terms, Acronyms, and Notation 2 2.1 Terms and Definitions 2 2.2 Acronyms 4 2.3 Mathematical Symbols 5 2.4 Interpreting the Pseudocode 6 2.4.1 Data Types 7 2.4.2 Loop Syntax 7 2.4.3 Arithmetic With Arrays of Integers 7 2.4.4 Representations of Algebraic Objects 8 2.4.5 Arithmetic With Polynomials and NTT Representations 9 2.4.6 Matrices and Vectors 9 2.4.7 Arithmetic With Matrices and Vectors 10 2.4.8 Applying Algorithms to Arrays, Examples 11 3 Overview of the ML-KEM Scheme 12 3.1 Key-Encapsulation Mechanisms 12 3.2 The ML-KEM Scheme 13 3.3 Requirements for ML-KEM Implementations 15 4 Auxiliary Algorithms 18 4.1 Cryptographic Functions 18 4.2 General Algorithms 20 4.2.1 Conversion and Compression Algorithms 20 4.2.2 Sampling Algorithms 22 4.3 The Number-Theoretic Transform 24 ivFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 4.3.1 Multiplication in the NTT Domain 27 5 The K-PKE Component Scheme 28 5.1 K-PKE Key Generation 28 5.2 K-PKE Encryption 29 5.3 K-PKE Decryption 31 6 Main Internal Algorithms 32 6.1 Internal Key Generation 32 6.2 Internal Encapsulation 32 6.3 Internal Decapsulation 33 7 The ML-KEM Key-Encapsulation Mechanism 35 7.1 ML-KEM Key Generation 35 7.2 ML-KEM Encapsulation 36 7.3 ML-KEM Decapsulation 37 8 Parameter Sets 39 References 41 Appendix A â€” Precomputed Values for the NTT 44 Appendix B â€” SampleNTT Loop Bounds 46 Appendix C â€” Differences From the CRYSTALS-KYBER Submission 47 C.1 Differences Between CRYSTALS-KYBER and FIPS 203 Initial Public Draft 47 C.2 Changes From FIPS 203 Initial Public Draft 47 vFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM List of Tables Table 1 Decapsulation failure rates for ML-KEM 15 Table 2 Approved parameter sets for ML-KEM 39 Table 3 Sizes (in bytes) of keys and ciphertexts of ML-KEM 39 Table 4 While-loop limits and probabilities of occurrence for SampleNTT 46 List of Figures Figure 1 A simple view of key establishment using a KEM 12 List of Algorithms Algorithm 1 ForExample() . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8 Algorithm 2 SHAKE128example(str ,â€¦,str ,ğ‘ ,â€¦,ğ‘ ) . . . . . . . . . . . . . 19 1 ğ‘š 1 â„“ Algorithm 3 BitsToBytes(ğ‘) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 Algorithm 4 BytesToBits(ğµ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20 Algorithm 5 ByteEncode (ğ¹ ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 ğ‘‘ Algorithm 6 ByteDecode (ğµ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22 ğ‘‘ Algorithm 7 SampleNTT(ğµ) . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23 Algorithm 8 SamplePolyCBD (ğµ) . . . . . . . . . . . . . . . . . . . . . . . . . 23 ğœ‚ Algorithm 9 NTT(ğ‘“) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 Algorithm 10 NTTâˆ’1(ğ‘“)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26 Algorithm 11 MultiplyNTTs(ğ‘“,Ì‚ ğ‘”)Ì‚ . . . . . . . . . . . . . . . . . . . . . . . . . . 27 Algorithm 12 BaseCaseMultiply(ğ‘ ,ğ‘ ,ğ‘ ,ğ‘ ,ğ›¾) . . . . . . . . . . . . . . . . . . 27 0 1 0 1 Algorithm 13 K-PKE.KeyGen(ğ‘‘) . . . . . . . . . . . . . . . . . . . . . . . . . . . 29 Algorithm 14 K-PKE.Encrypt(ek ,ğ‘š,ğ‘Ÿ) . . . . . . . . . . . . . . . . . . . . . . . 30 PKE Algorithm 15 K-PKE.Decrypt(dk ,ğ‘) . . . . . . . . . . . . . . . . . . . . . . . . 31 PKE Algorithm 16 ML-KEM.KeyGen_internal(ğ‘‘,ğ‘§) . . . . . . . . . . . . . . . . . . . . 32 Algorithm 17 ML-KEM.Encaps_internal(ek,ğ‘š) . . . . . . . . . . . . . . . . . . . 33 Algorithm 18 ML-KEM.Decaps_internal(dk,ğ‘) . . . . . . . . . . . . . . . . . . . . 34 Algorithm 19 ML-KEM.KeyGen() . . . . . . . . . . . . . . . . . . . . . . . . . . . 35 Algorithm 20 ML-KEM.Encaps(ek) . . . . . . . . . . . . . . . . . . . . . . . . . . 37 Algorithm 21 ML-KEM.Decaps(dk,ğ‘) . . . . . . . . . . . . . . . . . . . . . . . . 38 viFIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 1. Introduction 1.1 Purpose and Scope This standard specifies the Module-Lattice-Based Key-Encapsulation Mechanism (ML-KEM). A key-encapsulation mechanism (KEM) is a set of algorithms that can be used to establish a shared secret key between two parties communicating over a public channel. A KEM is a particular type of key establishment scheme. Other NIST-approved key establishment schemes are specified in NIST Special Publication (SP) 800-56A, Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm-Based Cryptography , and SP 800-56B, Recommendation for Pair-Wise Key Establishment Schemes Using Integer Factorization Cryptography . The key establishment schemes specified in SP 800-56A and SP 800-56B are vulnerable to attacks that use sufficiently-capable quantum computers. ML-KEM is an approved alternative that is presently believed to be secure, even against adversaries in possession of a large-scale fault-tolerant quantum computer. ML-KEM is derived from the round-three version of the CRYSTALS-KYBER KEM , a submission in the NIST Post-Quantum Cryptography Standardization project. For the differences between ML-KEM and CRYSTALS-KYBER, see Appendix C. This standard specifies the algorithms and parameter sets of the ML-KEM scheme. It aims to provide sufficient information to implement ML-KEM in a manner that can pass validation (see https://csrc.nist.gov/projects/cryptographic-module-validation-program). For general definitions and properties of KEMs, including requirements for the secure use of KEMs in applications, see SP 800-227 . This standard specifies three parameter sets for ML-KEM that offer different trade-offs in security strength versus performance. All three parameter sets of ML-KEM are approved to protect sensitive, non-classified communication systems of the U.S. Federal Government. 1.2 Context Over the past several years, there has been steady progress toward building quantum computers. If large-scale quantum computers are realized, the security of many commonly used public-key cryptosystems will be at risk. This would include key-establishment schemes and digital signature schemes whose security depends on the difficulty of solving the integer factorization and discrete logarithm problems (both over finite fields and elliptic curves). As a result, in 2016, NIST initiated a public Post-Quantum Cryptography (PQC) Standardization process to select quantum-resistant public-key cryptographic algorithms. A total of 82 candidate algorithms were submitted to NIST for consideration. After three rounds of evaluation and analysis, NIST selected the first four algorithms for stan- dardization. These algorithms are intended to protect sensitive U.S. Government information well into the foreseeable future, including after the advent of cryptographically-relevant quan- tum computers. This standard specifies a variant of the selected algorithm CRYSTALS-KYBER, a lattice-based key-encapsulation mechanism (KEM) designed by Peter Schwabe, Roberto Avanzi, Joppe Bos, LÃ©o Ducas, Eike Kiltz, TancrÃ¨de Lepoint, Vadim Lyubashevsky, John Schanck, Gregor Seiler, Damien StehlÃ©, and Jintai Ding . Throughout this standard, the KEM specified here will be referred to as ML-KEM, as it is based on the Module Learning With Errors assumption. 1FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 2. Terms, Acronyms, and Notation 2.1 Terms and Definitions approved FIPS-approved and/or NIST-recommended. An algorithm or technique that is either 1) specified in a FIPS or NIST recommendation, 2) adopted in a FIPS or NIST recommendation, or 3) specified in a list of NIST-approved security functions. (KEM) ciphertext A bit string that is produced by encapsulation and used as an input to decapsulation. cryptographic The set of hardware, software, and/or firmware that implements ap- module proved cryptographic functions (including key generation) that are con- tained within the cryptographic boundary of the module. decapsulation The process of applying the Decaps algorithm of a KEM. This algorithm accepts a KEM ciphertext and the decapsulation key as input and pro- duces a shared secret key as output. decapsulation key A cryptographic key produced by a KEM during key generation and used during the decapsulation process. The decapsulation key must be kept private and must be destroyed after it is no longer needed. (See Section 3.3.) decryption key A cryptographic key that is used with a PKE in order to decrypt cipher- texts into plaintexts. The decryption key must be kept private and must be destroyed after it is no longer needed. destroy An action applied to a key or other piece of secret data. After a piece of secret data is destroyed, no information about its value can be re- covered. encapsulation The process of applying the Encaps algorithm of a KEM. This algorithm accepts the encapsulation key as input, requires private randomness, and produces a shared secret key and an associated ciphertext as out- put. encapsulation key A cryptographic key produced by a KEM during key generation and used during the encapsulation process. The encapsulation key can be made public. (See Section 3.3.) encryption key A cryptographic key that is used with a PKE in order to encrypt plaintexts into ciphertexts. The encryption key can be made public. equivalent process Two processes are equivalent if the same output is produced when the same values are input to each process (either as input parameters, as values made available during the process, or both). fresh random value An output that was produced by a random bit generator and has not been previously used. 2FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM hash function A function on bit strings in which the length of the output is fixed. Approved hash functions (such as those specified in FIPS 180  and FIPS 202 ) are designed to satisfy the following properties: 1. (One-way) It is computationally infeasible to find any input that maps to any new pre-specified output. 2. (Collision-resistant) It is computationally infeasible to find any two distinct inputs that map to the same output. input checking Examination of a potential input to an algorithm for the purpose of determining whether it conforms to certain requirements. key A bit string that is used in conjunction with a cryptographic algorithm, such as the encapsulation and decapsulation keys (of a KEM), the shared secret key (produced by a KEM), and the encryption and decryption keys (of a PKE). (See Section 3.3.) key-encapsulation A set of three cryptographic algorithms (KeyGen, Encaps, and Decaps) mechanism (KEM) that can be used by two parties to establish a shared secret key over a public channel. key establishment A procedure that results in secret keying material that is shared among different parties. key pair A set of two keys with the property that one key can be made public while the other key must be kept private. In this standard, this could refer to either the (encapsulation key, decapsulation key) key pair of a KEM or the (encryption key, decryption key) key pair of a PKE. little-endian The property of a byte string having its bytes positioned in order of increasing significance. In particular, the leftmost (first) byte is the least significant, and the rightmost (last) byte is the most significant. The term â€œlittle-endianâ€ may also be applied in the same manner to bit strings (e.g., the 8-bit string 11010001 corresponds to the byte 20+21+23+27 =139). party An individual person, organization, device, or process. In this specifica- tion, there are two parties (e.g., Party A and Party B, or Alice and Bob) who jointly perform the key establishment process using a KEM. pseudorandom A process (or data produced by a process) is said to be pseudorandom when the outcome is deterministic yet also appears random as long as the internal action of the process is hidden from observation. For cryptographic purposes, â€œeffectively randomâ€ means â€œcomputationally indistinguishable from random within the limits of the intended security strength.â€ public channel A communication channel between two parties. Such a channel can be observed and possibly also corrupted by third parties. 3FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM public-key A set of three cryptographic algorithms (KeyGen, Encrypt, and Decrypt) encryption scheme that can be used by two parties to send secret data over a public channel. (PKE) Also known as an asymmetric encryption scheme. shared secret A secret value that has been computed during a key-establishment scheme, is known by both participants, and is used as input to a key- derivation method to produce keying material. shared secret key A shared secret that can be used directly as a cryptographic key in symmetric-key cryptography. It does not require additional key deriva- tion. The shared secret key must be kept private and must be destroyed when no longer needed. security category A number associated with the security strength of a post-quantum cryptographic algorithm, as specified by NIST (see ). security strength A number associated with the amount of work (i.e., the number of op- erations) that is required to break a cryptographic algorithm or system. shall Used to indicate a requirement of this standard. should Used to indicate a strong recommendation but not a requirement of this standard. Ignoring the recommendation could lead to undesirable results. 2.2 Acronyms AES Advanced Encryption Standard CBD Centered Binomial Distribution FIPS Federal Information Processing Standard KEM Key-Encapsulation Mechanism LWE Learning with Errors MLWE Module Learning with Errors NIST National Institute of Standards and Technology NISTIR NIST Interagency or Internal Report NTT Number-Theoretic Transform PKE Public-Key Encryption PQC Post-Quantum Cryptography PRF Pseudorandom Function RBG Random Bit Generator SHA Secure Hash Algorithm 4FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM SHAKE Secure Hash Algorithm KECCAK SP Special Publication XOF Extendable-Output Function 2.3 Mathematical Symbols ğ‘› Denotes the integer 256 throughout this document. ğ‘ Denotes the prime integer 3329 = 28 â‹…13+1 throughout this document. ğœ Denotes the integer 17, which is a primitive ğ‘›-th root of unity modulo ğ‘. ğ”¹ The set {0,1,â€¦,255} of unsigned 8-bit integers (bytes). â„š The set of rational numbers. â„¤ The set of integers. â„¤ The ring of integers modulo ğ‘š (i.e., the set {0,1,â€¦,ğ‘š âˆ’ 1} equipped with ğ‘š the operations of addition and multiplication modulo ğ‘š.) â„¤ğ‘› The set of ğ‘›-tuples over â„¤ equipped with â„¤ -module structure. As a data ğ‘š ğ‘š ğ‘š type, this is the set of length-ğ‘› arrays whose entries are in â„¤ . ğ‘š ğ‘… The ring â„¤ [ğ‘‹]/(ğ‘‹ğ‘› +1) consisting of polynomials of the form ğ‘“ = ğ‘“ + ğ‘ ğ‘ 0 ğ‘“ ğ‘‹ +â‹¯+ğ‘“ ğ‘‹255 , where ğ‘“ âˆˆ â„¤ for all ğ‘—. The ring operations are addi- 1 255 ğ‘— ğ‘ tion and multiplication modulo ğ‘‹ğ‘› +1. ğ‘‡ The image of ğ‘… under the number-theoretic transform. Its elements are ğ‘ ğ‘ called â€œNTT representationsâ€ of polynomials in ğ‘… . (See Section 4.3.) ğ‘ D (ğ‘… ) A certain distribution of polynomials in ğ‘… with small coefficients, from ğœ‚ ğ‘ ğ‘ which noise is sampled. The distribution is parameterized by ğœ‚ âˆˆ {2,3}. (See Section 4.2.2.) ğ‘†âˆ— If ğ‘† is a set, this denotes the set of finite-length tuples (or arrays) of elements from the set ğ‘†, including the empty tuple (or empty array). ğ‘†ğ‘˜ If ğ‘† is a set, this denotes the set of ğ‘˜-tuples (or length-ğ‘˜ arrays) of elements from the set ğ‘†. ğ‘“ The coefficient of ğ‘‹ğ‘— of a polynomial ğ‘“ =ğ‘“ +ğ‘“ ğ‘‹+â‹¯+ğ‘“ ğ‘‹255 âˆˆğ‘… . ğ‘— 0 1 255 ğ‘ ğ‘“ Ì‚ The element of ğ‘‡ that is equal to the NTT representation of a polynomial ğ‘ ğ‘“ âˆˆ ğ‘… . (See Sections 2.4.4 and 4.3.) ğ‘ ğ¯ğ‘‡ , ğ€ğ‘‡ The transpose of a row or column vector ğ¯. In general, the transpose of a matrix ğ€. 5FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM âˆ˜ Denotes linear-algebraic composition with coefficients in ğ‘… or ğ‘‡ (e.g., ğ‘ ğ‘ ğ€ âˆ˜ ğ¯ denotes the vector resulting from applying matrix ğ€ to vector ğ¯). (See Section 2.4.7.) Ã— Denotes the operation on coefficient arrays that implements product in the ğ‘‡ ğ‘ ring ğ‘‡ . (See Sections 2.4.5 and 4.3.1.) ğ‘ ğ´â€–ğµ The concatenation of two arrays or bit strings ğ´ and ğµ. ğµ[ğ‘–] The entry at index ğ‘– in the array ğµ. All arrays have indices that begin at zero. ğµ[ğ‘˜ âˆ¶ ğ‘š] The subarray (ğµ[ğ‘˜],ğµ[ğ‘˜ + 1],â€¦,ğµ[ğ‘š âˆ’ 1]) of the array ğµ. |ğµ| If ğµ is a number, this denotes the absolute value of ğµ. If ğµ is an array, this denotes its length. âŒˆğ‘¥âŒ‰ The ceiling of ğ‘¥ (i.e., the smallest integer greater than or equal to ğ‘¥). âŒŠğ‘¥âŒ‹ The floor of ğ‘¥ (i.e., the largest integer less than or equal to ğ‘¥). âŒˆğ‘¥âŒ‹ The rounding of ğ‘¥ to the nearest integer. If ğ‘¥ = ğ‘¦+1/2 for some ğ‘¦ âˆˆ â„¤, then âŒˆğ‘¥âŒ‹ = ğ‘¦+1. âˆ¶= Denotes that the left-hand side is defined to be the expression on the right- hand side. ğ‘Ÿ mod ğ‘š The unique integer ğ‘Ÿâ€² in {0,1,â€¦,ğ‘š âˆ’ 1} such that ğ‘š divides ğ‘Ÿ âˆ’ ğ‘Ÿâ€² . BitRev (ğ‘Ÿ) Bit reversal of a seven-bit integer ğ‘Ÿ. Specifically, if ğ‘Ÿ = ğ‘Ÿ +2ğ‘Ÿ +4ğ‘Ÿ +â‹¯+ 7 0 1 2 64ğ‘Ÿ with ğ‘Ÿ âˆˆ {0,1}, then BitRev (ğ‘Ÿ) = ğ‘Ÿ +2ğ‘Ÿ +4ğ‘Ÿ +â‹¯+64ğ‘Ÿ . 6 ğ‘– 7 6 5 4 0 ğ‘  â† ğ‘¥ In pseudocode, this notation means that the variable ğ‘  is assigned the value of the expression ğ‘¥. ğ‘  â†$ âˆ’ ğ”¹â„“ In pseudocode, this notation means that the variable ğ‘  is assigned the value of an array of â„“ random bytes. The bytes must be freshly generated using randomness from an approved RBG. (See Section 3.3.) âŠ¥ A symbol indicating failure or the lack of output from an algorithm. 2.4 Interpreting the Pseudocode This section outlines the conventions of the pseudocode used to describe the algorithms in this standard. All algorithms are understood to have access to two global integer constants: ğ‘› = 256 and ğ‘ = 3329. There are also five global integer variables: ğ‘˜, ğœ‚ , ğœ‚ , ğ‘‘ , and ğ‘‘ . All 1 2 ğ‘¢ ğ‘£ other variables are local. The five global variables are set to particular values when a parameter set is selected (see Section 8). When algorithms in this specification invoke other algorithms as subroutines, all arguments (i.e., inputs) are passed by value. In other words, a copy of the inputs is created, and the subroutine is invoked with the copy. There is no â€œpassing by reference.â€ Pseudocode assignments are performed using the symbol â€œâ†.â€ For example, the statement ğ‘§ â†ğ‘¦ means that the variable ğ‘§ is assigned the value of variable ğ‘¦. Pseudocode comparisons 6FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM are performed via the symbol â€œ==.â€ For example, the expression ğ‘¥ == ğ‘¤ is a boolean value that is TRUE if and only if the variables ğ‘¥ and ğ‘¤ have the same value. In regular text (i.e., outside of the pseudocode), a different convention is applied. There, the â€œ=â€ symbol is used both for assigning values and for comparisons, in keeping with standard mathematical notation. When emphasis is needed, assignments will be made with â€œâˆ¶=â€ instead. Variables will always have a valid value that is appropriate to their data type, with two exceptions: 1. The outputs of a random bit generator (RBG) have the byte array data type but are also allowed to have the special value NULL. This value indicates that randomness generation failed. This can only occur in ML-KEM.KeyGen and ML-KEM.Encaps. 2. The outputs of ML-KEM.KeyGen and ML-KEM.Encaps have the byte array data type but are also allowed to have the special value âŠ¥. When ML-KEM.KeyGen or ML-KEM.Encaps return the value âŠ¥, this indicates that the algorithm failed due to a failure of randomness generation. 2.4.1 Data Types For variables that represent the input or output of an algorithm, the data type (e.g., bit, byte, array of bits) will be explicitly described at the start of the algorithm. For most local variables in the pseudocode, the data type is easily deduced from context. For all other variables, the data type will be declared in a comment. In a single algorithm, the data type of a variable is determined the first time that the variable is used and will not be changed. Variable names can and will be reused across different algorithms, including with different data types. In addition to standard atomic data types (e.g., bits, bytes) and data structures (e.g., arrays), integers modulo ğ‘š (i.e., elements of â„¤ ) will also be used as an abstract data type. It is implicit ğ‘š that reduction modulo ğ‘š takes place whenever an assignment is made to a variable in â„¤ . For ğ‘š example, for ğ‘§ âˆˆ â„¤ and integers ğ‘¥ and ğ‘¦, the statement ğ‘š ğ‘§ â† ğ‘¥ +ğ‘¦ (2.1) means that ğ‘§ is assigned the value ğ‘¥ + ğ‘¦ mod ğ‘š. The pseudocode is agnostic regarding how an integer modulo ğ‘š is represented in actual implementations or how modular reduction is computed. 2.4.2 Loop Syntax The pseudocode will make use of both â€œwhileâ€ and â€œforâ€ loops. The â€œwhileâ€ syntax is self- explanatory. In the case of â€œforâ€ loops, the syntax will be in the style of the programming language C. Two simple examples are given in Algorithm 1. The standard mathematical expression (e.g., âˆ‘ğ‘› (ğ‘– + 3)) will be used for simple summations instead of a â€œforâ€ loop. ğ‘–â†1 2.4.3 Arithmetic With Arrays of Integers This standard makes extensive use of arrays of integers modulo ğ‘š (i.e., elements of â„¤â„“ ). In a ğ‘š typical case, the relevant values are ğ‘š = ğ‘ = 3329 and â„“ = ğ‘› = 256. Arithmetic with arrays in 7FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Algorithm 1 ForExample() Performs two simple â€œforâ€ loops. 1: for (ğ‘– â† 0; ğ‘– < 10; ğ‘–++) 2: ğ´[ğ‘–] â† ğ‘– â–· ğ´ is an integer array of length 10 3: end for â–· ğ´ now has the value (0,1,2,3,4, 5,6,7, 8,9) 4: ğ‘— â† 0 5: for (ğ‘˜ â† 256; ğ‘˜ > 1; ğ‘˜ â† ğ‘˜/2) 6: ğµ[ğ‘—] â† ğ‘˜ â–· ğµ is an integer array of length 8 7: ğ‘— â† ğ‘— + 1 8: end for â–· ğµ now has the value (256,128,64,32,16,8,4,2) â„¤â„“ will be done as follows. Let ğ‘ âˆˆ â„¤ and ğ‘‹,ğ‘Œ âˆˆ â„¤â„“ . The statements ğ‘š ğ‘š ğ‘š ğ‘ â† ğ‘â‹…ğ‘‹ (2.2) ğ‘Š â† ğ‘‹ +ğ‘Œ (2.3) will result in two arrays ğ‘,ğ‘Š âˆˆ â„¤â„“ , with the property that ğ‘[ğ‘–] = ğ‘â‹…ğ‘‹[ğ‘–] and ğ‘Š[ğ‘–] = ğ‘‹[ğ‘–]+ğ‘Œ [ğ‘–] ğ‘š for all ğ‘–. Multiplication of arrays in â„¤â„“ will only be meaningful when ğ‘š = ğ‘ and â„“ = ğ‘› = 256, in ğ‘š which case it corresponds to multiplication in a particular ring. This operation will be described in (2.8). 2.4.4 Representations of Algebraic Objects An essential operation in ML-KEM is the number-theoretic transform (NTT), which maps a poly- nomial ğ‘“ in a certain ring ğ‘… to its â€œNTT representationâ€ ğ‘“ iÌ‚ nan isomorphic ring ğ‘‡ . The rings ğ‘… ğ‘ ğ‘ ğ‘ and ğ‘‡ and the NTT are discussed in detail in Section 4.3. This standard will represent elements ğ‘ of ğ‘… and ğ‘‡ in pseudocode using arrays of integers modulo ğ‘ as follows. ğ‘ ğ‘ An element ğ‘“ of ğ‘… is a polynomial of the form ğ‘ ğ‘“ = ğ‘“ + ğ‘“ ğ‘‹ + â‹¯ + ğ‘“ ğ‘‹255 âˆˆ ğ‘… (2.4) 0 1 255 ğ‘ and will be represented in pseudocode by the array (ğ‘“ ,ğ‘“ ,â€¦,ğ‘“ ) âˆˆ â„¤256, (2.5) 0 1 255 ğ‘ whose entries contain the coefficients of ğ‘“. Overloading notation, the array in (2.5) will also be denoted by ğ‘“. The ğ‘–-th entry of the array ğ‘“ will thus contain the ğ‘–-th coefficient of the polynomial ğ‘“ (i.e., ğ‘“[ğ‘–] = ğ‘“ ). ğ‘– An element (sometimes called â€œNTT representationâ€) ğ‘”Ì‚of ğ‘‡ is a tuple of 128 polynomials, each ğ‘ of degree at most one. Specifically, ğ‘”Ì‚=( ğ‘”Ì‚ +ğ‘” Ì‚ ğ‘‹, ğ‘” Ì‚ +ğ‘” Ì‚ ğ‘‹, â€¦, ğ‘” Ì‚ + ğ‘” Ì‚ ğ‘‹)âˆˆğ‘‡ . (2.6) 0,0 0,1 1,0 1,1 127,0 127,1 ğ‘ 8FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Such an algebraic object will be represented in pseudocode by the array (ğ‘”Ì‚ ,ğ‘”Ì‚ ,ğ‘”Ì‚ , ğ‘”Ì‚ ,â€¦, ğ‘” Ì‚ , ğ‘” Ì‚ ) âˆˆ â„¤256. (2.7) 0,0 0,1 1,0 1,1 127,0 127,1 ğ‘ Overloading notation, the array in (2.7) will also be denoted by ğ‘”.Ì‚ In this case, the mapping between array entries and coefficients is ğ‘”[Ì‚ 2ğ‘–] = ğ‘”Ì‚ and ğ‘”[Ì‚ 2ğ‘– + 1] = ğ‘”Ì‚ for ğ‘– âˆˆ {0,1,â€¦,127}. ğ‘–,0 ğ‘–,1 Converting between a polynomial ğ‘“ âˆˆ ğ‘… and its NTT representation ğ‘“ Ì‚ âˆˆ ğ‘‡ will be done via the ğ‘ ğ‘ algorithms NTT (Algorithm 9) and NTTâˆ’1 (Algorithm 10). These algorithms act on arrays of coefficients, as described above, and satisfy ğ‘“ Ì‚ = NTT(ğ‘“) and ğ‘“ = NTTâˆ’1(ğ‘“)Ì‚ . 2.4.5 Arithmetic With Polynomials and NTT Representations The algebraic operations of addition and scalar multiplication in ğ‘… and ğ‘‡ are done coordinate- ğ‘ ğ‘ wise. For example, if ğ‘ âˆˆ â„¤ and ğ‘“ âˆˆ ğ‘… , the ğ‘–-th coefficient of the polynomial ğ‘â‹…ğ‘“ âˆˆ ğ‘… is ğ‘ ğ‘ ğ‘ equal to ğ‘ â‹…ğ‘“ mod ğ‘. In pseudocode, elements of both ğ‘… and ğ‘‡ are represented by coefficient ğ‘– ğ‘ ğ‘ arrays (i.e., elements of â„¤256). The algebraic operations of addition and scalar multiplication are ğ‘ thus performed by addition and scalar multiplication of the corresponding coefficient arrays, as in (2.3) and (2.2). For example, the addition of two NTT representations in pseudocode is performed by a statement of the form â„Ì‚ â† ğ‘“ +Ì‚ ğ‘”,Ì‚ where â„Ì‚,ğ‘“,Ì‚ ğ‘” Ì‚ âˆˆ â„¤256 are coefficient arrays. ğ‘ The algebraic operations of multiplication in ğ‘… and ğ‘‡ are treated as follows. For efficiency ğ‘ ğ‘ reasons, multiplication in ğ‘… will not be used. The algebraic meaning of multiplication in ğ‘‡ is ğ‘ ğ‘ discussed in Section 4.3.1. In pseudocode, it will be performed by the algorithm MultiplyNTTs (Algorithm 11). Specifically, if ğ‘“,Ì‚ ğ‘” Ì‚ âˆˆ â„¤256 are a pair of arrays (each representing the NTT of some ğ‘ polynomial), then â„Ì‚ â† ğ‘“ Ã— Ì‚ ğ‘” Ì‚ means â„ Ì‚ â† MultiplyNTTs(ğ‘“,Ì‚ ğ‘”) Ì‚ . (2.8) ğ‘‡ ğ‘ The result is an array â„Ì‚ âˆˆ â„¤256 . ğ‘ 2.4.6 Matrices and Vectors In addition to arrays of integers modulo ğ‘, the pseudocode will also make use of arrays whose entries are themselves elements of â„¤256. For example, an element ğ¯ âˆˆ (â„¤256)3 will be a length- ğ‘ ğ‘ three array whose entries ğ¯, ğ¯, and ğ¯ are themselves elements of â„¤256 (i.e., arrays). One ğ‘ can think of each of these entries as representing a polynomial in ğ‘… so that ğ¯ itself represents ğ‘ an element of the module ğ‘…3 . ğ‘ When arrays are used to represent matrices and vectors whose entries are elements of ğ‘… , they ğ‘ will be denoted with bold letters (e.g., ğ¯ for vectors and ğ€ for matrices). When arrays are used to represent matrices and vectors whose entries are elements of ğ‘‡ , they will be denoted with a ğ‘ â€œhatâ€ (e.g., ğ¯Ì‚ and ğ€Ì‚ ). Unless an explicit transpose operation is performed, it is understood that vectors are column vectors. One can then view vectors as the special case of matrices with only one column. Converting between matrices over ğ‘… and matrices over ğ‘‡ will be done coordinate-wise. For ğ‘ ğ‘ 9FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM example, if ğ¯ âˆˆ (â„¤256)ğ‘˜ , then the statement ğ‘ ğ¯Ì‚ â† NTT(ğ¯) (2.9) will result in ğ¯Ì‚ âˆˆ (â„¤256)ğ‘˜ such that ğ¯Ì‚ [ğ‘–]= NTT(ğ¯[ğ‘–]) for all ğ‘–. This involves running NTT a total ğ‘ of ğ‘˜ times. 2.4.7 Arithmetic With Matrices and Vectors The following describes how to perform arithmetic with matrices over ğ‘… and ğ‘‡ with vectors as ğ‘ ğ‘ a special case. Addition and scalar multiplication are performed coordinate-wise, so the addition of matrices over ğ‘… and ğ‘‡ is straightforward. In the case of ğ‘‡ , scalar multiplication is done via (2.8). For ğ‘ ğ‘ ğ‘ example, if ğ‘“ Ì‚ âˆˆ â„¤256 and ğ®Ì‚, ğ¯Ì‚ âˆˆ (â„¤256)ğ‘˜ , then ğ‘ ğ‘ ğ° Ì‚ â†ğ‘“â‹… Ì‚ ğ® Ì‚ (2.10) ğ³ Ì‚ â† ğ® Ì‚+ ğ¯ Ì‚ (2.11) will result in ğ°Ì‚ ,ğ³ Ì‚ âˆˆ (â„¤256 )ğ‘˜ satisfying ğ°Ì‚ [ğ‘–]=ğ‘“ Ã—Ì‚ ğ®Ì‚ [ğ‘–] and ğ³[Ì‚ ğ‘–] = ğ®Ì‚ [ğ‘–] + ğ¯Ì‚[ğ‘–] for all ğ‘–. Here, the ğ‘ ğ‘‡ ğ‘ multiplication and addition of individual entries are performed using the appropriate arithmetic for coefficient arrays of elements of ğ‘‡ (i.e., as in (2.3)). ğ‘ It will also be necessary to multiply matrices with entries in ğ‘‡ , which is done by using standard ğ‘ matrix multiplication with the base-case multiplication (i.e., multiplication of individual entries) being multiplication in ğ‘‡ . If ğ€Ì‚ and ğÌ‚ are two matrices with entries in ğ‘‡ , their matrix product ğ‘ ğ‘ will be denoted ğ€Ì‚ âˆ˜ğÌ‚ .Some example pseudocode statements involving matrix multiplication are given in (2.12), (2.13), and (2.14). In these examples, ğ€Ì‚ is a ğ‘˜ Ã— ğ‘˜ matrix, while ğ®Ì‚ and ğ¯Ì‚ are vectors of length ğ‘˜. All three of these objects are represented in pseudocode by arrays: a ğ‘˜ Ã— ğ‘˜ array for ğ€Ì‚ and length-ğ‘˜ arrays for ğ®Ì‚ and ğ¯Ì‚. The entries of ğ€Ì‚ , ğ®Ì‚, and ğ¯Ì‚ are elements of â„¤256. In ğ‘ (2.12) and (2.13), the pseudocode statement on the left produces a new length-ğ‘˜ vector whose entries are specified on the right. In (2.14), the pseudocode statement on the left computes a dot product. The result is in the base ring (i.e., ğ‘‡ ) and is represented by an element ğ‘§ Ì‚ of â„¤256. ğ‘ ğ‘ ğ‘˜âˆ’1 ğ° Ì‚ â†ğ€Ì‚ âˆ˜ ğ® Ì‚ ğ°Ì‚[ğ‘–]=âˆ‘ğ€Ì‚[ğ‘–,ğ‘—]Ã— ğ® Ì‚[ğ‘—] (2.12) ğ‘‡ ğ‘ ğ‘—=0 ğ‘˜âˆ’1 ğ² Ì‚ â†ğ€Ì‚âŠºâˆ˜ğ® Ì‚ ğ²Ì‚[ğ‘–]=âˆ‘ğ€Ì‚[ğ‘—,ğ‘–]Ã— ğ® Ì‚[ğ‘—] (2.13) ğ‘‡ ğ‘ ğ‘—=0 ğ‘˜âˆ’1 ğ‘§Ì‚ â†ğ®Ì‚ âŠºâˆ˜ğ¯Ì‚ ğ‘§Ì‚=âˆ‘ğ® Ì‚[ğ‘—]Ã— ğ¯ Ì‚[ğ‘—] (2.14) ğ‘‡ ğ‘ ğ‘—=0 The multiplication Ã— of individual entries above is performed using MultiplyNTTs, as described ğ‘‡ ğ‘ in (2.8). 10FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 2.4.8 Applying Algorithms to Arrays, Examples In the previous examples, arithmetic over â„¤ was extended to arithmetic with arrays over â„¤ ğ‘š ğ‘š and then further extended to arithmetic with matrices whose entries are themselves arrays over â„¤ . Similarly, algorithms defined with a given data type as input will be applied to arrays and ğ‘š matrices over that data type. When the pseudocode invokes such an algorithm on an array or matrix input, it is implied that the algorithm is invoked repeatedly and applied to each entry of the input. For example, consider the function Compress âˆ¶â„¤ â†’â„¤ defined in Section 4. It can be invoked ğ‘‘ ğ‘ 2ğ‘‘ on an array input ğ¹ âˆˆ â„¤256 with the statement ğ‘ ğ¾ â† Compress (ğ¹ ). (2.15) ğ‘‘ The result will be an array ğ¾ âˆˆ â„¤256 such that ğ¾[ğ‘–] = Compress (ğ¹ [ğ‘–]) for every ğ‘– âˆˆ {0,1,â€¦,255}. 2ğ‘‘ ğ‘‘ The computation (2.15) involves running the Compress algorithm 256 times. For a second example, consider the algorithm NTT defined in Section 4.3. It takes an array ğ‘“ âˆˆ â„¤256 (representing an element of ğ‘… ) as input and outputs another array ğ‘“ Ì‚ âˆˆ â„¤256 (representing ğ‘ ğ‘ ğ‘ an element of ğ‘‡ ). If the NTT algorithm is invoked on a vector ğ¬ âˆˆ (â„¤256)ğ‘˜ (representing an ğ‘ ğ‘ element of ğ‘…ğ‘˜) with the pseudocode statement ğ‘ ğ¬ Ì‚ â† NTT(ğ¬), (2.16) the result is a vector ğ¬Ì‚ âˆˆ(â„¤256 )ğ‘˜ such that ğ¬[Ì‚ ğ‘–] = NTT(ğ¬[ğ‘–]) for all ğ‘– âˆˆ {0,1,â€¦,ğ‘˜âˆ’1}. The vector ğ‘ ğ¬Ì‚ represents an element of ğ‘‡ğ‘˜ . The computation (2.16) involves running the NTT algorithm ğ‘˜ ğ‘ times. For a third example, consider line 2 of K-PKE.Encrypt in Section 5.2: ğ­ Ì‚â† ByteDecode (ek [0 âˆ¶ 384ğ‘˜]). (2.17) 12 PKE ByteDecode is defined to receive a byte array of length 32â‹…12 = 384 as input and produce 12 an integer array in â„¤256 as output. The computation (2.17) is run on the first 384ğ‘˜ bytes of ğ‘ byte array ek and results in ğ­ Ì‚ âˆˆ (â„¤256 )ğ‘˜ . ByteDecode will thus be applied ğ‘˜ times, once for PKE ğ‘ 12 each subarray ek [384 â‹… ğ‘—,384 â‹… (ğ‘— + 1)], and will result in an integer array ğ­[Ì‚ ğ‘—] âˆˆ â„¤256 such that PKE ğ‘ ğ­[Ì‚ ğ‘—] = ByteDecode (ek [384â‹…ğ‘—,384â‹…(ğ‘—+1)]) for each ğ‘— from 0 to ğ‘˜ âˆ’ 1. 12 PKE 11FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 3. Overview of the ML-KEM Scheme This section gives a high-level overview of the ML-KEM scheme. 3.1 Key-Encapsulation Mechanisms The following is a high-level overview of key-encapsulation mechanisms (KEMs). For details, see SP 800-227 . A KEM is a cryptographic scheme that, under certain conditions, can be used to establish a shared secret key between two communicating parties. This shared secret key can then be used for symmetric-key cryptography. A KEM consists of three algorithms and a collection of parameter sets. The three algorithms are: 1. A probabilistic key generation algorithm denoted by KeyGen 2. A probabilistic â€encapsulationâ€ algorithm denoted by Encaps 3. A deterministic â€decapsulationâ€ algorithm denoted by Decaps The collection of parameter sets is used to select a trade-off between security and efficiency. Each parameter set in the collection is a list of specific (typically numerical) values, one for each parameter required by the three algorithms. Alice Bob KeyGen decapsulation key encapsulation key Decaps ciphertext Encaps Aliceâ€™s copy of the Bobâ€™s copy of the shared secret key shared secret key ğ¾â€² ğ¾ Figure 1. A simple view of key establishment using a KEM 12FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM In the typical application, a KEM is used to establish a shared secret key between two parties (here referred to as Alice and Bob) as described in Figure 1. Alice begins by running KeyGen in order to generate a (public) encapsulation key and a (private) decapsulation key. Upon obtaining Aliceâ€™s encapsulation key, Bob runs the Encaps algorithm, which produces Bobâ€™s copy ğ¾ of the shared secret key along with an associated ciphertext. Bob sends the ciphertext to Alice, and Alice completes the process by running the Decaps algorithm using her decapsulation key and the ciphertext. This final step produces Aliceâ€™s copy ğ¾â€² of the shared secret key. After completing this process, Alice and Bob would like to conclude that their outputs satisfy ğ¾â€² =ğ¾ and that this value is a secure, random, shared secret key. However, these properties only hold if certain important conditions are satisfied, as discussed in SP 800-227 . 3.2 The ML-KEM Scheme ML-KEM is a key-encapsulation mechanism based on CRYSTALS-KYBER , a scheme that was initially described in . The following is a brief and informal description of the computational assumption underlying ML-KEM and how the ML-KEM scheme is constructed. The computational assumption. The security of ML-KEM is based on the presumed hardness of the so-called Module Learning with Errors (MLWE) problem , which is a generalization of the Learning With Errors (LWE) problem introduced by Regev in 2005 . The hardness of the MLWE problem is itself based on the presumed hardness of certain computational problems in module lattices . This motivates the name of the scheme ML-KEM. In the LWE problem, the input is a set of random â€œnoisyâ€ linear equations in some secret variables ğ‘¥ âˆˆ â„¤ğ‘›, and the task is to recover ğ‘¥. The noise in the equations is such that standard ğ‘ algorithms (e.g., Gaussian elimination) are intractable. The LWE problem naturally lends itself to cryptographic applications. For example, if ğ‘¥ is interpreted as a secret key, then one can encrypt a one-bit plaintext value by sampling either an approximately correct linear equation (if the plaintext is zero) or a far-from-correct linear equation (if the plaintext is one). Plausibly, only a party in possession of ğ‘¥ can distinguish these two cases. Encryption can then be delegated to another party by publishing a large collection of noisy linear equations, which can be combined appropriately by the encrypting party. The result is an asymmetric encryption scheme. The MLWE problem is similar to the LWE problem. An important difference is that, in MLWE, â„¤ğ‘› ğ‘ is replaced by a certain module ğ‘…ğ‘˜ , which is constructed by taking the ğ‘˜-fold Cartesian product ğ‘ of a certain polynomial ring ğ‘… . In particular, the secret in the MLWE problem is an element ğ± of ğ‘ the module ğ‘…ğ‘˜ . The ring ğ‘… is discussed in detail in Section 4.3. ğ‘ ğ‘ The ML-KEM construction. At a high level, the construction of the scheme ML-KEM proceeds in two steps. First, the ideas discussed previously are used to construct a public-key encryption (PKE) scheme from the MLWE problem. Second, this PKE scheme is converted into a key-encapsulation mechanism using the so-called Fujisaki-Okamoto (FO) transform [11, 12]. Due to certain prop- erties of the FO transform, the resulting KEM provides security in a significantly more general attack model than the PKE scheme. As a result, ML-KEM is believed to satisfy so-called IND-CCA2 security [1, 4, 13, 14]. 13FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM The specification of the ML-KEM algorithms in this standard will follow the same pattern. Specif- ically, this standard will first describe a public-key encryption scheme called K-PKE (in Section 5) and then use the algorithms of K-PKE as subroutines when describing the algorithms of ML-KEM (in Sections 6 and 7). The cryptographic transformation from K-PKE to ML-KEM is crucial for achieving IND-CCA2 security. The scheme K-PKE is not IND-CCA2-secure and shall not be used as a stand-alone scheme (see Section 3.3). A notable feature of ML-KEM is the use of the number-theoretic transform (NTT). The NTT converts a polynomial ğ‘“ âˆˆ ğ‘… to an alternative representation as a vector ğ‘“ oÌ‚ f linear polynomials. ğ‘ Working with NTT representations enables significantly faster multiplication of polynomials. Other operations (e.g., addition, rounding, and sampling) can be done in either representation. ML-KEM satisfies the essential KEM property of correctness. This means that in the absence of corruption or interference, the process in Figure 1 will result in ğ¾â€² =ğ¾ with overwhelming probability. ML-KEM also comes with a proof of asymptotic theoretical security in a certain heuristic model . Each of the parameter sets of ML-KEM comes with an associated security strength that was estimated based on current cryptanalysis (see Section 8 for details). Parameter sets and algorithms. Recall that a KEM consists of algorithms KeyGen, Encaps, and Decaps, along with a collection of parameter sets. In the case of ML-KEM, the three aforemen- tioned algorithms are: 1. ML-KEM.KeyGen (Algorithm 19) 2. ML-KEM.Encaps (Algorithm 20) 3. ML-KEM.Decaps (Algorithm 21) These algorithms are described and discussed in detail in Section 7. ML-KEM comes equipped with three parameter sets: â€¢ ML-KEM-512 (security category 1) â€¢ ML-KEM-768 (security category 3) â€¢ ML-KEM-1024 (security category 5) These parameter sets are described and discussed in detail in Section 8. The security categories 1-5 are defined in SP 800-57, Part 1 . Each parameter set assigns a particular numerical value to five integer variables: ğ‘˜, ğœ‚ , ğœ‚ , ğ‘‘ , and ğ‘‘ . The values of these variables in each parameter 1 2 ğ‘¢ ğ‘£ set are given in Table 2 of Section 8. In addition to these five variable parameters, there are also two constants: ğ‘› = 256 and ğ‘ = 3329. Decapsulation failures. Provided that all inputs are well-formed and randomness generation is successful, the key establishment procedure of ML-KEM will never explicitly fail, meaning that both ML-KEM.Encaps and ML-KEM.Decaps will each output a 256-bit value. Moreover, if no corruption or interference is present, the two 256-bit values produced by ML-KEM.Encaps and ML-KEM.Decaps will be equal with overwhelming probability (i.e., ğ¾â€² will equal ğ¾ in the process described in Figure 1). The event that ğ¾â€² â‰ ğ¾ under these conditions is called a decapsulation 14FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM failure. Formally, the decapsulation failure probability is defined to be the probability (conditioned on no RGB failures) that the process 1. (ek,dk)â† ML-KEM.KeyGen() (3.1) 2. (ğ‘,ğ¾) â† ML-KEM.Encaps(ek) (3.2) 3. ğ¾â€² â† ML-KEM.Decaps(dk,ğ‘) (3.3) results in ğ¾â€² â‰  ğ¾. The probability is taken over uniformly random seeds ğ‘‘,ğ‘§ (sampled in ML-KEM.KeyGen) and ğ‘š (sampled in ML-KEM.Encaps) and under the heuristic assumption that hash functions and XOFs behave like uniformly random functions. The decapsulation failure rates for ML-KEM are listed in Table 1. For details, see Theorem 1 in  and the scripts in . Table 1. Decapsulation failure rates for ML-KEM Parameter set Decapsulation failure rate ML-KEM-512 2âˆ’138.8 ML-KEM-768 2âˆ’164.8 ML-KEM-1024 2âˆ’174.8 Terminology for keys. A KEM involves three different types of keys: encapsulation keys, de- capsulation keys, and shared secret keys. ML-KEM is built on top of the component public-key encryption scheme K-PKE, which has two additional key types: encryption keys and decryption keys. In the literature, encapsulation keys and encryption keys are sometimes referred to as â€œpublic keys,â€ while decapsulation keys and decryption keys are sometimes referred to as â€œpri- vate keys.â€ In order to reduce confusion, this standard will not use the terms â€œpublic keyâ€ or â€œprivate key.â€ Instead, keys will be referred to only using the more specific terms, i.e., one of â€œencapsulation keyâ€, â€œdecapsulation keyâ€, â€œencryption keyâ€, â€œdecryption keyâ€, and â€œshared secret keyâ€. 3.3 Requirements for ML-KEM Implementations This section describes several requirements for cryptographic modules that implement ML-KEM. Implementation requirements specific to particular algorithms will be described in later sections. Additional requirements, including requirements for using ML-KEM in specific applications, are given in SP 800-227 . While conforming implementations must adhere to all of these requirements, adherence does not guarantee that the result will be secure (see Point 13 in the announcement). K-PKE is only a component. The public-key encryption scheme K-PKE described in Section 5 shall not be used as a stand-alone cryptographic scheme. Instead, the algorithms that comprise K-PKE may only be used as subroutines in the algorithms of ML-KEM. In particular, the algorithms K-PKE.KeyGen (Algorithm 13), K-PKE.Encrypt (Algorithm 14), and K-PKE.Decrypt (Algorithm 15) are not approved for use as a public-key encryption scheme. 15FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Controlled access to internal functions. The key-encapsulation mechanism ML-KEM makes use of internal, â€œderandomizedâ€ functions ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal, and ML-KEM.Decaps_internal, specified in Section 6. The interfaces for these functions should not be made available to applications other than for testing purposes. In particular, the sampling of random values required for key generation (as specified in ML-KEM.KeyGen) and encapsulation (as specified in ML-KEM.Encaps) shall be performed by the cryptographic module. Equivalent implementations. For every algorithm that is specified in this standard, a conforming implementation may replace the given set of steps with any mathematically equivalent set of steps. In other words, the specified algorithm may be replaced with a different procedure that produces the correct output for every input (where â€œinputâ€ includes the specified input as well as all parameter values and all randomness). Approved usage of the shared secret key. If randomness generation is successful, the values ğ¾ and ğ¾â€² returned by ML-KEM.Encaps and ML-KEM.Decaps, respectively, are always 256-bit values. Under appropriate conditions (see Sections 3.1 and 3.2, and SP 800-227 ), these values match (i.e., ğ¾â€² =ğ¾) and can be used directly as a shared secret key for symmetric cryptography. If further key derivation is needed, the final symmetric keys shall be derived from this 256-bit shared secret key in an approved manner, as specified in SP 800-108 and SP 800-56C [16, 17]. As discussed in Section 3.2, ML-KEM is an IND-CCA2-secure KEM. However, a combined KEM that includes ML-KEM as a component might not meet IND-CCA2 security. Implementers should assess the security of any procedure in which the key derivation methods of SP 800-56C are applied to ML-KEM in combination with another key establishment procedure. More guidance regarding combined KEMs is given in SP 800-227 . Randomness generation. Two algorithms in this standard require the generation of randomness as an internal step: ML-KEM.KeyGen and ML-KEM.Encaps. In pseudocode, this randomness generation is denoted by a statement of the form ğ‘š â†$ âˆ’ ğ”¹32 . A fresh string of random bytes must be generated for every such invocation. These random bytes shall be generated using an approved RBG, as prescribed in SP 800-90A, SP 800-90B, and SP 800-90C [18, 19, 20]. Moreover, this RBG shall have a security strength of at least 128 bits for ML-KEM-512, at least 192 bits for ML-KEM-768, and at least 256 bits for ML-KEM-1024. Input checking. The algorithms ML-KEM.Encaps and ML-KEM.Decaps require input checking. Implementers shall ensure that ML-KEM.Encaps and ML-KEM.Decaps are only executed on inputs that have been checked, as described in Section 7. Destruction of intermediate values. Data used in intermediate computation steps of KEM algorithms could be used by an adversary to compromise security. Therefore, implementers shall ensure that intermediate data is destroyed as soon as it is no longer needed. In particular, for ML-KEM.KeyGen, ML-KEM.Encaps, and ML-KEM.Decaps, only the designated output can be retained in memory after the algorithm terminates. All other data shall be destroyed prior to 16FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM the algorithm terminating. There are two exceptions to this rule: 1. The seed (ğ‘‘,ğ‘§) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later expansion using ML-KEM.KeyGen_internal. As this seed can be used to compute the decapsulation key, it is sensitive data and shall be treated with the same safeguards as a decapsulation key (see SP 800-227 ). 2. The matrix ğ€Ì‚ generated in steps 3-7 of K-PKE.KeyGen (as a subroutine of ML-KEM.KeyGen) can be stored so that it need not be recomputed in later operations (e.g., ML-KEM.Decaps). The same matrix ğ€Ì‚ is also generated in steps 4-8 of K-PKE.Encrypt (as a subroutine of ML-KEM.Encaps or ML-KEM.Decaps); it can also then be stored. In either case, the matrix ğ€Ì‚ is data that is easily computed from the public encapsulation key and thus does not require any special protections. No floating-point arithmetic. Implementations of ML-KEM shall not use floating-point arithmetic, as rounding errors in floating-point operations may lead to incorrect results in some cases. In all pseudocode in this standard in which division is performed (e.g., ğ‘¥/ğ‘¦) and ğ‘¦ may not divide ğ‘¥, either âŒŠğ‘¥/ğ‘¦âŒ‹, âŒˆğ‘¥/ğ‘¦âŒ‰, or âŒˆğ‘¥/ğ‘¦âŒ‹ is used. All of these can be computed without floating-point arithmetic, as ordinary integer division ğ‘¥/ğ‘¦ computes âŒŠğ‘¥/ğ‘¦âŒ‹, and âŒˆğ‘¥/ğ‘¦âŒ‰ = âŒŠ(ğ‘¥ + ğ‘¦ âˆ’ 1)/ğ‘¦âŒ‹ for non-negative integers ğ‘¥ and positive integers ğ‘¦. 17FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 4. Auxiliary Algorithms 4.1 Cryptographic Functions The algorithms specified in this publication require the use of several cryptographic functions. Each function shall be instantiated by means of an approved hash function or an approved eXtendable-Output Function (XOF), as prescribed below. The relevant hash functions and XOFs are described in detail in FIPS 202 . They will be used as follows. SHA3-256 and SHA3-512 are hash functions with one variable-length input and one fixed-length output. In this standard, invocations of these functions on an input ğ‘€ will be denoted by SHA3-256(ğ‘€) and SHA3-512(ğ‘€), respectively. The inputs and outputs for both SHA3-256 and SHA3-512 are always byte arrays. SHAKE128 and SHAKE256 are XOFs with one variable-length input and one variable-length output. This standard will adhere to the following conventions : â€¢ The inputs and outputs for both SHAKE128 and SHAKE256 are always byte arrays. â€¢ When invoking SHAKE128 or SHAKE256, desired output length is always specified in bits. For example, the expression ğ‘Ÿ âˆ¶= SHAKE128(ğ‘€,8 â‹… 64) (4.1) implies that ğ‘€ is an array of bytes and that ğ‘Ÿ is an array of 64 bytes. The aforementioned functions play several different roles in the algorithms specified in this standard and will only be invoked using the wrapper functions defined below. Importantly, these wrappers will avoid any potential â€œbyte arrayâ€ versus â€œbit-lengthâ€ confusion by only working with bytes and byte array lengths. Pseudorandom function (PRF). The function PRF takes a parameter ğœ‚ âˆˆ {2,3}, one 32-byte input, and one 1-byte input. It produces one (64 â‹… ğœ‚)-byte output. It will be denoted by PRF âˆ¶ {2,3}Ã—ğ”¹32 Ã—ğ”¹ â†’ ğ”¹64ğœ‚, (4.2) and it shall be instantiated as PRF (ğ‘ ,ğ‘) âˆ¶= SHAKE256(ğ‘ â€–ğ‘,8 â‹… 64 â‹… ğœ‚), (4.3) ğœ‚ where ğœ‚ âˆˆ {2,3}, ğ‘  âˆˆ ğ”¹32 , and ğ‘ âˆˆ ğ”¹. Note that ğœ‚ is only used to specify the desired output length and not to perform domain separation. Hash functions. The specification will also make use of three hash functions H, J and G, which are defined as follows. The functions H and J each take one variable-length input and produce one 32-byte output. They will be denoted by H âˆ¶ ğ”¹âˆ— â†’ ğ”¹32 and J âˆ¶ ğ”¹âˆ— â†’ ğ”¹32 , respectively, and shall be instantiated as H(ğ‘ ) âˆ¶= SHA3-256(ğ‘ ) and J(ğ‘ ) âˆ¶= SHAKE256(ğ‘ ,8 â‹… 32) (4.4) 18FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM where ğ‘  âˆˆ ğ”¹âˆ— . The function G takes one variable-length input and produces two 32-byte outputs. It will be denoted by G âˆ¶ ğ”¹âˆ— â†’ ğ”¹32 Ã— ğ”¹32 . The two outputs of G will be denoted by (ğ‘,ğ‘) â† G(ğ‘), where ğ‘,ğ‘ âˆˆ ğ”¹32 , ğ‘ âˆˆğ”¹âˆ— , and G(ğ‘) = ğ‘â€–ğ‘. The function G shall be instantiated as G(ğ‘) âˆ¶= SHA3-512(ğ‘). (4.5) eXtendable-Output Function (XOF). This standard uses a XOF wrapper defined in terms of the incremental API for SHAKE128 in SP 800-185 . This SHAKE128 API consists of three functions: â€¢ ctx â† SHAKE128.Init() Initializes a XOF â€œcontextâ€ ctx. â€¢ ctx â† SHAKE128.Absorb(ctx,str) Injects data to be used in the â€œabsorbingâ€ phase of SHAKE128 and updates the context accordingly. â€¢ (ctx,ğµ) â† SHAKE128.Squeeze(ctx,8 â‹… ğ‘§) Extracts ğ‘§ output bytes produced during the â€œsqueezingâ€ phase of SHAKE128 and updates the context accordingly. While the above functions are constructed using the Keccak-ğ‘“ permutation rather than the XOF SHAKE128 directly, they are defined so that a single SHAKE128 call of the form output â† SHAKE128(str â€–â€¦â€–str ,8ğ‘ +â€¦+8ğ‘ ) (4.6) 1 ğ‘š 1 â„“ is equivalent to performing Algorithm 2. This equivalence holds whether or not |str | and ğ‘ are ğ‘– ğ‘— multiples of the SHAKE128 block length. Algorithm 2 SHAKE128example(str ,â€¦,str ,ğ‘ ,â€¦,ğ‘ ) 1 ğ‘š 1 â„“ Performs a sequence of absorbing operations followed by a sequence of squeezing operations. Input: byte arrays str ,â€¦,str . 1 ğ‘š Input: positive integers ğ‘ ,â€¦,ğ‘ . 1 â„“ Output: a byte array of length âˆ‘â„“ ğ‘ . ğ‘—=1 ğ‘— 1: ctx â† SHAKE128.Init() â–· initialize context 2: for (ğ‘– â† 1; ğ‘– â‰¤ ğ‘š; ğ‘–++) 3: ctx â† SHAKE128.Absorb(ctx,str ) â–· absorb byte array str ğ‘– ğ‘– 4: end for 5: for (ğ‘— â†1; ğ‘— â‰¤â„“; ğ‘—++) 6: (ctx,out ) â† SHAKE128.Squeeze(ctx,8â‹…ğ‘ ) â–· squeeze ğ‘ -many bytes ğ‘— ğ‘— ğ‘— 7: end for 8: output â† out â€–â€¦â€–out â–· return the concatenation of all the results 1 â„“ In this standard, the incremental API for SHAKE128 will only be invoked through a wrapper XOF, 19FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM which is defined as follows. 1. XOF.Init() = SHAKE128.Init(). 2. XOF.Absorb(ctx, str)= SHAKE128.Absorb(ctx,str). 3. XOF.Squeeze(ctx,â„“) = SHAKE128.Squeeze(ctx,8 â‹… â„“). Note that XOF.Squeeze requires the input length to be specified in bytes. This is consistent with the convention that all wrapper functions treat inputs and outputs as byte arrays and measure the lengths of all such arrays in terms of bytes. 4.2 General Algorithms This section specifies a number of algorithms that will be used as subroutines in ML-KEM. 4.2.1 Conversion and Compression Algorithms This section specifies several algorithms for converting between bit arrays, byte arrays, and arrays of integers modulo ğ‘š. It also specifies a certain operation for compressing integers modulo ğ‘, and the corresponding decompression operation. Algorithm 3 BitsToBytes(ğ‘) Converts a bit array (of a length that is a multiple of eight) into an array of bytes. Input: bit array ğ‘ âˆˆ {0,1}8â‹…â„“ . Output: byte array ğµ âˆˆ ğ”¹â„“ . 1: ğµ â† (0,â€¦,0) 2: for (ğ‘– â† 0; ğ‘– < 8â„“; ğ‘–++) 3: ğµ[âŒŠğ‘–/8âŒ‹] â† ğµ[âŒŠğ‘–/8âŒ‹]+ğ‘[ğ‘–]â‹…2ğ‘– mod 8 4: end for 5: return ğµ Algorithm 4 BytesToBits(ğµ) Performs the inverse of BitsToBytes, converting a byte array into a bit array. Input: byte array ğµ âˆˆğ”¹â„“ . Output: bit array ğ‘ âˆˆ {0,1}8â‹…â„“ . 1: ğ¶ â†ğµ â–· copy ğµ into array ğ¶ âˆˆğ”¹â„“ 2: for (ğ‘– â† 0; ğ‘– < â„“; ğ‘–++) 3: for (ğ‘— â† 0; ğ‘— < 8; ğ‘—++) 4: ğ‘[8ğ‘–+ğ‘—] â† ğ¶[ğ‘–] mod 2 5: ğ¶[ğ‘–] â† âŒŠğ¶[ğ‘–]/2âŒ‹ 6: end for 7: end for 8: return ğ‘ 20FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Converting between bits and bytes. The algorithms BitsToBytes (Algorithm 3) and BytesToBits (Algorithm 4) convert between bit arrays and byte arrays. The inputs to BitsToBytes and the outputs of BytesToBits are bit arrays, with each segment of eight bits representing a byte in little-endian order. As an example, the 8-bit string 11010001 corresponds to the byte 20 +21 + 23+27 =139. Compression and decompression. Recall that ğ‘ = 3329, and that the bit length of ğ‘ is 12. For ğ‘‘ < 12, define Compress âˆ¶ â„¤ âŸ¶ â„¤ (4.7) ğ‘‘ ğ‘ 2ğ‘‘ ğ‘¥ âŸ¼ âŒˆ(2ğ‘‘/ğ‘) â‹… ğ‘¥âŒ‹ mod 2ğ‘‘ . Decompress âˆ¶ â„¤ âŸ¶ â„¤ (4.8) ğ‘‘ 2ğ‘‘ ğ‘ ğ‘¦ âŸ¼ âŒˆ(ğ‘/2ğ‘‘) â‹… ğ‘¦âŒ‹. The input and output types of these functions are integers modulo ğ‘š (see Section 2.4.1). Division and rounding in the computation of these functions are performed in the set of rational numbers. Floating-point computations shall not be used. The Compress and Decompress algorithms satisfy two important properties. First, decompression followed by compression preserves the input. That is, Compress (Decompress (ğ‘¦)) = ğ‘¦ for ğ‘‘ ğ‘‘ all ğ‘¦ âˆˆ â„¤ and all ğ‘‘ < 12. Second, if ğ‘‘ is large (i.e., close to 12), compression followed by 2ğ‘‘ decompression does not significantly alter the value. Encoding and decoding. The algorithms ByteEncode (Algorithm 5) and ByteDecode (Algorithm 6) will be used for conversion between integers modulo ğ‘š and bytes. The algorithm ByteEncode converts an array of ğ‘› = 256 integers modulo ğ‘š into a corresponding array of bytes. ByteDecode performs the inverse operation, converting an array of bytes into an array of integers modulo ğ‘š. Specifying the modulus ğ‘š is done as described below. For the following description, it is convenient to view ByteDecode and ByteEncode as converting between integers and bits. The conversion between bits and bytes is straightforward and done using BitsToBytes and BytesToBits. The valid range of values for the parameter ğ‘‘ is 1â‰¤ğ‘‘ â‰¤12. Bit arrays are divided into ğ‘‘-bit segments. The operations are performed in two different ways, depending on the value of ğ‘‘: â€¢ For ğ‘‘ satisfying 1 â‰¤ ğ‘‘ â‰¤ 11, the conversion is one-to-one. ByteDecode converts each ğ‘‘ ğ‘‘-bit segment of its input into one integer modulo 2ğ‘‘ , while ByteEncode performs the ğ‘‘ inverse operation. â€¢ For ğ‘‘ = 12, ByteDecode produces integers modulo ğ‘ as output, while ByteEncode 12 12 receives integers modulo ğ‘ as input. Specifically, ByteDecode converts each 12-bit 12 segment of its input into an integer modulo 212 = 4096 and then reduces the result modulo ğ‘. This is no longer a one-to-one operation. Indeed, some 12-bit segments could correspond to an integer greater than ğ‘âˆ’1 = 3328 but less than 4096. However, this cannot occur for arrays produced by ByteEncode . These aspects of ByteDecode and 12 12 21FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM ByteEncode will be important when considering checking of the ML-KEM encapsulation 12 key in Section 7. Algorithm 5 ByteEncode (ğ¹ ) ğ‘‘ Encodes an array of ğ‘‘-bit integers into a byte array for 1â‰¤ğ‘‘ â‰¤12. Input: integer array ğ¹ âˆˆ â„¤256 , where ğ‘š = 2ğ‘‘ if ğ‘‘ <12, and ğ‘š = ğ‘ if ğ‘‘ =12. ğ‘š Output: byte array ğµ âˆˆ ğ”¹32ğ‘‘ . 1: for (ğ‘– â† 0; ğ‘– < 256; ğ‘–++) 2: ğ‘â†ğ¹[ğ‘–] â–·ğ‘âˆˆâ„¤ ğ‘š 3: for (ğ‘— â† 0; ğ‘— < ğ‘‘; ğ‘—++) 4: ğ‘[ğ‘–â‹…ğ‘‘+ğ‘—] â† ğ‘ mod 2 â–· ğ‘ âˆˆ {0,1}256â‹…ğ‘‘ 5: ğ‘â†(ğ‘âˆ’ğ‘[ğ‘–â‹…ğ‘‘+ğ‘—])/2 â–· note ğ‘ âˆ’ ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] is always even 6: end for 7: end for 8: ğµ â† BitsToBytes(ğ‘) 9: return ğµ Algorithm 6 ByteDecode (ğµ) ğ‘‘ Decodes a byte array into an array of ğ‘‘-bit integers for 1â‰¤ğ‘‘ â‰¤12. Input: byte array ğµ âˆˆ ğ”¹32ğ‘‘ . Output: integer array ğ¹ âˆˆ â„¤256 , where ğ‘š = 2ğ‘‘ if ğ‘‘ < 12 and ğ‘š = ğ‘ if ğ‘‘ = 12. ğ‘š 1: ğ‘ â† BytesToBits(ğµ) 2: for (ğ‘– â† 0; ğ‘– < 256; ğ‘–++) 3: ğ¹ [ğ‘–] â† âˆ‘ğ‘‘âˆ’1 ğ‘[ğ‘– â‹… ğ‘‘ + ğ‘—] â‹… 2ğ‘— mod ğ‘š ğ‘—â†0 4: end for 5: return ğ¹ 4.2.2 Sampling Algorithms The algorithms of ML-KEM require two sampling subroutines that are specified in Algorithms 7 and 8. Both of these algorithms can be used to convert a stream of uniformly random bytes into a sample from some desired distribution. In this standard, these algorithms will be invoked with a stream of pseudorandom bytes as the input. It follows that the output will then be a sample from a distribution that is computationally indistinguishable from the desired distribution. Uniform sampling of NTT representations. The algorithm SampleNTT (Algorithm 7) converts a seed together with two indexing bytes into a polynomial in the NTT domain. If the seed is uniformly random, the resulting polynomial will be drawn from a distribution that is computa- tionally indistinguishable from the uniform distribution on ğ‘‡ . The output of SampleNTT is an ğ‘ array in â„¤256 that contains the coefficients of the sampled element of ğ‘‡ (see Section 2.4.4). See ğ‘ ğ‘ Appendix B for a note on (optionally) safely bounding the algorithmâ€™s while-loop iterations. 22FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Algorithm 7 SampleNTT(ğµ) Takes a 32-byte seed and two indices as input and outputs a pseudorandom element of ğ‘‡ . ğ‘ Input: byte array ğµ âˆˆ ğ”¹34 . â–· a 32-byte seed along with two indices Output: array ğ‘Ì‚ âˆˆâ„¤256 . â–· the coefficients of the NTT of a polynomial ğ‘ 1: ctx â† XOF.Init() 2: ctx â† XOF.Absorb(ctx,ğµ) â–· input the given byte array into XOF 3: ğ‘— â†0 4: while ğ‘— < 256 do 5: (ctx,ğ¶) â† XOF.Squeeze(ctx,3) â–· get a fresh 3-byte array ğ¶ from XOF 6: ğ‘‘ â†ğ¶+256â‹…(ğ¶ mod 16) â–·0â‰¤ğ‘‘ <212 1 1 7: ğ‘‘ â†âŒŠğ¶/16âŒ‹+16â‹…ğ¶ â–·0â‰¤ğ‘‘ <212 2 2 8: if ğ‘‘ <ğ‘ then 1 9: ğ‘[Ì‚ ğ‘—] â† ğ‘‘ â–· ğ‘ Ì‚ âˆˆ â„¤256 1 ğ‘ 10: ğ‘— â†ğ‘—+1 11: end if 12: if ğ‘‘ <ğ‘ and ğ‘— <256 then 2 13: ğ‘[Ì‚ ğ‘—] â† ğ‘‘ 2 14: ğ‘— â†ğ‘—+1 15: end if 16: end while 17: return ğ‘Ì‚ Sampling from the centered binomial distribution. ML-KEM makes use of a special distribution D (ğ‘… ) of polynomials in ğ‘… with small coefficients. Such polynomials are sometimes referred ğœ‚ ğ‘ ğ‘ to as â€œerrorsâ€ or â€œnoise.â€ The distribution is parameterized by an integer ğœ‚ âˆˆ {2,3}. To sample a polynomial from D (ğ‘… ), each of its coefficients is independently sampled from a certain cen- ğœ‚ ğ‘ tered binomial distribution (CBD) on â„¤ . The algorithm SamplePolyCBD (Algorithm 8) samples ğ‘ the coefficient array of a polynomial ğ‘“ âˆˆ ğ‘… according to the distribution D (ğ‘… ), provided that ğ‘ ğœ‚ ğ‘ Algorithm 8 SamplePolyCBD (ğµ) ğœ‚ Takes a seed as input and outputs a pseudorandom sample from the distribution D (ğ‘… ). ğœ‚ ğ‘ Input: byte array ğµ âˆˆ ğ”¹64ğœ‚ . Output: array ğ‘“ âˆˆ â„¤256. â–· the coefficients of the sampled polynomial ğ‘ 1: ğ‘ â† BytesToBits(ğµ) 2: for (ğ‘– â† 0; ğ‘– < 256; ğ‘–++) 3: ğ‘¥â†âˆ‘ğœ‚âˆ’1 ğ‘[2ğ‘–ğœ‚ + ğ‘—] â–·0â‰¤ğ‘¥â‰¤ğœ‚ ğ‘—â†0 4: ğ‘¦â†âˆ‘ğœ‚âˆ’1 ğ‘[2ğ‘–ğœ‚ + ğœ‚ + ğ‘—] â–·0â‰¤ğ‘¦â‰¤ğœ‚ ğ‘—â†0 5: ğ‘“[ğ‘–] â† ğ‘¥âˆ’ğ‘¦ mod ğ‘ â–·0â‰¤ğ‘“[ğ‘–]â‰¤ğœ‚ or ğ‘âˆ’ğœ‚ â‰¤ğ‘“[ğ‘–]â‰¤ğ‘âˆ’1 6: end for 7: return ğ‘“ 23FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM its input is a stream of uniformly random bytes. 4.3 The Number-Theoretic Transform The Number-Theoretic Transform (NTT) can be viewed as a specialized, exact version of the discrete Fourier transform. In the case of ML-KEM, the NTT is used to improve the efficiency of multiplication in the ring ğ‘… . Recall that ğ‘… is the ring â„¤ [ğ‘‹]/(ğ‘‹ğ‘› +1) of polynomials of the ğ‘ ğ‘ ğ‘ form ğ‘“ =ğ‘“ +ğ‘“ ğ‘‹+â‹¯+ğ‘“ ğ‘‹255 (where ğ‘“ âˆˆ â„¤ for all ğ‘—), with the ring operations defined 0 1 255 ğ‘— ğ‘ by arithmetic modulo ğ‘‹ğ‘› +1. The ring ğ‘… is isomorphic to another ring ğ‘‡ , which is a direct sum of 128 quadratic extensions ğ‘ ğ‘ of â„¤ . The NTT is a computationally efficient isomorphism between these two rings. When a ğ‘ polynomial ğ‘“ âˆˆ ğ‘… is input, the NTT outputs an element ğ‘“ Ì‚ âˆ¶= NTT(ğ‘“) of the ring ğ‘‡ , where ğ‘“ iÌ‚s ğ‘ ğ‘ called the â€œNTT representationâ€ of ğ‘“. The isomorphism property implies that ğ‘“ Ã— ğ‘” = NTTâˆ’1(ğ‘“ Ã—Ì‚ ğ‘”) Ì‚ , (4.9) ğ‘… ğ‘‡ ğ‘ ğ‘ where Ã— and Ã— denote multiplication in ğ‘… and ğ‘‡ , respectively. Moreover, since ğ‘‡ is a ğ‘… ğ‘‡ ğ‘ ğ‘ ğ‘ ğ‘ ğ‘ product of 128 rings that each consist of polynomials of degree at most one, the operation Ã— ğ‘‡ ğ‘ is much more efficient than the operation Ã— . For these reasons, the NTT is considered to be ğ‘… ğ‘ an integral part of ML-KEM and not merely an optimization. As the rings ğ‘… and ğ‘‡ have a vector space structure over â„¤ , the most natural abstract data ğ‘ ğ‘ ğ‘ type to represent elements from either of these rings is â„¤ğ‘›. For this reason, the choice of data ğ‘ structure for the inputs and outputs of NTT and NTTâˆ’1 are length-ğ‘› arrays of integers modulo ğ‘. These arrays are understood to represent elements of ğ‘‡ or ğ‘… , respectively (see Section ğ‘ ğ‘ 2.4.4). Algorithms 9 and 10 describe an efficient means of computing NTT and NTTâˆ’1 in place. However, to clarify the distinction between the algebraic objects before and after the conversion, the algorithms are written with explicit inputs and outputs. This is consistent with this standardâ€™s convention that all inputs are passed by copy. The mathematical structure of the NTT. In ML-KEM, ğ‘ is the prime 3329 = 28â‹…13+1, and ğ‘› = 256. There are 128 primitive 256-th roots of unity and no primitive 512-th roots of unity in â„¤ . Note that ğœ =17âˆˆâ„¤ is a primitive 256-th root of unity modulo ğ‘. Thus, ğœ128 â‰¡ âˆ’1. ğ‘ ğ‘ Define BitRev (ğ‘–) to be the integer represented by bit-reversing the unsigned 7-bit value that 7 corresponds to the input integer ğ‘– âˆˆ {0,â€¦,127}. The polynomial ğ‘‹256 +1 factors into 128 polynomials of degree 2 modulo ğ‘ as follows: 127 ğ‘‹256+1 = âˆ (ğ‘‹2âˆ’ğœ2BitRev 7(ğ‘–)+1). (4.10) ğ‘–=0 Therefore, ğ‘… âˆ¶=â„¤ [ğ‘‹]/(ğ‘‹256+1) is isomorphic to a direct sum of 128 quadratic extension ğ‘ ğ‘ 24FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM fields of â„¤ , denoted ğ‘‡ . Specifically, this ring has the structure ğ‘ ğ‘ 127 ğ‘‡ ğ‘ âˆ¶=â¨â„¤ ğ‘[ğ‘‹]/(ğ‘‹2âˆ’ğœ2BitRev 7(ğ‘–)+1). (4.11) ğ‘–=0 Thus, the NTT representation ğ‘“ Ì‚ âˆˆ ğ‘‡ of a polynomial ğ‘“ âˆˆ ğ‘… is the vector that consists of the ğ‘ ğ‘ corresponding residues of degree at most one: ğ‘“ Ì‚ âˆ¶= (ğ‘“ mod (ğ‘‹2 âˆ’ğœ2BitRev 7(0)+1),â€¦,ğ‘“ mod (ğ‘‹2 âˆ’ğœ2BitRev 7(127)+1)) . (4.12) As discussed in Section 2.4.4, the algorithms in this standard represent ğ‘“ Ì‚as an array of 256 integers modulo ğ‘. Specifically, ğ‘“ mod (ğ‘‹2 âˆ’ğœ2BitRev 7(ğ‘–)+1) = ğ‘“[ Ì‚ 2ğ‘–] + ğ‘“[Ì‚ 2ğ‘– + 1]ğ‘‹, (4.13) for ğ‘– from 0 to 127. The ML-KEM NTT algorithms. An algorithm for the ML-KEM NTT is described in Algorithm 9. An algorithm for the inverse operation (NTTâˆ’1) is described in Algorithm 10. These two algorithms will be used to transform elements of ğ‘… to elements of ğ‘‡ (using NTT) and vice versa (using ğ‘ ğ‘ NTTâˆ’1). In addition, as discussed in Section 2.4.8, these algorithms represent the coordinate- wise transformation of structures over those rings. Specifically, they map matrices/vectors with entries in ğ‘… to matrices/vectors with entries in ğ‘‡ (using NTT) and vice versa (using NTTâˆ’1). ğ‘ ğ‘ The values ğœBitRev 7(ğ‘–) mod ğ‘ for ğ‘– = 1,â€¦,127 used in line 5 of Algorithm 9 and line 5 of Algorithm 10 may be precomputed into an array. This array is given in Appendix A. 25FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Algorithm 9 NTT(ğ‘“) Computes the NTT representation ğ‘“ oÌ‚ f the given polynomial ğ‘“ âˆˆ ğ‘… . ğ‘ Input: array ğ‘“ âˆˆ â„¤256. â–· the coefficients of the input polynomial ğ‘ Output: array ğ‘“ Ì‚ âˆˆ â„¤256. â–· the coefficients of the NTT of the input polynomial ğ‘ 1: ğ‘“Ì‚ â†ğ‘“ â–· will compute in place on a copy of input array 2: ğ‘– â† 1 3: for (len â† 128; len â‰¥2; len â† len/2) 4: for (start â†0; start < 256; start â† start +2â‹… len) 5: zeta â† ğœBitRev 7(ğ‘–) mod ğ‘ 6: ğ‘– â† ğ‘–+1 7: for (ğ‘— â† start; ğ‘— < start + len; ğ‘—++) 8: ğ‘¡ â† zeta â‹… ğ‘“[Ì‚ ğ‘— + len] â–· steps 8-10 done modulo ğ‘ 9: ğ‘“[Ì‚ ğ‘— + len] â† ğ‘“[Ì‚ ğ‘—]âˆ’ğ‘¡ Ì‚ Ì‚ 10: ğ‘“[ğ‘—] â† ğ‘“[ğ‘—]+ğ‘¡ 11: end for 12: end for 13: end for 14: return ğ‘“ Ì‚ Algorithm 10 NTTâˆ’1(ğ‘“) Ì‚ Computes the polynomial ğ‘“ âˆˆ ğ‘… that corresponds to the given NTT representation ğ‘“ Ì‚ âˆˆ ğ‘‡ . ğ‘ ğ‘ Input: array ğ‘“ Ì‚ âˆˆ â„¤256. â–· the coefficients of input NTT representation ğ‘ Output: array ğ‘“ âˆˆ â„¤256. â–· the coefficients of the inverse NTT of the input ğ‘ 1: ğ‘“ â† ğ‘“Ì‚ â–· will compute in place on a copy of input array 2: ğ‘– â† 127 3: for (len â†2; len â‰¤ 128; len â†2â‹… len) 4: for (start â†0; start < 256; start â† start +2â‹… len) 5: zeta â† ğœBitRev 7(ğ‘–) mod ğ‘ 6: ğ‘– â† ğ‘–âˆ’1 7: for (ğ‘— â† start; ğ‘— < start + len; ğ‘—++) 8: ğ‘¡ â† ğ‘“[ğ‘—] 9: ğ‘“[ğ‘—] â† ğ‘¡+ğ‘“[ğ‘—+ len] â–· steps 9-10 done modulo ğ‘ 10: ğ‘“[ğ‘— + len]â† zeta â‹… (ğ‘“[ğ‘— + len] âˆ’ ğ‘¡) 11: end for 12: end for 13: end for 14: ğ‘“ â†ğ‘“â‹…3303 mod ğ‘ â–· multiply every entry by 3303 â‰¡ 128âˆ’1 mod ğ‘ 15: return ğ‘“ 26FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 4.3.1 Multiplication in the NTT Domain The addition and scalar multiplication of elements of ğ‘‡ can be done using the corresponding ğ‘ coordinate-wise arithmetic operations on the coefficient arrays (see Section 2.4.5). This section describes how to do the remaining ring operation (i.e., multiplication in ğ‘‡ ). ğ‘ Recall from (4.12) that ğ‘“ Ì‚ âˆˆ ğ‘‡ is a vector of 128 degree-one residues modulo quadratic polyno- ğ‘ mials. Algebraically, multiplication in the ring ğ‘‡ consists of independent multiplication in each ğ‘ of the 128 coordinates with respect to the quadratic modulus of that coordinate. Specifically, the ğ‘–-th coordinate in ğ‘‡ of the product â„Ì‚ =ğ‘“Ã—Ì‚ ğ‘”Ì‚ is determined by the calculation ğ‘ ğ‘‡ ğ‘ â„Ì‚[2ğ‘–]+ â„Ì‚ [2ğ‘–+1]ğ‘‹ =(ğ‘“[Ì‚ 2ğ‘–]+ ğ‘“[Ì‚ 2ğ‘–+1]ğ‘‹)(ğ‘”[Ì‚2ğ‘–]+ ğ‘”[Ì‚2ğ‘–+1]ğ‘‹) mod (ğ‘‹2 âˆ’ğœ2BitRev 7(ğ‘–)+1). (4.14) Algorithm 11 MultiplyNTTs(ğ‘“, Ì‚ ğ‘”) Ì‚ Computes the product (in the ring ğ‘‡ ) of two NTT representations. ğ‘ Input: Two arrays ğ‘“ Ì‚ âˆˆ â„¤256 and ğ‘” Ì‚ âˆˆ â„¤256 . â–· the coefficients of two NTT representations ğ‘ ğ‘ Output: An array â„Ì‚ âˆˆ â„¤256. â–· the coefficients of the product of the inputs ğ‘ 1: for (ğ‘– â† 0; ğ‘– < 128; ğ‘–++) 2: (â„Ì‚[2ğ‘–],â„Ì‚ [2ğ‘–+1]) â† BaseCaseMultiply(ğ‘“[Ì‚ 2ğ‘–],ğ‘“[Ì‚ 2ğ‘– + 1],ğ‘”[Ì‚2ğ‘–], ğ‘”[Ì‚2ğ‘– + 1],ğœ2BitRev 7(ğ‘–)+1) 3: end for 4: return â„Ì‚ Thus, one can compute the product of two elements of ğ‘‡ using the algorithm MultiplyNTTs (Al- ğ‘ gorithm 11), which uses BaseCaseMultiply (Algorithm 12) as a subroutine. The values ğœ2BitRev 7(ğ‘–)+1 used in Algorithm 11 may be precomputed and stored in an array (see Appendix A). MultiplyNTTs also enables linear-algebraic arithmetic with matrices and vectors whose entries are in ğ‘‡ (see ğ‘ Section 2.4.7). Algorithm 12 BaseCaseMultiply(ğ‘ ,ğ‘ ,ğ‘ ,ğ‘ ,ğ›¾) 0 1 0 1 Computes the product of two degree-one polynomials with respect to a quadratic modulus. Input: ğ‘ ,ğ‘ ,ğ‘ ,ğ‘ âˆˆ â„¤ . â–· the coefficients of ğ‘ + ğ‘ ğ‘‹ and ğ‘ + ğ‘ ğ‘‹ 0 1 0 1 ğ‘ 0 1 0 1 Input: ğ›¾ âˆˆâ„¤ . â–· the modulus is ğ‘‹2 âˆ’ğ›¾ ğ‘ Output: ğ‘ ,ğ‘ âˆˆ â„¤ . â–· the coefficients of the product of the two polynomials 0 1 ğ‘ 1: ğ‘ â†ğ‘ â‹…ğ‘ +ğ‘ â‹…ğ‘ â‹…ğ›¾ â–· steps 1-2 done modulo ğ‘ 0 0 0 1 1 2: ğ‘ â†ğ‘ â‹…ğ‘ +ğ‘ â‹…ğ‘ 1 0 1 1 0 3: return (ğ‘ , ğ‘ ) 0 1 27FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 5. The K-PKE Component Scheme This section describes the component scheme K-PKE. As discussed in Section 3.3, K-PKE is not approved for use in a stand-alone fashion. It serves only as a collection of subroutines for use in the algorithms of the approved scheme ML-KEM, as described in Section 7. K-PKE consists of three algorithms: 1. Key generation (K-PKE.KeyGen) 2. Encryption (K-PKE.Encrypt) 3. Decryption (K-PKE.Decrypt) When K-PKE is instantiated as part of ML-KEM, K-PKE inherits the parameter set selected for ML-KEM. Each parameter set specifies numerical values for each parameter. While ğ‘› is always 256 and ğ‘ is always 3329, the values of the remaining parameters ğ‘˜, ğœ‚ , ğœ‚ , ğ‘‘ , and ğ‘‘ vary 1 2 ğ‘¢ ğ‘£ among the three parameter sets. Parameters and parameter sets are described in Section 8. The algorithms in this section do not perform any input checking because they are only invoked as subroutines of the main ML-KEM algorithms. The algorithms of ML-KEM themselves do perform input checking as needed. Each of the algorithms of K-PKE is accompanied by a brief, informal description in text. For simplicity, this description is written in terms of vectors and matrices whose entries are elements of ğ‘… . In the actual algorithm, most of the computations occur in the NTT domain in order to ğ‘ improve the efficiency of multiplication. The relevant vectors and matrices will then have entries in ğ‘‡ . Linear-algebraic arithmetic with such vectors and matrices (e.g., line 18 of K-PKE.KeyGen) ğ‘ is performed as described in Sections 2.4.7 and 4.3.1. The encryption and decryption keys of K-PKE are also stored in the NTT form. 5.1 K-PKE Key Generation The key generation algorithm K-PKE.KeyGen of K-PKE (Algorithm 13) receives a seed as input and outputs an encryption key ek and a decryption key dk . As is typically the case for public-key PKE PKE encryption, the encryption key can be made public, while the decryption key and the randomness must remain private. Indeed, the encryption key of K-PKE will serve as the encapsulation key of ML-KEM (see ML-KEM.KeyGen below) and can thus be made public. Meanwhile, the decryption key and seed of K-PKE.KeyGen must remain private as they can be used to perform decapsulation in ML-KEM. The matrix ğ€Ì‚ generated in steps 3-7 of K-PKE.KeyGen can be stored, as specified in Section 3.3. This allows later operations to use ğ€Ì‚ directly rather than re-expanding it from the public seed ğœŒ. Informal description. The decryption key of K-PKE.KeyGen is a length-ğ‘˜ vector ğ¬ of elements of ğ‘… (i.e., ğ¬ âˆˆ ğ‘…ğ‘˜). Roughly speaking, ğ¬ is a set of secret variables, while the encryption key is ğ‘ ğ‘ a collection of â€œnoisyâ€ linear equations (ğ€,ğ€ğ¬ + ğ) in the secret variables ğ¬. The rows of the matrix ğ€ form the equation coefficients. This matrix is generated pseudorandomly using XOF with only a seed stored in the encryption key. The secret ğ¬ and the â€œnoiseâ€ ğ are sampled from 28FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Algorithm 13 K-PKE.KeyGen(ğ‘‘) Uses randomness to generate an encryption key and a corresponding decryption key. Input: randomness ğ‘‘ âˆˆ ğ”¹32 . Output: encryption key ek âˆˆ ğ”¹384ğ‘˜+32. PKE Output: decryption key dk âˆˆ ğ”¹384ğ‘˜ . PKE 1: (ğœŒ,ğœ) â† G(ğ‘‘â€–ğ‘˜) â–· expand 32+1 bytes to two pseudorandom 32-byte seeds1 2: ğ‘ â†0 3: for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘–++) â–· generate matrix ğ€Ì‚ âˆˆ (â„¤256)ğ‘˜Ã—ğ‘˜ ğ‘ 4: for (ğ‘— â† 0; ğ‘— < ğ‘˜; ğ‘—++) 5: ğ€Ì‚[ğ‘–,ğ‘—] â† SampleNTT(ğœŒâ€–ğ‘—â€–ğ‘–) â–· ğ‘— and ğ‘– are bytes 33 and 34 of the input 6: end for 7: end for 8: for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘–++) â–· generate ğ¬ âˆˆ (â„¤256)ğ‘˜ ğ‘ 9: ğ¬[ğ‘–] â† SamplePolyCBD (PRF (ğœ,ğ‘)) â–· ğ¬[ğ‘–] âˆˆ â„¤256 sampled from CBD ğœ‚ 1 ğœ‚ 1 ğ‘ 10: ğ‘ â†ğ‘+1 11: end for 12: for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘–++) â–· generate ğ âˆˆ (â„¤256)ğ‘˜ ğ‘ 13: ğ[ğ‘–] â† SamplePolyCBD (PRF (ğœ,ğ‘)) â–· ğ[ğ‘–] âˆˆ â„¤256 sampled from CBD ğœ‚ 1 ğœ‚ 1 ğ‘ 14: ğ‘ â†ğ‘+1 15: end for 16: ğ¬ Ì‚â† NTT(ğ¬) â–· run NTT ğ‘˜ times (once for each coordinate of ğ¬) 17: ğ Ì‚â† NTT(ğ) â–· run NTT ğ‘˜ times 18: ğ­Ì‚â† ğ€Ì‚ âˆ˜ ğ¬Ì‚ +ğÌ‚ â–· noisy linear system in NTT domain 19: ek â† ByteEncode (ğ­)Ì‚ â€–ğœŒ â–· run ByteEncode ğ‘˜ times, then append ğ€Ì‚-seed PKE 12 12 20: dk â† ByteEncode (ğ¬)Ì‚ â–· run ByteEncode ğ‘˜ times PKE 12 12 21: return (ek ,dk ) PKE PKE centered binomial distributions using randomness expanded from another seed ğœ via PRF. Once ğ€, ğ¬, and ğ are generated, the computation of the final part ğ­ = ğ€ğ¬+ğ of the encryption key takes place. The results are appropriately encoded into byte arrays and output. In K-PKE.KeyGen, the choice of parameter set affects the length of the secret ğ¬ (via the parameter ğ‘˜) and, as a consequence, the sizes of the noise vector ğ and the pseudorandom matrix ğ€. The choice of parameter set also affects the noise distribution (via the parameter ğœ‚ ) used to sample 1 the entries of ğ¬ and ğ. 5.2 K-PKE Encryption The encryption algorithm K-PKE.Encrypt of K-PKE (Algorithm 14) takes an encryption key ek , PKE a 32-byte plaintext ğ‘š, and randomness ğ‘Ÿ as input and produces a single output: a ciphertext ğ‘. 1Byte 33 of the input to G is the module dimension ğ‘˜ âˆˆ {2,3,4} âŠ‚ ğ”¹. This is included to establish domain separation between the three parameter sets. For implementations that use the seed in place of the private key, this ensures that the expansion will produce an unrelated key if the seed is mistakenly expanded using a parameter set other than the originally intended one. 29FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM The matrix ğ€Ì‚ generated in steps 4-8 of K-PKE.Encrypt can be stored, as specified in Section 3.3. This allows later operations to use ğ€Ì‚ directly rather than re-expanding it from the public seed ğœŒ. Algorithm 14 K-PKE.Encrypt(ek ,ğ‘š,ğ‘Ÿ) PKE Uses the encryption key to encrypt a plaintext message using the randomness ğ‘Ÿ. Input: encryption key ek âˆˆ ğ”¹384ğ‘˜+32. PKE Input: message ğ‘š âˆˆ ğ”¹32 . Input: randomness ğ‘Ÿ âˆˆ ğ”¹32 . Output: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ ğ‘¢ğ‘˜+ğ‘‘ ğ‘£). 1: ğ‘ â†0 2: ğ­ Ì‚ â† ByteDecode (ek [0 âˆ¶ 384ğ‘˜]) â–· run ByteDecode ğ‘˜ times to decode ğ­ Ì‚ âˆˆ (â„¤256 )ğ‘˜ 12 PKE 12 ğ‘ 3: ğœŒ â† ek [384ğ‘˜ âˆ¶ 384ğ‘˜ + 32] â–· extract 32-byte seed from ek PKE PKE 4: for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘–++) â–· re-generate matrix ğ€Ì‚ âˆˆ (â„¤256)ğ‘˜Ã—ğ‘˜ sampled in Alg. 13 ğ‘ 5: for (ğ‘— â† 0; ğ‘— < ğ‘˜; ğ‘—++) 6: ğ€Ì‚[ğ‘–,ğ‘—] â† SampleNTT(ğœŒâ€–ğ‘—â€–ğ‘–) â–· ğ‘— and ğ‘– are bytes 33 and 34 of the input 7: end for 8: end for 9: for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘–++) â–· generate ğ² âˆˆ (â„¤256)ğ‘˜ ğ‘ 10: ğ²[ğ‘–] â† SamplePolyCBD (PRF (ğ‘Ÿ,ğ‘)) â–· ğ²[ğ‘–] âˆˆ â„¤256 sampled from CBD ğœ‚ 1 ğœ‚ 1 ğ‘ 11: ğ‘ â†ğ‘+1 12: end for 13: for (ğ‘– â† 0; ğ‘– < ğ‘˜; ğ‘–++) â–· generate ğ âˆˆ (â„¤256)ğ‘˜ ğŸ ğ‘ 14: ğ [ğ‘–] â† SamplePolyCBD (PRF (ğ‘Ÿ,ğ‘)) â–· ğ [ğ‘–] âˆˆ â„¤256 sampled from CBD ğŸ ğœ‚ 2 ğœ‚ 2 ğŸ ğ‘ 15: ğ‘ â†ğ‘+1 16: end for 17: ğ‘’ â† SamplePolyCBD (PRF (ğ‘Ÿ,ğ‘)) â–· sample ğ‘’ âˆˆ â„¤256 from CBD 2 ğœ‚ 2 ğœ‚ 2 2 ğ‘ 18: ğ²Ì‚ â† NTT(ğ²) â–· run NTT ğ‘˜ times 19: ğ® â† NTTâˆ’1(ğ€Ì‚ âŠº âˆ˜ ğ²Ì‚ ) + ğ â–· run NTTâˆ’1 ğ‘˜ times ğŸ 20: ğœ‡ â† Decompress (ByteDecode (ğ‘š)) 1 1 21: ğ‘£ â† NTTâˆ’1(ğ­âŠºÌ‚ âˆ˜ğ²Ì‚ )+ğ‘’ +ğœ‡ â–· encode plaintext ğ‘š into polynomial ğ‘£ 2 22: ğ‘ â† ByteEncode (Compress (ğ®)) â–· run ByteEncode and Compress ğ‘˜ times 1 ğ‘‘ ğ‘‘ ğ‘‘ ğ‘‘ ğ‘¢ ğ‘¢ ğ‘¢ ğ‘¢ 23: ğ‘ â† ByteEncode (Compress (ğ‘£)) 2 ğ‘‘ ğ‘‘ ğ‘£ ğ‘£ 24: return ğ‘ â† (ğ‘ â€–ğ‘ ) 1 2 Informal description. The algorithm K-PKE.Encrypt begins by extracting the vector ğ­ and the seed from the encryption key. The seed is then expanded to re-generate the matrix ğ€ in the same manner as was done in K-PKE.KeyGen. If ğ­ and ğ€ are derived correctly from an encryption key produced by K-PKE.KeyGen, then they are equal to their corresponding values in K-PKE.KeyGen. Recall from the description of key generation that the pair (ğ€,ğ­ = ğ€ğ¬+ğ) can be thought of as a system of noisy linear equations in the secret variables ğ¬. One can generate an additional noisy linear equation in the same secret variables â€” without knowing ğ¬ â€” by picking a random linear 30FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM combination of the noisy equations in the system (ğ€,ğ­). One can then encode information in the â€œconstant termâ€ (i.e., the entry that is a linear combination of entries of ğ­) of such a combined equation. This information can then be deciphered by a party in possession of ğ¬. For example, one could encode a single bit by deciding whether or not to significantly alter the constant term, thus making either a nearly correct equation that corresponds to the decrypted bit value of 0 or a far-from-correct equation that corresponds to the decrypted bit value of 1. In the case of K-PKE, the constant term is a polynomial with 256 coefficients, so one can encode more information: one bit in each coefficient. To this end, K-PKE.Encrypt proceeds by generating a vector ğ² âˆˆ ğ‘…ğ‘˜ and noise terms ğ âˆˆ ğ‘…ğ‘˜ ğ‘ ğŸ ğ‘ and ğ‘’ âˆˆ ğ‘… , all of which are sampled from the centered binomial distribution using pseudoran- 2 ğ‘ domness expanded via PRF from the input randomness ğ‘Ÿ. One then computes the â€œnew noisy equation,â€ which is (up to some details) (ğ€âŠºğ² + ğ ,ğ­âŠºğ² + ğ‘’ ). An appropriate encoding ğœ‡ of 1 2 the input message ğ‘š is then added to the latter term in the pair. Finally, the resulting pair (ğ®,ğ‘£) is compressed, serialized into a byte array, and output as the ciphertext. 5.3 K-PKE Decryption The decryption algorithm K-PKE.Decrypt of K-PKE (Algorithm 15) takes a decryption key dk PKE and a ciphertext ğ‘ as input, requires no randomness, and outputs a plaintext ğ‘š. Informal description. The algorithm K-PKE.Decrypt begins by recovering a pair (ğ®â€²,ğ‘£â€²) from the ciphertext ğ‘ (see the description of K-PKE.Encrypt). Here, one can think of ğ®â€² as the coefficients of the equation and ğ‘£â€² as the constant term. The decryption key dk contains the vector of PKE secret variables ğ¬. The decryption algorithm can thus use the decryption key to compute the true constant term ğ‘£ = ğ¬âŠºğ®â€² and calculate ğ‘£â€² âˆ’ğ‘£. The decryption algorithm ends by decoding the plaintext message ğ‘š from ğ‘£â€² âˆ’ğ‘£ and outputting ğ‘š. Algorithm 15 K-PKE.Decrypt(dk ,ğ‘) PKE Uses the decryption key to decrypt a ciphertext. Input: decryption key dk âˆˆ ğ”¹384ğ‘˜ . PKE Input: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ ğ‘¢ğ‘˜+ğ‘‘ ğ‘£). Output: message ğ‘š âˆˆ ğ”¹32 . 1: ğ‘ â† ğ‘[0 âˆ¶ 32ğ‘‘ ğ‘˜] 1 ğ‘¢ 2: ğ‘ â†ğ‘[32ğ‘‘ ğ‘˜âˆ¶32(ğ‘‘ ğ‘˜+ğ‘‘ )] 2 ğ‘¢ ğ‘¢ ğ‘£ 3: ğ®â€² â† Decompress (ByteDecode (ğ‘ )) â–· run Decompress and ByteDecode ğ‘˜ times ğ‘‘ ğ‘‘ 1 ğ‘‘ ğ‘‘ ğ‘¢ ğ‘¢ ğ‘¢ ğ‘¢ 4: ğ‘£â€² â† Decompress (ByteDecode (ğ‘ )) ğ‘‘ ğ‘‘ 2 ğ‘£ ğ‘£ 5: ğ¬ Ì‚â† ByteDecode (dk ) â–· run ByteDecode ğ‘˜ times 12 PKE 12 6: ğ‘¤ â† ğ‘£â€² âˆ’ NTTâˆ’1(ğ¬âŠºÌ‚ âˆ˜ NTT(ğ®â€²)) â–· run NTT ğ‘˜ times; run NTTâˆ’1 once 7: ğ‘š â† ByteEncode (Compress (ğ‘¤)) â–· decode plaintext ğ‘š from polynomial ğ‘£ 1 1 8: return ğ‘š 31FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 6. Main Internal Algorithms This section specifies three algorithms: ML-KEM.KeyGen_internal, ML-KEM.Encaps_internal, and ML-KEM.Decaps_internal. These three algorithms are all deterministic, meaning that their output is completely determined by their input. No randomness is sampled inside of these algorithms. These three algorithms will be used to construct ML-KEM in Section 7. The algorithms in this section make use of the parameters ğ‘›, ğ‘, ğ‘˜, ğ‘‘ , and ğ‘‘ . The subroutines they invoke ğ‘¢ ğ‘£ additionally make use of the parameters ğœ‚ and ğœ‚ . While ğ‘› is always 256 and ğ‘ is always 3329, 1 2 the remaining parameters vary among the possible parameter sets (see Section 8). The interfaces specified in this section will be used to test ML-KEM implementations through the Cryptographic Algorithm Validation Program (CAVP). The key generation function in this section may also be used to re-expand a key from a seed (see Section 3.3), including when obtaining assurance of private key possession via regeneration. As prescribed in Section 3.3, the interfaces specified in this section should not be made available to applications other than for testing purposes, and the random seeds (as specified in ML-KEM.KeyGen and ML-KEM.Encaps in Section 7) shall be generated by the cryptographic module. 6.1 Internal Key Generation The algorithm ML-KEM.KeyGen_internal (Algorithm 16) accepts two random seeds as input, and produces an encapsulation key and a decapsulation key. Informal description. The core subroutine of ML-KEM.KeyGen_internal is the key generation algorithm of K-PKE (Algorithm 13). The encapsulation key is simply the encryption key of K-PKE. The decapsulation key consists of the decryption key of K-PKE, the encapsulation key, a hash of the encapsulation key, and a random 32-byte value. This random value will be used in the â€implicit rejectionâ€ mechanism of the internal decapsulation algorithm (Algorithm 18). Algorithm 16 ML-KEM.KeyGen_internal(ğ‘‘,ğ‘§) Uses randomness to generate an encapsulation key and a corresponding decapsulation key. Input: randomness ğ‘‘ âˆˆ ğ”¹32 . Input: randomness ğ‘§ âˆˆ ğ”¹32 . Output: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 . Output: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 . 1: (ek ,dk )â† K-PKE.KeyGen(ğ‘‘) â–· run key generation for K-PKE PKE PKE 2: ek â† ek â–· KEM encaps key is just the PKE encryption key PKE 3: dk â†(dk â€–ekâ€–H(ek)â€–ğ‘§) â–· KEM decaps key includes PKE decryption key PKE 4: return (ek,dk) 6.2 Internal Encapsulation The algorithm ML-KEM.Encaps_internal (Algorithm 17) accepts an encapsulation key and a ran- dom byte array as input and outputs a ciphertext and a shared key. 32FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Algorithm 17 ML-KEM.Encaps_internal(ek,ğ‘š) Uses the encapsulation key and randomness to generate a key and an associated ciphertext. Input: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 . Input: randomness ğ‘š âˆˆ ğ”¹32 . Output: shared secret key ğ¾ âˆˆ ğ”¹32 . Output: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ ğ‘¢ğ‘˜+ğ‘‘ ğ‘£). 1: (ğ¾,ğ‘Ÿ) â† G(ğ‘šâ€–H(ek)) â–· derive shared secret key ğ¾ and randomness ğ‘Ÿ 2: ğ‘ â† K-PKE.Encrypt(ek,ğ‘š,ğ‘Ÿ) â–· encrypt ğ‘š using K-PKE with randomness ğ‘Ÿ 3: return (ğ¾,ğ‘) Informal description. The core subroutine of ML-KEM.Encaps_internal is the encryption algo- rithm of K-PKE, which is used to encrypt a random value ğ‘š into a ciphertext ğ‘. A copy of the shared secret key ğ¾ and the randomness used during encryption are derived from ğ‘š and the encapsulation key ek via hashing. Specifically, H is applied to ek, and the result is concatenated with ğ‘š and then hashed using G. Finally, the algorithm outputs the shared secret key ğ¾ and the ciphertext ğ‘. 6.3 Internal Decapsulation The algorithm ML-KEM.Decaps_internal (Algorithm 18) accepts a decapsulation key and a cipher- text as input, does not use any randomness, and outputs a shared secret key. Informal description. The algorithm ML-KEM.Decaps_internal begins by parsing out the com- ponents of the decapsulation key dk of ML-KEM. These components are an (encryption key, decryption key) pair for K-PKE, a hash value â„, and a random value ğ‘§. The decryption key of K-PKE is then used to decrypt the input ciphertext ğ‘ to get a plaintext ğ‘šâ€² . The decapsulation algorithm then re-encrypts ğ‘šâ€² and computes a candidate shared secret key ğ¾â€² in the same manner as should have been done in encapsulation. Specifically, ğ¾â€² and the encryption ran- domness ğ‘Ÿâ€² are computed by hashing ğ‘šâ€² and the encryption key of K-PKE, and a ciphertext ğ‘â€² is generated by encrypting ğ‘šâ€² using randomness ğ‘Ÿâ€² . Finally, decapsulation checks whether the resulting ciphertext ğ‘â€² matches the provided ciphertext ğ‘. If it does not, the algorithm performs an â€œimplicit rejectionâ€: the value of ğ¾â€² is changed to a hash of ğ‘ together with the random value ğ‘§ stored in the ML-KEM secret key (see the discussion of decapsulation failures in Section 3.2). In either case, decapsulation outputs the resulting shared secret key ğ¾â€² . The â€œimplicit rejectâ€ flag computed in step 9 (by comparing ğ‘ and ğ‘â€² ) is a secret piece of interme- diate data. As specified in the requirements in Section 3.3, this flag shall be destroyed prior to ML-KEM.Decaps_internal terminating. In particular, returning the value of the flag as an output in any form is not permitted. 33FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Algorithm 18 ML-KEM.Decaps_internal(dk,ğ‘) Uses the decapsulation key to produce a shared secret key from a ciphertext. Input: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 . Input: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ ğ‘¢ğ‘˜+ğ‘‘ ğ‘£). Output: shared secret key ğ¾ âˆˆ ğ”¹32 . 1: dk â† dk[0 âˆ¶ 384ğ‘˜] â–· extract (from KEM decaps key) the PKE decryption key PKE 2: ek â† dk[384ğ‘˜ âˆ¶ 768ğ‘˜ + 32] â–· extract PKE encryption key PKE 3: â„â† dk[768ğ‘˜ + 32 âˆ¶ 768ğ‘˜ + 64] â–· extract hash of PKE encryption key 4: ğ‘§ â† dk[768ğ‘˜ + 64 âˆ¶ 768ğ‘˜ + 96] â–· extract implicit rejection value 5: ğ‘šâ€² â† K-PKE.Decrypt(dk ,ğ‘) â–· decrypt ciphertext PKE 6: (ğ¾â€²,ğ‘Ÿâ€²) â† G(ğ‘šâ€²â€–â„) 7: ğ¾Ì„ â† J(ğ‘§â€–ğ‘) 8: ğ‘â€² â† K-PKE.Encrypt(ek ,ğ‘šâ€²,ğ‘Ÿâ€²) â–· re-encrypt using the derived randomness ğ‘Ÿâ€² PKE 9: if ğ‘ â‰ ğ‘â€² then 10: ğ¾â€² â†ğ¾Ì„ â–· if ciphertexts do not match, â€œimplicitly rejectâ€ 11: end if 12: return ğ¾â€² 34FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 7. The ML-KEM Key-Encapsulation Mechanism This section describes the three main algorithms of the ML-KEM scheme: 1. Key generation (ML-KEM.KeyGen) 2. Encapsulation (ML-KEM.Encaps) 3. Decapsulation (ML-KEM.Decaps) To instantiate ML-KEM, one must select a parameter set. Each parameter set is associated with a particular trade-off between security and performance. The three possible parameter sets are called ML-KEM-512, ML-KEM-768, and ML-KEM-1024 and are described in detail in Table 2 of Section 8. Each parameter set assigns specific numerical values to the individual parameters ğ‘›, ğ‘, ğ‘˜, ğœ‚ , ğœ‚ , ğ‘‘ , and ğ‘‘ . While ğ‘› is always 256 and ğ‘ is always 3329, the remaining parameters 1 2 ğ‘¢ ğ‘£ vary among the three parameter sets. Implementers shall ensure that the three algorithms of ML-KEM listed above are only invoked with a valid parameter set, and that this parameter set is selected appropriately for the desired application. Moreover, implementers shall ensure that the parameter set used in any particular invocation of ML-KEM.Encaps or ML-KEM.Decaps matches the parameter set associated to the provided inputs. 7.1 ML-KEM Key Generation The key generation algorithm ML-KEM.KeyGen for ML-KEM (Algorithm 19) accepts no input, generates randomness internally, and produces an encapsulation key and a decapsulation key. While the encapsulation key can be made public, the decapsulation key shall remain private. The seed (ğ‘‘,ğ‘§) generated in steps 1 and 2 of ML-KEM.KeyGen can be stored for later expan- sion using ML-KEM.KeyGen_internal (see Section 3.3). As the seed can be used to compute the decapsulation key, it is sensitive data and shall be treated with the same safeguards as a decapsulation key (see SP 800-227 ). Algorithm 19 ML-KEM.KeyGen() Generates an encapsulation key and a corresponding decapsulation key. Output: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 . Output: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 . 1: ğ‘‘â†$ âˆ’ ğ”¹32 â–·ğ‘‘ is 32 random bytes (see Section 3.3) 2: ğ‘§â†$ âˆ’ ğ”¹32 â–·ğ‘§ is 32 random bytes (see Section 3.3) 3: if ğ‘‘ == NULL or ğ‘§ == NULL then 4: return âŠ¥ â–· return an error indication if random bit generation failed 5: end if 6: (ek, dk)â† ML-KEM.KeyGen_internal(ğ‘‘,ğ‘§) â–· run internal key generation algorithm 7: return (ek,dk) Secure key establishment depends on the use of key pairs that have been properly generated via ML-KEM.KeyGen. If the owner of a KEM key pair did not generate the key pair but instead received it from a trusted third party or other source, the owner may optionally perform certain 35FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM checks on the key pair. While these checks can detect certain corruptions, they do not guarantee that the key pair was properly generated. Key pair check. To check a candidate key pair1 (ek,dk), perform the following checks: 1. (Seed consistency) If a seed (ğ‘‘,ğ‘§) is available, run ML-KEM.KeyGen_internal(ğ‘‘,ğ‘§), and verify that the output is equal to (ek,dk). 2. (Encapsulation key check) Check ek as specified in Section 7.2. 3. (Decapsulation key check) Check dk as specified in Section 7.3. 4. (Pair-wise consistency) Perform the following steps: i. Generate an array of 32 random bytes by performing ğ‘š â†$ âˆ’ ğ”¹32 . ii. Perform (ğ¾,ğ‘) â† ML-KEM.Encaps_internal(ek,ğ‘š). iii. Perform ğ¾â€² â† ML-KEM.Decaps_internal(dk,ğ‘). iv. Reject unless ğ¾ == ğ¾â€² . It is important to note that this checking process does not guarantee that the key pair is a properly produced output of ML-KEM.KeyGen. 7.2 ML-KEM Encapsulation The encapsulation algorithm ML-KEM.Encaps of ML-KEM (Algorithm 20) accepts an encapsula- tion key as input, generates randomness internally, and outputs a ciphertext and a shared key. This algorithm requires input checking, as specified below. Encapsulation key check. To check a candidate encapsulation key ek, perform the following: 1. (Type check) If ek is not an array of bytes of length 384ğ‘˜ + 32 for the value of ğ‘˜ specified by the relevant parameter set, then input checking failed. 2. (Modulus check) Perform the computation test â† ByteEncode (ByteDecode (ek[0 âˆ¶ 384ğ‘˜])) (7.1) 12 12 (see Section 4.2.1). If test â‰  ek[0 âˆ¶ 384ğ‘˜], then input checking failed. This check ensures that the integers encoded in the public key are in the valid range [0,ğ‘ âˆ’ 1]. If both checks pass, then ML-KEM.Encaps can be run with input ek âˆ¶= ek. It is important to note that this checking process does not guarantee that ek is a properly produced output of ML-KEM.KeyGen. ML-KEM.Encaps shall not be run with an encapsulation key that has not been checked as above. However, checking of the encapsulation key need not be performed by the encapsulating party, 1In discussions of input checking, the â€œlow overlineâ€ in the notation indicates that the input has not yet been checked (e.g., ek has not yet been checked, while ek has passed the check). 36FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM nor with every execution of ML-KEM.Encaps. Instead, assurance that these checks have been performed can be acquired through other means (see SP 800-227 ). Algorithm 20 ML-KEM.Encaps(ek) Uses the encapsulation key to generate a shared secret key and an associated ciphertext. Checked input: encapsulation key ek âˆˆ ğ”¹384ğ‘˜+32 . Output: shared secret key ğ¾ âˆˆ ğ”¹32 . Output: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ ğ‘¢ğ‘˜+ğ‘‘ ğ‘£). 1: ğ‘š â†$ âˆ’ ğ”¹32 â–· ğ‘š is 32 random bytes (see Section 3.3) 2: if ğ‘š == NULL then 3: return âŠ¥ â–· return an error indication if random bit generation failed 4: end if 5: (ğ¾,ğ‘) â† ML-KEM.Encaps_internal(ek,ğ‘š) â–· run internal encapsulation algorithm 6: return (ğ¾,ğ‘) 7.3 ML-KEM Decapsulation The decapsulation algorithm ML-KEM.Decaps of ML-KEM (Algorithm 21) accepts a decapsulation key and an ML-KEM ciphertext as input, does not use any randomness, and outputs a shared secret. This algorithm requires input checking, as specified below. Decapsulation input check. To check a candidate decapsulation key dk and ciphertext ğ‘, perform the following checks: 1. (Ciphertext type check) If ğ‘ is not a byte array of length 32(ğ‘‘ ğ‘˜ + ğ‘‘ ) for the values of ğ‘‘ , ğ‘¢ ğ‘£ ğ‘¢ ğ‘‘ , and ğ‘˜ specified by the relevant parameter set, then input checking has failed. ğ‘£ 2. (Decapsulation key type check) If dk is not a byte array of length 768ğ‘˜ + 96 for the value of ğ‘˜ specified by the relevant parameter set, then input checking has failed. 3. (Hash check) Perform the computation test â† H(dk[384ğ‘˜ âˆ¶ 768ğ‘˜+32])). (7.2) If test â‰  dk[768ğ‘˜ + 32 âˆ¶ 768ğ‘˜ + 64], then input checking has failed. If all of the above checks pass, then ML-KEM.Decaps can be run with inputs dk âˆ¶= dk and ğ‘ âˆ¶= ğ‘. It is important to note that this checking process does not guarantee that dk is a properly produced output of ML-KEM.KeyGen, nor that ğ‘ is a properly produced output of ML-KEM.Encaps. ML-KEM.Decaps shall not be run with a decapsulation key or a ciphertext unless both have been checked. However, checking of the decapsulation key need not be performed by the decapsulating party, nor with every execution of ML-KEM.Decaps. Instead, assurance that this check has been performed can be acquired through other means (see SP 800-227 ). Ciphertext checking shall be performed with every execution of ML-KEM.Decaps. 37FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Algorithm 21 ML-KEM.Decaps(dk,ğ‘) Uses the decapsulation key to produce a shared secret key from a ciphertext. Checked input: decapsulation key dk âˆˆ ğ”¹768ğ‘˜+96 . Checked input: ciphertext ğ‘ âˆˆ ğ”¹32(ğ‘‘ ğ‘¢ğ‘˜+ğ‘‘ ğ‘£). Output: shared secret key ğ¾ âˆˆ ğ”¹32 . 1: ğ¾â€² â† ML-KEM.Decaps_internal(dk,ğ‘) â–· run internal decapsulation algorithm 2: return ğ¾â€² 38FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM 8. Parameter Sets ML-KEM is equipped with three parameter sets, each of the which comprises five individual parameters: ğ‘˜, ğœ‚ , ğœ‚ , ğ‘‘ , and ğ‘‘ . There are also two constants: ğ‘› = 256 and ğ‘ = 3329. The 1 2 ğ‘¢ ğ‘£ following is a brief and informal description of the roles played by the variable parameters in the algorithms of K-PKE and ML-KEM. See Section 5 for details. â€¢ The parameter ğ‘˜ determines the dimensions of the matrix ğ€Ì‚ that appears in K-PKE.KeyGen and K-PKE.Encrypt. It also determines the dimensions of vectors ğ¬ and ğ in K-PKE.KeyGen and the dimensions of vectors ğ² and ğ in K-PKE.Encrypt. 1 â€¢ The parameter ğœ‚ is required to specify the distribution for generating the vectors ğ¬ and ğ 1 in K-PKE.KeyGen and the vector ğ² in K-PKE.Encrypt. â€¢ The parameter ğœ‚ is required to specify the distribution for generating the vectors ğ and 2 1 ğ‘’ in K-PKE.Encrypt. 2 â€¢ The parameters ğ‘‘ and ğ‘‘ serve as parameters and inputs for the functions Compress, ğ‘¢ ğ‘£ Decompress, ByteEncode, and ByteDecode in K-PKE.Encrypt and K-PKE.Decrypt. This standard approves the parameter sets given in Table 2. Each parameter set is associated with a required security strength for randomness generation (see Section 3.3). The sizes of the ML-KEM keys and ciphertexts for each parameter set are summarized in Table 3. Table 2. Approved parameter sets for ML-KEM ğ‘› ğ‘ ğ‘˜ ğœ‚ ğœ‚ ğ‘‘ ğ‘‘ required RBG strength (bits) 1 2 ğ‘¢ ğ‘£ ML-KEM-512 256 3329 2 3 2 10 4 128 ML-KEM-768 256 3329 3 2 2 10 4 192 ML-KEM-1024 256 3329 4 2 2 11 5 256 Table 3. Sizes (in bytes) of keys and ciphertexts of ML-KEM encapsulation key decapsulation key ciphertext shared secret key ML-KEM-512 800 1632 768 32 ML-KEM-768 1184 2400 1088 32 ML-KEM-1024 1568 3168 1568 32 A parameter set name can also be said to denote a (parameter-free) KEM. Specifically, ML-KEM-ğ‘¥ can be used to denote the parameter-free KEM that results from instantiating the scheme ML-KEM with the parameter set ML-KEM-ğ‘¥. The three parameter sets included in Table 2 were designed to meet certain security strength categories defined by NIST in its original Call for Proposals [4, 22]. These security strength categories are explained further in SP 800-57, Part 1 . Using this approach, security strength is not described by a single number, such as â€œ128 bits of security.â€ Instead, each ML-KEM parameter set is claimed to be at least as secure as a generic 39FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM block cipher with a prescribed key size or a generic hash function with a prescribed output length. More precisely, it is claimed that the computational resources needed to break ML-KEM are greater than or equal to the computational resources needed to break the block cipher or hash function when those computational resources are estimated using any realistic model of computation. Different models of computation can be more or less realistic and, accordingly, lead to more or less accurate estimates of security strength. Some commonly studied models are discussed in . Concretely, ML-KEM-512 is claimed to be in security category 1, ML-KEM-768 is claimed to be in security category 3, and ML-KEM-1024 is claimed to be in security category 5. For additional discussion of the security strength of MLWE-based cryptosystems, see . Selecting an appropriate parameter set. When initially establishing cryptographic protections for data, the strongest possible parameter set should be used. This has a number of advantages, including reducing the likelihood of costly transitions to higher-security parameter sets in the future. At the same time, it should be noted that some parameter sets might have adverse performance effects for the relevant application (e.g., the algorithm may be unacceptably slow, or objects such as keys or ciphertexts may be unacceptably large). NIST recommends using ML-KEM-768 as the default parameter set, as it provides a large security margin at a reasonable performance cost. In cases where this is impractical or even higher security is required, other parameter sets may be used. 40FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM References  National Institute of Standards and Technology (2024) Recommendations for key- encapsulation mechanisms, (National Institute of Standards and Technology, Gaithers- burg, MD), NIST Special Publication (SP) 800-227. [Forthcoming; will be available at https://csrc.nist.gov/publications].  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R (2018) Recommendation for pair-wise key-establishment schemes using discrete logarithm cryptography (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56A Revi- sion 3. https://doi.org/10.6028/NIST.SP.800-56Ar3.  Barker EB, Chen L, Roginsky AL, Vassilev A, Davis R, Simon S (2019) Recommendation for pair-wise key-establishment using integer factorization cryptography (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56B Revision 2. https://doi.org/10.6028/NIST.SP.800-56Br2.  Avanzi R, Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G, StehlÃ© D (2020) CRYSTALS-Kyber algorithm specifications and supporting documentation, Third-round submission to the NISTâ€™s post-quantum cryptography standardization process. Available at https://csrc.nist.gov/Projects/post-quantum-cryptography/post-quantum-cry ptography-standardization/round-3-submissions.  National Institute of Standards and Technology (2015) Secure hash standard (SHS), (U.S. Department of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 180-4. https://doi.org/10.6028/NIST.FIPS.180-4.  National Institute of Standards and Technology (2015) SHA-3 standard: Permutation-based hash and extendable-output functions, (U.S. Department of Commerce, Washington, DC), Federal Information Processing Standards Publication (FIPS) 202. https://doi.org/10.6028/ NIST.FIPS.202.  Barker EB (2020) Recommendation for key management: Part 1 -General, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-57 Part 1, Rev. 5 [or as amended]. https://doi.org/10.6028/NIST.SP.800-57pt1r5.  Bos J, Ducas L, Kiltz E, Lepoint T, Lyubashevsky V, Schanck JM, Schwabe P, Seiler G, StehlÃ© D (2018) CRYSTALS-Kyber: A CCA-secure module-lattice-based KEM. 2018 IEEE European Symposium on Security and Privacy (EuroS&P), pp 353â€“367. https://doi.org/10.1109/Euro SP.2018.00032.  Langlois A, StehlÃ© D (2015) Worst-case to average-case reductions for module lattices. Designs, Codes and Cryptography 75(3):565â€“599. https://doi.org/10.1007/s10623-014-9 938-4.  Regev O (2005) On lattices, learning with errors, random linear codes, and cryptography. Proceedings of the Thirty-Seventh Annual ACM Symposium on Theory of Computing STOC â€™05 (Association for Computing Machinery, New York, NY, USA), pp 84â€“â€“93. https://doi.org/ 10.1145/1060590.1060603. 41FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM  Fujisaki E, Okamoto T (2013) Secure integration of asymmetric and symmetric encryption schemes. Journal of Cryptology 26:80â€“101. https://doi.org/10.1007/s00145-011-9114-1.  Hofheinz D, HÃ¶velmanns K, Kiltz E (2017) A modular analysis of the Fujisaki-Okamoto trans- formation. Theory of Cryptography, eds Kalai Y, Reyzin L (Springer International Publishing, Cham), pp 341â€“371. https://doi.org/10.1007/978-3-319-70500-2_12.  Katz J, Lindell Y (2020) Introduction to Modern Cryptography (Chapman & Hall/CRC), 3rd Ed.  Almeida JB, Olmos SA, Barbosa M, Barthe G, Dupressoir F, GrÃ©goire B, Laporte V, LÃ©chenet JC, Low C, Oliveira T, Pacheco H, Quaresma M, Schwabe P, Strub PY (2024) Formally verifying Ky- ber episode V: Machine-checked IND-CCA security and correctness of ML-KEM in EasyCrypt, Cryptology ePrint Archive, Paper 2024/843. Available at https://eprint.iacr.org/2024/843.  Ducas L, Schanck J (2021) Security estimation scripts for Kyber and Dilithium, Github reposi- tory. Available at https://github.com/pq-crystals/security-estimates.  Chen L (2022) Recommendation for key derivation using pseudorandom functions, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-108r1-upd1, Includes updates as of February 2, 2024. https://doi.org/10.6028/NIST.SP. 800-108r1-upd1.  Barker EB, Chen L, Davis R (2020) Recommendation for key-derivation methods in key- establishment schemes (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-56C Revision 2. https://doi.org/10.6028/NIST.SP.800-56C r2.  Barker EB, Kelsey JM (2015) Recommendation for random number generation using deter- ministic random bit generators, (National Institute of Standards and Technology, Gaithers- burg, MD), NIST Special Publication (SP) 800-90A, Rev. 1. https://doi.org/10.6028/NIST.SP. 800-90Ar1.  SÃ¶nmez Turan M, Barker EB, Kelsey JM, McKay KA, Baish ML, Boyle M (2018) Recom- mendation for the entropy sources used for random bit generation, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-90B. https://doi.org/10.6028/NIST.SP.800-90B.  Barker E, Kelsey J, McKay K, Roginsky A, Turan MS (2024) Recommendation for random bit generator (RBG) constructions, (National Institute of Standards and Technology, Gaithers- burg, MD), NIST Special Publication (SP) 800-90C 4pd. https://doi.org/10.6028/NIST.SP.80 0-90C.4pd.  Kelsey J, Chang S, Perlner R (2016) SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash and ParallelHash, (National Institute of Standards and Technology, Gaithersburg, MD), NIST Special Publication (SP) 800-185 [or as amended]. https://doi.org/10.6028/NIST.SP.800-1 85.  National Institute of Standards and Technology (2016) Submission requirements and eval- uation criteria for the post-quantum cryptography standardization process. Available at https://csrc.nist.gov/CSRC/media/Projects/Post-Quantum-Cryptography/documents/call-f or-proposals-final-dec-2016.pdf. 42FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM  Alagic G, Apon D, Cooper D, Dang Q, Dang T, Kelsey J, Lichtinger J, Liu YK, Miller C, Moody D, Peralta R, Perlner R, Robinson A, Smith-Tone D (2022) Status report on the third round of the NIST post-quantum cryptography standardization process (National Institute of Standards and Technology, Gaithersburg, MD), NIST Interagency or Internal Report (IR) 8413. https://doi.org/10.6028/NIST.IR.8413-upd1.  CRYSTALS-Kyber submission team (2023) â€œDiscussion about Kyberâ€™s tweaked FO transformâ€, PQC-Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/W FRDl8DqYQ4.  CRYSTALS-Kyber submission team (2023) â€œKyber decisions, part 2: FO transformâ€, PQC- Forum Post. Available at https://groups.google.com/a/list.nist.gov/g/pqc-forum/c/C0D3W 1KoINY/m/99kIvydoAwAJ. 43FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Appendix A â€” Precomputed Values for the NTT The following 128 numbers are the values of ğœBitRev 7(ğ‘–) mod ğ‘ for ğ‘– âˆˆ {0,â€¦,127}. These numbers are used in Algorithms 9 and 10. { 1 1729 2580 3289 2642 630 1897 848 1062 1919 193 797 2786 3260 569 1746 296 2447 1339 1476 3046 56 2240 1333 1426 2094 535 2882 2393 2879 1974 821 289 331 3253 1756 1197 2304 2277 2055 650 1977 2513 632 2865 33 1320 1915 2319 1435 807 452 1438 2868 1534 2402 2647 2617 1481 648 2474 3110 1227 910 17 2761 583 2649 1637 723 2288 1100 1409 2662 3281 233 756 2156 3015 3050 1703 1651 2789 1789 1847 952 1461 2687 939 2308 2437 2388 733 2337 268 641 1584 2298 2037 3220 375 2549 2090 1645 1063 319 2773 757 2099 561 2466 2594 2804 1092 403 1026 1143 2150 2775 886 1722 1212 1874 1029 2110 2935 885 2154 } 44FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM When implementing Algorithm 11, the values ğœ2BitRev 7(ğ‘–)+1 mod ğ‘ need to be computed. The following array contains these values for ğ‘– âˆˆ {0,â€¦,127}: { 17 -17 2761 -2761 583 -583 2649 -2649 1637 -1637 723 -723 2288 -2288 1100 -1100 1409 -1409 2662 -2662 3281 -3281 233 -233 756 -756 2156 -2156 3015 -3015 3050 -3050 1703 -1703 1651 -1651 2789 -2789 1789 -1789 1847 -1847 952 -952 1461 -1461 2687 -2687 939 -939 2308 -2308 2437 -2437 2388 -2388 733 -733 2337 -2337 268 -268 641 -641 1584 -1584 2298 -2298 2037 -2037 3220 -3220 375 -375 2549 -2549 2090 -2090 1645 -1645 1063 -1063 319 -319 2773 -2773 757 -757 2099 -2099 561 -561 2466 -2466 2594 -2594 2804 -2804 1092 -1092 403 -403 1026 -1026 1143 -1143 2150 -2150 2775 -2775 886 -886 1722 -1722 1212 -1212 1874 -1874 1029 -1029 2110 -2110 2935 -2935 885 -885 2154 -2154 } 45FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Appendix B â€” SampleNTT Loop Bounds In SampleNTT (Algorithm 7), the algorithm repeatedly generates byte arrays from the XOF to create an element of ğ‘‡ . If a generated byte array value is out of bounds for a coefficient of ğ‘‡ , ğ‘ ğ‘ the algorithm tries again until all 256 coefficients are created. On average, this while loop will resolve within a reasonable number of iterations. However, there may be cases in which the generated byte arrays are consistently out of bounds and the algorithm may run for a higher number of iterations. Implementations should not bound this loop, if at all possible. An incorrect limit will cause interoperability errors, and the chances for SampleNTT to iterate longer become exponentially rare. If an implementation does bound the number of iterations of SampleNTT, it shall not use a limit lower than those presented in Table 4. The calculated probability of SampleNTT exceeding the limit is included and calculated under standard assumptions about the output distributions of XOFs and hash functions. Table 4. While-loop limits and probabilities of occurrence for SampleNTT Number of iterations Probability of reaching limit 280 2âˆ’261 If a limit is used and the number of iterations exceeds the limit, then the algorithm shall destroy all intermediate results. If a return value or exception is produced, it shall be the same value for any execution in which the maximum number of iterations is exceeded. 46FIPS 203 MODULE-LATTICE-BASED KEY-ENCAPSULATION MECHANISM Appendix C â€” Differences From the CRYSTALS-Kyber Submission This appendix lists the differences between CRYSTALS-KYBER (as described in ) and the ML-KEM scheme (specified in this document) that result in differing input-output behavior of the main algorithms (i.e., KeyGen, Encaps, Decaps). Since a conforming implementation need only match the input-output behavior of these three algorithms (see â€œImplementationsâ€ and Section 3.3 below), the list does not include any of the numerous differences in how the main algorithms actu- ally produce outputs from inputs (e.g., via different computational steps or different subroutines), nor any differences in presentation between this standard and . C.1 Differences Between CRYSTALS-Kyber and FIPS 203 Initial Pub- lic Draft â€¢ In the third-round specification , the shared secret key was treated as a variable-length value whose length depended on how it would be used in the relevant application. In this specification, the length of the shared secret key is fixed to 256 bits. It can be used directly in applications as a symmetric key, or symmetric keys can be derived from it, as specified in Section 3.3. â€¢ The ML-KEM.Encaps and ML-KEM.Decaps algorithms in this specification use a different variant of the Fujisaki-Okamoto transform (see [24, 25]) than the third-round specifica- tion . Specifically, ML-KEM.Encaps no longer includes a hash of the ciphertext in the derivation of the shared secret, and ML-KEM.Decaps has been adjusted to match this change. â€¢ In the third-round specification , the initial randomness ğ‘š in the ML-KEM.Encaps algo- rithm was first hashed before being used. Specifically, between lines 1 and 2 in Algorithm 20, there was an additional step that performed the operation ğ‘š â† ğ»(ğ‘š). The purpose of this step was to safeguard against the use of flawed randomness generation processes. As this standard requires the use of NIST-approved randomness generation, this step is unnecessary and is not performed in ML-KEM. â€¢ This specification includes explicit input checking steps that were not part of the third-round specification . For example, ML-KEM.Encaps requires that the byte array containing the encapsulation key correctly decodes to an array of integers modulo ğ‘ without any modular reductions. C.2 Changes From FIPS 203 Initial Public Draft The differences between CRYSTALS-KYBER and ML-KEM as described in Appendix C were included in the initial public draft (ipd) of FIPS 203, which was posted on August 24, 2023. Based on comments submitted on the draft ML-KEM, domain separation was added to K-PKE.KeyGen to prevent the misuse of keys generated to target one security level from being used for a different security level when saving a key as a seed. Additionally, FIPS 203 ipd had inadvertently swapped the indices of matrix ğ€Ì‚ in K-PKE.KeyGen and K-PKE.Encrypt. This was changed back in the final version of ML-KEM to match CRYSTALS-KYBER. 47