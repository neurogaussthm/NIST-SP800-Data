NIST Special Publication 800-56A Revision 3 Recommendation for Pair-Wise Key-Establishment Schemes Using Discrete Logarithm Cryptography Elaine Barker Lily Chen Allen Roginsky Apostol Vassilev Richard Davis This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-56Ar3 C O M P U T E R S E C U R I T YNIST Special Publication 800-56A Revision 3 Recommendation for Pair-Wise Key- Establishment Schemes Using Discrete Logarithm Cryptography Elaine Barker Lily Chen Allen Roginsky Apostol Vassilev Computer Security Division Information Technology Laboratory Richard Davis National Security Agency This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-56Ar3 April 2018 U.S. Department of Commerce Wilbur L. Ross, Jr., Secretary National Institute of Standards and Technology Walter Copan, NIST Director and Under Secretary of Commerce for Standards and TechnologyNIST SP 800-56A REV. 3 RECOMMENDATION FOR PAIR-WISE KEY ESTABLISHMENT USING DISCRETE LOGARITHM CRYPTOGRAPHY Authority This publication has been developed by the National Institute of Standards and Technology (NIST) in accordance with its statutory responsibilities under the Federal Information Security Modernization Act (FISMA) of 2014, 44 U.S.C. § 3551 et seq., Public Law (P.L.) 113-283. NIST is responsible for developing information security standards and guidelines, including minimum requirements for federal information systems, but such standards and guidelines shall not apply to national security systems without the express approval of appropriate federal officials exercising policy authority over such systems. This guideline is consistent with the requirements of the Office of Management and Budget (OMB) Circular A-130. Nothing in this publication should be taken to contradict the standards and guidelines made mandatory and binding on federal agencies by the Secretary of Commerce under statutory authority. Nor should these guidelines be interpreted as altering or superseding the existing authorities of the Secretary of Commerce, Director of the OMB, or any other federal official. This publication may be used by nongovernmental organizations on a voluntary basis and is not subject to copyright in the United States. Attribution would, however, be appreciated by NIST. National Institute of Standards and Technology Special Publication 800-56A Revision 3 Natl. Inst. Stand. Technol. Spec. Publ. 800-56A Rev. 3, 151 pages (April 2018) CODEN: NSPUE2 This publication is available free of charge from: https://doi.org/10.6028/NIST.SP.800-56Ar3 Certain commercial entities, equipment, or materials may be identified in this document in order to describe an experimental procedure or concept adequately. Such identification is not intended to imply recommendation or endorsement by NIST, nor is it intended to imply that the entities, materials, or equipment are necessarily the best available for the purpose. There may be references in this publication to other publications currently under development by NIST in accordance with its assigned statutory responsibilities. The information in this publication, including concepts and methodologies, may be used by federal agencies even before the completion of such companion publications. Thus, until each publication is completed, current requirements, guidelines, and procedures, where they exist, remain operative. For planning and transition purposes, federal agencies may wish to closely follow the development of these new publications by NIST. Organizations are encouraged to review all draft publications during public comment periods and provide feedback to NIST. Many NIST cybersecurity publications, other than the ones noted above, are available at https://csrc.nist.gov/publications. Comments on this publication may be submitted to: National Institute of Standards and Technology Attn: Computer Security Division, Information Technology Laboratory 100 Bureau Drive (Mail Stop 8930) Gaithersburg, MD 20899-8930 Email: SP800-56a_comments@nist.gov All comments are subject to release under the Freedom of Information Act (FOIA). iNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Reports on Computer Systems Technology The Information Technology Laboratory (ITL) at the National Institute of Standards and Technology (NIST) promotes the U.S. economy and public welfare by providing technical leadership for the Nation’s measurement and standards infrastructure. ITL develops tests, test methods, reference data, proof of concept implementations, and technical analyses to advance the development and productive use of information technology. ITL’s responsibilities include the development of management, administrative, technical, and physical standards and guidelines for the cost-effective security and privacy of other than national security- related information in Federal information systems. The Special Publication 800-series reports on ITL’s research, guidelines, and outreach efforts in information system security, and its collaborative activities with industry, government, and academic organizations. T h is p Abstract u b lic This Recommendation specifies key-establishment schemes based on the discrete logarithm a tio problem over finite fields and elliptic curves, including several variations of Diffie-Hellman and n is Menezes-Qu-Vanstone (MQV) key establishment schemes. a v a ila b le Keywords fre Diffie-Hellman; elliptic curve cryptography; finite field cryptography; key agreement; key e o confirmation; key derivation; key establishment; MQV. f c h a rg e fro Acknowledgements m : h The authors gratefully acknowledge the contributions on previous versions of this document by ttp Mike Hopper, Don Johnson, Sharon Keller, Laurie Law, and Miles Smid. s ://d o i.o rg Conformance Testing /1 0 .6 Conformance testing for implementations of this Recommendation will be conducted within the 0 2 8 framework of the Cryptographic Algorithm Validation Program (CAVP) and the Cryptographic N/ IS Module Validation Program (CMVP). The requirements of this Recommendation are indicated by T .S the word “shall.” Some of these requirements may be out-of-scope for CAVP or CMVP validation P testing, and thus are the responsibility of entities using, implementing, installing or configuring .8 0 0 applications that incorporate this Recommendation. -5 6 A r3 i iNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Table of Contents 1. Introduction .............................................................................................................. 1 2. Scope and Purpose ................................................................................................. 1 3. Definitions, Symbols and Abbreviations ............................................................... 2 3.1 Definitions........................................................................................................................ 2 3.2 Symbols and Abbreviations ............................................................................................. 9 4. Overview of Key-Establishment Schemes ........................................................... 14 T h is p 4.1 Key Establishment Preparations .................................................................................... 15 u b lic 4.2 Key-Agreement Process ................................................................................................. 17 a tio n is 4.3 DLC-based Key-Transport Process ............................................................................... 19 a v a 5. Cryptographic Elements ....................................................................................... 20 ila b le 5.1 Cryptographic Hash Functions ...................................................................................... 20 fre e o 5.2 Message Authentication Code (MAC) Algorithm ......................................................... 20 f c h a 5.2.1 MAC Tag Computation for Key Confirmation ................................................. 20 rg e fro 5.2.2 MAC Tag Verification for Key Confirmation ................................................... 21 m : h 5.3 Random Number Generation ......................................................................................... 21 ttp s ://d 5.4 Nonce ............................................................................................................................ 21 o i.o 5.5 Domain Parameters ........................................................................................................ 23 rg /1 0 5.5.1 Domain-Parameter Selection/Generation .......................................................... 23 .6 0 2 8 5.5.1.1 FFC Domain Parameter Selection/Generation .................................... 23 N/ IS T 5.5.1.2 ECC Domain-Parameter Selection ..................................................... 24 .S P .8 5.5.2 Assurances of Domain-Parameter Validity ....................................................... 26 0 0 -5 6 5.5.3 Domain Parameter Management ........................................................................ 26 A r3 5.6 Key-Establishment Key Pairs ........................................................................................ 27 5.6.1 Key-Pair Generation .......................................................................................... 27 5.6.1.1 FFC Key-Pair Generation ................................................................... 27 5.6.1.1.1 Using the Approved Safe-Prime Groups ............................. 27 5.6.1.1.2 Using the FIPS 186-Type FFC Parameter-size Sets ............ 27 ii iNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.6.1.1.3 Key-Pair Generation Using Extra Random Bits .................. 27 5.6.1.1.4 Key-Pair Generation by Testing Candidates ........................ 29 5.6.1.2 ECC Key-Pair Generation ................................................................... 30 5.6.1.2.1 Key Pair Generation Using Extra Random Bits .................. 30 5.6.1.2.2 Key Pair Generation by Testing Candidates ........................ 31 5.6.2 Required Assurances .......................................................................................... 32 5.6.2.1 Assurances Required by the Key Pair Owner ..................................... 33 T 5.6.2.1.1 Owner Assurance of Correct Generation ............................. 35 h is p 5.6.2.1.2 Owner Assurance of Private-Key Validity .......................... 35 u b lic a 5.6.2.1.3 Owner Assurance of Public-Key Validity ........................... 36 tio n is 5.6.2.1.4 Owner Assurance of Pair-wise Consistency ........................ 36 a v a ila 5.6.2.1.5 Owner Assurance of Possession of the Private Key ............ 37 b le fre 5.6.2.2 Assurances Required by a Public Key Recipient ................................ 37 e o 5.6.2.2.1 Recipient Assurance of Static Public-Key Validity ............. 39 f c h a rg 5.6.2.2.2 Recipient Assurance of Ephemeral Public-Key Validity ..... 39 e fro 5.6.2.2.3 Recipient Assurance of the Owner’s Possession of a Static m : h Private Key........................................................................... 40 ttp s 5.6.2.2.4 Recipient Assurance of the Owner’s Possession of an ://d o Ephemeral Private Key ........................................................ 42 i.o rg 5.6.2.3 Public Key Validation Routines .......................................................... 43 /1 0 .6 0 5.6.2.3.1 FFC Full Public-Key Validation Routine ............................ 43 2 8 N/ 5.6.2.3.2 FFC Partial Public-Key Validation Routine ........................ 44 IS T .S 5.6.2.3.3 ECC Full Public-Key Validation Routine............................ 44 P .8 0 0 5.6.2.3.4 ECC Partial Public-Key Validation Routine ........................ 45 -5 6 A 5.6.3 Key Pair Management ........................................................................................ 46 r3 5.6.3.1 Common Requirements on Static and Ephemeral Key Pairs .............. 46 5.6.3.2 Specific Requirements on Static Key Pairs ........................................ 46 5.6.3.3 Specific Requirements on Ephemeral Key Pairs ................................ 47 5.7 DLC Primitives .............................................................................................................. 48 5.7.1 Diffie-Hellman Primitives ................................................................................. 48 ivNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.7.1.1 Finite Field Cryptography Diffie-Hellman (FFC DH) Primitive ........ 48 5.7.1.2 Elliptic Curve Cryptography Cofactor Diffie-Hellman (ECC CDH) Primitive .............................................................................................. 49 5.7.2 MQV Primitives ................................................................................................. 50 5.7.2.1 Finite Field Cryptography MQV (FFC MQV) Primitive ................... 50 5.7.2.1.1 MQV2 Form of the FFC MQV Primitive ............................ 51 5.7.2.1.2 MQV1 Form of the FFC MQV Primitive ............................ 51 5.7.2.2 ECC MQV Associate Value Function ................................................ 51 T h is 5.7.2.3 Elliptic Curve Cryptography MQV (ECC MQV) Primitive ............... 52 p u b lic 5.7.2.3.1 Full MQV Form of the ECC MQV Primitive ...................... 52 a tio n 5.7.2.3.2 One-Pass Form of the ECC MQV Primitive........................ 53 is a v 5.8 Key-Derivation Methods for Key-Agreement Schemes ................................................ 53 a ila b le 5.8.1 Performing the Key Derivation .......................................................................... 53 fre e 5.8.2 FixedInfo ............................................................................................................ 54 o f c h 5.8.2.1 One-step Key Derivation .................................................................... 55 a rg e fro 5.8.2.1.1 The Concatenation Format for FixedInfo ............................ 56 m : h 5.8.2.1.2 The ASN.1 Format for FixedInfo ........................................ 57 ttp s 5.8.2.2 Two-step Key-Derivation (Extraction-then-Expansion) ..................... 57 ://d o i.o 5.8.2.3 Other Formats for FixedInfo ............................................................... 57 rg /1 0 5.9 Key Confirmation ........................................................................................................... 58 .6 0 2 5.9.1 Unilateral Key Confirmation for Key-Agreement Schemes .............................. 58 8 N/ IS 5.9.2 Bilateral Key Confirmation for Key-Agreement Schemes ................................ 61 T .S P .8 5.9.3 Selecting the MAC and Other Key-Confirmation Parameters .......................... 62 0 0 -5 6. Key Agreement Schemes ...................................................................................... 64 6 A r3 6.1 Schemes Using Two Ephemeral Key Pairs, C(2e) ........................................................ 66 6.1.1 C(2e, 2s) Schemes .............................................................................................. 67 6.1.1.1 dhHybrid1, C(2e, 2s, FFC DH) Scheme ............................................. 68 6.1.1.2 (Cofactor) Full Unified Model, C(2e, 2s, ECC CDH) Scheme .......... 70 6.1.1.3 MQV2, C(2e, 2s, FFC MQV) Scheme ............................................... 71 vNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.1.1.4 Full MQV, C(2e, 2s, ECC MQV) Scheme ......................................... 73 6.1.1.5 Incorporating Key Confirmation into a C(2e, 2s) Scheme ................. 74 6.1.1.5.1 C(2e, 2s) Scheme with Unilateral Key Confirmation Provided by Party U to Party V ........................................... 75 6.1.1.5.2 C(2e, 2s) Scheme with Unilateral Key Confirmation Provided by Party V to Party U ........................................... 76 6.1.1.5.3 C(2e, 2s) Scheme with Bilateral Key Confirmation ............ 77 6.1.2 C(2e, 0s) Schemes .............................................................................................. 78 T h 6.1.2.1 dhEphem, C(2e, 0s, FFC DH) Scheme ............................................... 79 is p u b 6.1.2.2 (Cofactor) Ephemeral Unified Model, C(2e, 0s, ECC CDH) Scheme 80 lic a tio 6.1.2.3 Key Confirmation for C(2e, 0s) Schemes ........................................... 81 n is a 6.2 Schemes Using One Ephemeral Key Pair, C(1e) Schemes ........................................... 82 v a ila 6.2.1 C(1e, 2s) Schemes .............................................................................................. 82 b le fre 6.2.1.1 dhHybridOneFlow, C(1e, 2s, FFC DH) Scheme ................................ 83 e o f c 6.2.1.2 (Cofactor) One-Pass Unified Model, C(1e, 2s, ECC CDH) Scheme .. 85 h a rg 6.2.1.3 MQV1, C(1e, 2s, FFC MQV) Scheme ............................................... 88 e fro m 6.2.1.4 One-Pass MQV, C(1e, 2s, ECC MQV) Scheme ................................. 90 : h ttp 6.2.1.5 Incorporating Key Confirmation into a C(1e, 2s) Scheme ................. 92 s ://d o 6.2.1.5.1 C(1e, 2s) Scheme with Unilateral Key Confirmation i.o Provided by Party U to Party V ........................................... 92 rg /1 0 .6 6.2.1.5.2 C(1e, 2s) Scheme with Unilateral Key Confirmation 0 2 Provided by Party V to Party U ........................................... 94 8 N/ IS 6.2.1.5.3 C(1e, 2s) Scheme with Bilateral Key Confirmation ............ 95 T .S P 6.2.2 C(1e, 1s) Schemes .............................................................................................. 96 .8 0 0 -5 6.2.2.1 dhOneFlow, C(1e, 1s, FFC DH) Scheme ........................................... 97 6 A r3 6.2.2.2 (Cofactor) One-Pass Diffie-Hellman, C(1e, 1s, ECC CDH) Scheme . 99 6.2.2.3 Incorporating Key Confirmation into a C(1e, 1s) Scheme ............... 101 6.2.2.3.1 C(1e, 1s) Scheme with Unilateral Key Confirmation Provided by Party V to Party U ......................................... 101 6.3 C(0e, 2s) Schemes ........................................................................................................ 102 6.3.1 dhStatic, C(0e, 2s, FFC DH) Scheme .............................................................. 104 v iNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.3.2 (Cofactor) Static Unified Model, C(0e, 2s, ECC CDH) Scheme ..................... 105 6.3.3 Incorporating Key Confirmation into a C(0e, 2s) Scheme .............................. 107 6.3.3.1 C(0e, 2s) Scheme with Unilateral Key Confirmation Provided by Party U to Party V ...................................................................................... 107 6.3.3.2 C(0e, 2s) Scheme with Unilateral Key Confirmation Provided by Party V to Party U ...................................................................................... 109 6.3.3.3 C(0e, 2s) Scheme with Bilateral Key Confirmation ......................... 110 7. Rationale for Selecting a Specific Scheme ........................................................ 112 T h 7.1 Rationale for Choosing a C(2e, 2s) Scheme ................................................................... 113 is p u b 7.2 Rationale for Choosing a C(2e, 0s) Scheme ................................................................... 114 lic a tio 7.3 Rationale for Choosing a C(1e, 2s) Scheme ................................................................... 115 n is a 7.4 Rationale for Choosing a C(1e, 1s) Scheme ................................................................... 116 v a ila 7.5 Rationale for Choosing a C(0e, 2s) Scheme ................................................................... 118 b le fre 7.6 Summary of Assurances Associated with Key-Agreement Schemes ............................. 119 e o f c 8. Key Recovery ....................................................................................................... 122 h a rg 9. Implementation Validation .................................................................................. 123 e fro m Appendix A: References ........................................................................................... 125 : h ttp A.1 Normative References ................................................................................................... 125 s ://d o A.2 Informative References ................................................................................................. 127 i.o rg Appendix B: Rationale for Including Identifiers and other Context-specific /1 0 .6 Information in the KDM Input (Informative) ....................................................... 129 0 2 N8 / Appendix C: Data Conversions (Normative) ........................................................... 130 IS T C.1 Integer-to-Byte String Conversion ............................................................................... 130 .S P .8 C.2 Field-Element-to-Byte String Conversion ................................................................... 130 0 0 -5 6 C.3 Field-Element-to-Integer Conversion .......................................................................... 131 A r3 C.4 Conversion of a Bit String to an Integer ...................................................................... 131 Appendix D: Approved ECC Curves and FFC Safe-prime Groups ....................... 132 Appendix E: Revisions (Informative) ....................................................................... 134 vi iNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography List of Figures Figure 1: Owner key-establishment preparations ..........................................................................17 Figure 2: Key-agreement process. .................................................................................................18 Figure 3: Key-transport process .....................................................................................................66 Figure 4: C(2e, 2s) schemes: each party contributes a static and an ephemeral key pair ..............74 Figure 5: C(2e, 2s) scheme with unilateral key confirmation from party U to party V.................75 Figure 6: C(2e, 2s) scheme with unilateral key confirmation from party V to party U ................76 T Figure 7: C(2e, 2s) scheme with bilateral key confirmation ..........................................................77 h is p Figure 8: C(2e, 0s) schemes: each party contributes only an ephemeral key pair .........................81 u b lic a Figure 9: C(1e, 2s) schemes: party U contributes a static and an ephemeral key pair while party tio n V contributes only a static key pair ................................................................................92 is a v Figure 10: C(1e, 2s) scheme with unilateral key confirmation from party U to party V ...............93 a ila b Figure 11: C(1e, 2s) scheme with unilateral key confirmation from party V to party U ...............94 le fre e Figure 12: C(1e, 2s) scheme with bilateral key confirmation ........................................................95 o f c h Figure 13: C(1e, 1s) schemes: party U contributes an ephemeral key pair, and party V contributes a rg a static key pair .............................................................................................................101 e fro m Figure 14: C(1e, 1s) scheme with unilateral key confirmation from party V to party U .............102 : h ttp Figure 15: C(0e, 2s) schemes: each party contributes only a static key pair ...............................103 s ://d Figure 16: C(0e, 2s) scheme with unilateral key confirmation from party U to party V .............108 o i.o rg Figure 17: C(0e, 2s) scheme with unilateral key confirmation from party V to party U .............109 /1 0 .6 0 2 8 N/ List of Tables IS T .S Table 1: FIPS 186-type FFC parameter-size sets ..........................................................................23 P .8 0 Table 2: Initial assurances required by the key-pair owner ...........................................................34 0 -5 6 Table 3: Optional renewal of assurances by the key-pair owner ...................................................34 A r3 Table 4: Assurances required by a public-key recipient ................................................................38 Table 5: Approved MAC algorithms for key confirmation ...........................................................62 Table 6: Key-agreement scheme categories ..................................................................................64 Table 7: Key-agreement scheme subcategories .............................................................................64 Table 8: Key-agreement schemes ..................................................................................................65 Table 9: dhHybrid1 key-agreement scheme summary ..................................................................69 vi iiNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Table 10: Full unified model key-agreement scheme summary ....................................................71 Table 11: MQV2 key-agreement scheme summary ......................................................................72 Table 12: Full MQV key-agreement scheme summary .................................................................74 Table 13: dhEphem key-agreement scheme summary ..................................................................80 Table 14: Ephemeral unified model key-agreement scheme summary .........................................81 Table 15: dhHybridOneFlow key-agreement scheme summary ...................................................85 Table 16: One-pass unified model key-agreement scheme summary ...........................................87 Table 17: MQV1 key-agreement scheme summary ......................................................................89 T h Table 18: One-pass MQV model key-agreement scheme summary .............................................91 is p u Table 19: dhOneFlow key-agreement scheme summary ...............................................................99 b lic a Table 20: One-pass Diffie-Hellman key-agreement scheme summary .......................................101 tio n is Table 21: dhStatic key-agreement scheme summary ...................................................................105 a v a Table 22: Static unified model key-agreement scheme summary ...............................................107 ila b le Table 23: Summary of assurances ...............................................................................................121 fre e Table 24: Appoved elliptic curves for ECC key-agreement ........................................................132 o f c h Table 25: Approved IKE groups for FFC key agreement ............................................................133 a rg e Table 26: Approved TLS groups for FFC key agreement ..........................................................133 fro m : h ttp s ://d o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 ixNIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. Introduction Many U.S. Government Information Technology (IT) systems need to employ well- established cryptographic schemes to protect the integrity and confidentiality of the data that they process. Algorithms such as the Advanced Encryption Standard (AES) as defined in Federal Information Processing Standard (FIPS) 197,1 and the Keyed-Hash Message Authentication Code (HMAC) as defined in FIPS 1982 make attractive choices for the provision of these services. These algorithms have been standardized to facilitate interoperability between systems. However, the use of these algorithms requires the establishment of keying material between the participating entities in advance. Trusted couriers may manually distribute this secret keying material. However, as the number of T entities using a system grows, the work involved in the distribution of the secret keying h is material could grow rapidly. Therefore, it is essential to support the cryptographic algorithms p u b used in modern U.S. Government applications with automated key-establishment schemes. lic a tio A key-establishment scheme can be characterized as either a key-agreement scheme or a key- n is transport scheme. The asymmetric-key-based key-agreement schemes in this a Recommendation are based on the Diffie-Hellman (DH) and Menezes-Qu-Vanstone (MQV) v a ila algorithms. Asymmetric-key-based key-establishment schemes using Integer Factorization b le Cryptography are specified in SP 800-56B.3 The selection of schemes specified in this fre Recommendation is based on standards for key-establishment schemes developed by the e o Accredited Standards Committee (ASC) X9, Inc.: ANS X9.42, Agreement of Symmetric Keys f c h using Discrete Logarithm Cryptography, and ANS X9.63, Key Agreement and Key a rg Transport using Elliptic Curve Cryptography. e fro m 2. Scope and Purpose : h ttp s This Recommendation provides the specifications for key-agreement schemes that are ://d appropriate for use by the U.S. Federal Government and is intended for use in conjunction o i.o with NIST Special Publication (SP) SP 800-57.4 This Recommendation (i.e., SP 800-56A) rg /1 and SP 800-57 are intended to provide sufficient information for a vendor to implement 0 .6 secure key establishment using asymmetric algorithms in FIPS 1405-validated modules. 0 2 8 N/ A scheme may be a component of a protocol, which in turn provides additional security IS properties not provided by the scheme when considered by itself. Note that protocols, per se, T .S are not specified in this Recommendation. P .8 0 0 -5 6 A r3 1 FIPS 197, Advanced Encryption Standard (AES). 2 FIPS 198, The Keyed-Hash Message Authentication Code (HMAC). 3 SP 800-56B, Recommendation for Pair-Wise Key-establishment Schemes Using Integer Factorization Cryptography. 4 SP 800-57, Recommendation for Key Management. 5 FIPS 140, Security Requirements for Cryptographic Modules. 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 3. Definitions, Symbols and Abbreviations 3.1 Definitions Algorithm A clearly specified mathematical process for computation; a set of rules that, if followed, will give a prescribed result. Approved FIPS-approved or NIST-Recommended. An algorithm or technique that is either 1) specified in a FIPS or NIST Recommendation, or 2) adopted in a FIPS or NIST Recommendation and specified either (a) in an appendix to the FIPS or NIST Recommendation, or (b) in a document referenced by the FIPS or NIST Recommendation. T h is Assumption Used to indicate the conditions that are required to be true when an p u b approved key-establishment scheme is executed in accordance with lic a this Recommendation. tio n is Assurance of Confidence that an entity possesses a private key corresponding to a a v private-key public key. a ila possession b le fre Assurance of Confidence that either a key or a set of domain parameters is e o validity arithmetically correct. f c h a Big-endian The property of a byte string having its bytes positioned in order of rg e decreasing significance. In particular, the leftmost (first) byte is the fro most significant byte (containing the most significant eight bits of the m : h corresponding bit string) and the rightmost (last) byte is the least ttp significant byte (containing the least significant eight bits of the s ://d corresponding bit string). o i.o rg For the purposes of this Recommendation, it is assumed that the bits /1 within each byte of a big-endian byte string are also positioned in 0 .6 order of decreasing significance (beginning with the most significant 0 2 8 bit in the leftmost position and ending with the least significant bit in N/ IS the rightmost position). T .S P Binding Assurance of the integrity of an asserted relationship between items .8 0 of information that is provided by cryptographic means. Also see 0 -5 Trusted association. 6 A r3 Bit length The length in bits of a bit string. Bit string An ordered sequence of 0’s and 1’s. Also known as a binary string. Byte A bit string consisting of eight bits. Byte string An ordered sequence of bytes. 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Certificate The entity in a Public-Key Infrastructure (PKI) that is responsible for Authority (CA) issuing public key certificates and exacting compliance to a PKI policy. Also known as a Certification Authority. Cofactor The order of the elliptic curve group divided by the (prime) order of the generator point (i.e., the base point) specified in the domain parameters. Confidentiality The property that sensitive information is not disclosed to unauthorized entities. Critical security Security-related information whose disclosure or modification can T parameter (CSP) compromise the security of a cryptographic module. Domain h is p parameters, secret or private keys, shared secrets, key-derivation u b keys, intermediate values and secret salts are examples of quantities lic a that may be considered CSPs in this Recommendation. See FIPS 140. tio n is Cryptographic A parameter used with a cryptographic algorithm that determines its a v key (Key) operation. a ila b le Cryptographic The set of hardware, software and/or firmware that implements fre module approved security functions (including cryptographic algorithms and e o key generation). See FIPS 140. f c h a rg Destroy In this Recommendation, an action applied to a key or a piece of secret e fro data. After a key or a piece of secret data is destroyed, no information m about its value can be recovered. Also known as zeroization in FIPS : h 140. ttp s ://d Domain The parameters used with a cryptographic algorithm that are common o i.o parameters to a domain of users. rg /1 0 Entity An individual (person), organization, device, or process. “Party” is a .6 0 synonym. 2 8 N/ IS Ephemeral key A key pair, consisting of a public key (i.e., an ephemeral public key) T .S pair and a private key (i.e., an ephemeral private key) that is intended for P .8 a very short period of use. The key pair is ordinarily used in exactly 0 0 one transaction of a cryptographic scheme. Contrast with a static key -5 6 pair. A r3 Fresh Newly established keying material that is statistically independent of any previously established keying material. Hash function A function that maps a bit string of arbitrary length to a fixed-length bit string. Approved hash functions are expected to satisfy the following properties: 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. One-way: It is computationally infeasible to find any input that maps to any pre-specified output, and 2. Collision resistant: It is computationally infeasible to find any two distinct inputs that map to the same output. Identifier A bit string that is associated with a person, device or organization. It may be an identifying name or may be something more abstract (for example, a string consisting of an IP address). Integrity A property whereby data has not been altered in an unauthorized manner since it was created, transmitted or stored. T h is Key agreement A (pair-wise) key-establishment procedure in which the resultant p u secret keying material is a function of information contributed by both b lic participants so that neither party can predetermine the value of the a tio secret keying material independently from the contributions of the n is other party. Contrast with key-transport. a v a ila Key-agreement An execution of a key-agreement scheme. b le transaction fre e Key confirmation A procedure to provide assurance to one party (the key-confirmation o f c recipient) that another party (the key-confirmation provider) h a rg possesses the correct secret keying material and/or the shared secret e fro from which that keying material is derived. m : h Key-confirmation The party that provides assurance to the other party (the recipient) that ttp provider the two parties have indeed established a shared secret or shared s ://d keying material. o i.o rg Key-derivation As used in this Recommendation, a function used to derive secet /1 function keying material from a shared secret and other information. 0 .6 0 2 As used in this Recommendation, a method used to derive secret 8 Key-derivation N/ keying material from a shared secret and other information. A key- IS method T derivation method may use a key-derivation function or a key- .S P derivation procedure. .8 0 0 -5 Key-derivation As used in this Recommendation, a multi-step process that is used to 6 A procedure derive keying material from a shared secret and other information. r3 Key The procedure that results in secret keying material that is shared establishment among different parties. Key- A private/public key pair that is used in a key-establishment scheme. establishment It can be a static key pair or an ephemeral key pair. key pair 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Key- An instance of establishing secret keying material using a key- establishment agreement or key-transport transaction. transaction Key-transport A (pair-wise) key-establishment procedure whereby one party (the sender) selects a value for the secret keying material and then securely distributes that value to another party (the receiver). Contrast with key agreement. Key-transport An execution of a key-transport scheme. transaction T Key-wrapping A method of protecting keying material (along with associated h is integrity information) that provides both confidentiality and integrity p u protection by using symmetric-key algorithms. b lic a tio Key-wrapping In this Recommendation, a key-wrapping key is a symmetric key n is key established during a key-agreement transaction and used with a key- a v wrapping algorithm to protect the keying material to be transported. a ila b le Key-wrapping An algorithm for protecting keying material that provides both fre algorithm confidentiality and integrity protection using a symmetric key- e o wrapping key. f c h a rg e Key-wrapping A symmetric key used with a key-wrapping algorithm to protect the fro key keying material to be transported. m : h ttp Keying material Data that is represented as a binary string such that any non- s ://d overlapping segments of the string with the required lengths can be o i.o used as secret keys, secret initialization vectors and other secret rg parameters. /1 0 .6 0 2 8 MAC tag Data obtained from the output of a MAC algorithm (possibly by N/ truncation) that can be used by an entity to verify the integrity and the IS T origination of the information used as input to the MAC algorithm. .S P .8 Message A family of cryptographic functions that is parameterized by a 0 0 Authentication symmetric key. Each of the functions can act on input data (called a -5 6 A Code (MAC) “message”) of variable length to produce an output value of a r3 algorithm specified length. The output value is called the MAC of the input message. An approved MAC algorithm is expected to satisfy the following property (for each of its supported security levels): It must be computationally infeasible to determine the (as yet unseen) MAC of a message without knowledge of the key, even if one has already seen the results of using that key to compute the MACs of other (different) messages. 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography A MAC algorithm can be used to provide data-origin authentication and data-integrity protection. In this Recommendation, a MAC algorithm is used for key confirmation; the use of MAC algorithms for key derivation is addressed in SP 800-56C. Nonce A time-varying value that has at most an acceptably small chance of repeating. For example, the nonce may be a random value that is generated anew for each use, a timestamp, a sequence number, or some combination of these. Owner For a static public key, static private key and/ or the static key pair containing those components, the owner is the entity that is authorized T h is to use the static private key corresponding to the static public key, p u whether that entity generated the static key pair itself or a trusted party b lic generated the key pair for the entity. a tio n For an ephemeral public key, ephemeral private key and/or or is a ephemeral public key pair, the owner is the entity that generated the v a ephemeral key pair and is authorized to use the ephemeral private key ila b of the key pair. le fre e o Party See entity. f c h a Prime number An integer that is greater than 1 and divisible only by 1 and itself. rg e fro Primitive A low-level cryptographic algorithm that is used as a basic building m : h block for higher-level cryptographic operations or schemes. ttp s Private key A cryptographic key that is kept secret and is used with a public-key ://d o cryptographic algorithm. A private key is associated with a public i.o rg key. /1 0 .6 Protocol A set of rules used by two or more communicating entities that 0 2 describe the message order and data structures for information 8 N/ exchanged between the entities. IS T .S Provider A party that provides (1) a public key (e.g., in a certificate); (2) P .8 assurance, such as an assurance of the validity of a candidate public 0 0 -5 key or assurance of possession of the private key associated with a 6 A public key; or (3) key confirmation. Contrast with recipient. r3 Public key A cryptographic key that may be made public and is used with a public-key cryptographic algorithm. A public key is associated with a private key. A data structure that contains an entity’s identifier(s), the entity's Public-key public key (including an indication of the associated set of domain certificate parameters) and possibly other information, along with a signature on 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography that data set that is generated by a trusted party, i.e., a certificate authority, thereby binding the public key to the included identifier(s). Public-key The procedure whereby the recipient of a public key checks that the validation key conforms to the arithmetic requirements for such a key in order to thwart certain types of attacks. Random nonce A nonce containing a random-value component that is generated anew for each nonce. Receiver The party that receives secret keying material via a key-transport transaction. Contrast with sender. T h Recipient A party that (1) receives a public key; or (2) obtains assurance from is p an assurance provider (e.g., assurance of the validity of a candidate u b lic public key or assurance of possession of the private key a tio corresponding to a public key); or (3) receives key confirmation from n is a key-confirmation provider. a v a Scheme A set of unambiguously specified transformations that provide a ila b (cryptographic) service when properly implemented and maintained. le fre A scheme is a higher-level construct than a primitive and a lower- e o level construct than a protocol. f c h a Security The security features (e.g., replay protection, or key confirmation) rg e properties that a cryptographic scheme may, or may not, provide. fro m Security strength A number associated with the amount of work (that is, the number of : h ttp (Also, “Bits of operations) that is required to break a cryptographic algorithm or s ://d security”) system. o i.o rg Sender The party that sends secret keying material to the receiver in a key- /1 transport transaction. Contrast with receiver. 0 .6 0 2 8 N/ Shall This term is used to indicate a requirement that needs to be fulfilled IS to claim conformance to this Recommendation. Note that shall may T .S be coupled with not to become shall not. P .8 0 0 Shared secret A secret value that has been computed during a key-establishment -5 6 scheme, is known by both participants, and is used as input to a key- A r3 derivation method to produce keying material. Should This term is used to indicate an important recommendation. Ignoring the recommendation could result in undesirable results. Note that should may be coupled with not to become should not. Static key pair A key pair, consisting of a private key (i.e., a static private key) and a public key (i.e., a static public key) that is intended for use for a relatively long period of time and is typically intended for use in 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography multiple key-establishment transactions. Contrast with an ephemeral key pair. A telecommunications technique in which information is sent to an Store-and- intermediate station where it is kept and later sent to the final forward destination or to another intermediate station. Support (a A security strength of s bits is said to be supported by a particular security strength) choice of algorithm, primitive, auxiliary function, parameters (etc.) for use in the implementation of a cryptographic mechanism if that choice will not prevent the resulting implementation from attaining a T h is security strength of at least s bits. p u b In this Recommendation, it is assumed that implementation choices lic a are intended to support a security strength of 112 bits or more (see SP tio n 800-576 and SP 800-131A7). is a v a ila Symmetric key A cryptographic key that is shared between two or more entities and b le used with a cryptographic application to process information. fre e o Symmetric-key A cryptographic algorithm that uses secret keying material that is f c h algorithm shared between authorized parties. a rg e fro Targeted security The security strength that is intended to be supported by one or more m : h strength implementation-related choices (such as algorithms, primitives, ttp auxiliary functions, parameter sizes and/or actual parameters) for the s ://d purpose of instantiating a cryptographic mechanism. o i.o rg In this Recommendation, it is assumed that the targeted security /1 strength of any instantiation of an approved key-establishment 0 .6 scheme has a value greater than or equal to 112 bits and less than or 0 2 8 equal to 256 bits. N/ IS T Trusted Assurance of the integrity of an asserted relationship between items .S P association of information that may be provided by cryptographic or non- .8 0 cryptographic (e.g., physical) means. Also see Binding. 0 -5 6 A Trusted party A party that is trusted by an entity to faithfully perform certain r3 services for that entity. An entity could be a trusted party for itself. Trusted third A third party, such as a CA, that is trusted by its clients to perform party certain services. (By contrast, the two participants in a key- 6 SP 800-57 Rev. 4, Recommendation for Key Management Part1: General. 7 SP 800-131A, Transitions: Recommendation for Transitioning the Use of Cryptographic Algorithms and Key Lengths. 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography establishment transaction are considered to be the first and second parties.) 3.2 Symbols and Abbreviations General: AES Advanced Encryption Standard (as specified in FIPS 197). AES-CMAC The AES Cipher-based MAC mode (as specified in SP 800-38B8). ASC The American National Standards Institute (ANSI) Accredited Standards Committee. T h is p ANS American National Standard. u b lic ASN.1 Abstract Syntax Notation One. a tio n C(ie) Notation for a category of key-establishment schemes in which i is a ephemeral key pairs are used, where i ∈ {0, 1, 2}. v a ila b le C(ie, js) Notation for a subcategory of key-establishment schemes in which fre i ephemeral key pairs and j static key pairs are used. In this e o Recommendation, schemes in the subcategories C(0e, 2s), C(1e, f c h 2s), C(1e, 1s), C(2e, 0s), and C(2e, 2s) are defined. a rg e CA Certification Authority. fro m : h CDH The cofactor ECC Diffie-Hellman key-agreement primitive. ttp s CSP Critical Security Parameter. ://d o i.o DH The (non-cofactor) FFC Diffie-Hellman key-agreement primitive. rg /1 DLC Discrete Logarithm Cryptography, which is comprised of both 0 .6 0 Finite Field Cryptography (FFC) and Elliptic Curve Cryptography 2 8 (ECC). N/ IS T EC Elliptic Curve. .S P .8 ECC Elliptic Curve Cryptography; the public-key cryptographic 0 0 -5 methods using operations in an elliptic curve group. 6 A r3 FF Finite Field. FFC Finite Field Cryptography; the public-key cryptographic methods using operations in a multiplicative group of a finite field. ID The bit string denoting the identifier associated with an entity. 8 SP 800-38B: Recommendation for Block Cipher Modes of Operation: The CMAC Mode for Authentication. 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography KC Key Confirmation. KDM Key-Derivation Method. KM Keying Material. KMAC The KECCAK-based MAC (as specified in SP 800-1859). len(x) The bit length of the shortest base-two representation of the positive integer x, i.e., len(x) = log (x)+1. 2 MAC Message Authentication Code. MAC(MacKey, A MAC algorithm with MacKey as the key, and MacData as the T h is MacData) data. p u b lic MacOutputBits The length of the MAC ouput block in bits. a tio n MacTag A MAC tag. is a v MacTagBits The length of the MacTag in bits. a ila b MQV The Menezes-Qu-Vanstone key-agreement primitive. le fre e Null The empty bit string o f c h RBG Random Bit Generator. a rg e fro m SHA S 20ec 2u 11r )e . Hash Algorithm (as specified in FIPS 18010 and FIPS : h ttp T bitLen(X) A truncation function that outputs the most significant (i.e., s ://d leftmost) bitLen bits of the input bit string, X, when the bit length o i.o of X is greater than bitLen; otherwise, the function outputs X. For rg /1 example, T 2(1011) = 10, T 3(1011) = 101, T 4(1011) = 1011, and 0 T (1011) = 1011. .6 5 0 2 8 TTP Trusted Third Party. N/ IS T U, V Represents the two parties in a (pair-wise) key-establishment .S P scheme. .8 0 0 -5 6 A r3 9 SP 800-185, SHA-3 Derived Functions: cSHAKE, KMAC, TupleHash, and ParallelHash. 10 FIPS 180, Secure Hash Standard (SHS). 11 FIPS 202, SHA-3 Standard: Permutation-Based Hash and Extendable-Output Functions. 1 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography { } In this Recommendation, the curly braces { } are used in the following three situations: (1) {x} is used to indicate that the inclusion of x is optional; for example, the notation “Input: w {, x}, y, and z” implies that the inclusion of x as an input is optional. (2) If both X and Y are binary strings, the notation of binary string “Y{||X}” implies that the concatenation of string X is optional. (3) {x , x , …, x } indicates a set with elements x , x , …, x . 1 2 k 1 2 k X || Y The concatenation of two bit strings X and Y. For example, 11001 || 010 = 11001010. T [a, b] The set of integers x, such that a ≤ x ≤ b. h is p x The ceiling of x; the smallest integer  x. For example, 5 = 5, u b lic 5.3 = 6. a tio n x The floor of x; the greatest integer that does not exceed x. For is a example, ⌊2.1⌋= 2, and ⌊4⌋= 4. v a ila Z A shared secret (represented as a byte string) that is used to derive b le fre secret keying material using a key-derivation method. e o Z A component of the shared secret (represented as a byte string) that f c e h is computed using ephemeral keys in a Diffie-Hellman primitive. a rg e fro Z s A component of the shared secret (represented as a byte string) that m is computed using static keys in a Diffie-Hellman primitive. : h ttp The following notations are used for FFC and ECC in this Recommendation. Note that the s ://d notation sometimes differs between the two scheme types due to the differing notations used o i.o in the two standards on which this Recommendation is based (i.e., ANS X9.42 and ANS rg /1 X9.63). 0 .6 0 FFC: 2 8 N/ GF(p) The finite field with p elements, where p is an (odd) prime number. The IS T elements of GF(p) can be represented by the set of integers {0, 1, …, p−1}. .S P The addition and multiplication operations for GF(p) can be realized by .8 0 performing the corresponding integer operations and reducing the results 0 -5 modulo p. 6 A r3 GF(p)* The multiplicative group of non-zero field elements in GF(p). g An FFC domain parameter; the selected generator of the multiplicative subgroup of prime order q in GF(p)*. k mod p The modular reduction of the (arbitrary) integer k by the (positive) integer p (the modulus). For the purposes of this Recommendation, j = k mod p is the unique integer satisfying the following two conditions: 0  j < p, and k −j is a multiple of p. In short, j = k – k/pp. 1 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography p An FFC domain parameter; an odd prime number that determines the size of the finite field GF(p). counter An optional FFC domain parameter; a value that may be output during domain parameter generation to provide assurance at a later time that the resulting domain parameters were generated using a canonical process. q When used as an FFC domain parameter, q is the (odd) prime number equal to the order of the multiplicative subgroup of GF(p)* generated by g. Note that q is a divisor of p – 1. r r The ephemeral private keys of party U and party V, respectively. These U, V T h are integers in the interval [1, q − 1]. (In some instances, r U, and/or r V may is be restricted to a subinterval of the form [1, 2N − 1]; see Section 5.6.1.1.1.) p u b lic a t U, t V The ephemeral public keys of party U and party V, respectively. These are tio integers in the interval [2, p − 2]. n is a SEED An FFC domain parameter; an initialization value that is used during v a ila domain parameter generation that can also be used later to provide b le assurance that the resulting domain parameters were generated using an fre approved process. e o f c h x x The static private keys of party U and party V, respectively. These are a U, V rg e fro i rn este trg ie cr ts e din t oth ae si un bte inrv tea rl v [ a1 l, oq f − th 1 e] f. o( rI mn s [o 1m , 2e N i n −s t 1a ]n ; c se es e, Sx U e, c a tin od n/ o 5r . 6x .V 1 m .1a .1y . )b e m : h ttp y U, y V The static public keys of party U and party V, respectively. These are s ://d integers in the interval [2, p − 2]. o i.o rg /1 0 ECC: .6 0 2 a, b ECC domain parameters; two elements in the finite field GF(q) that define 8 N/ the (Weierstrass) equation of an elliptic curve, y2 = x3 + ax + b when q is an IS T odd prime p or y2 + xy = x3 + ax2 + b when q = 2m for some prime integer m. .S P .8 avf(Q) The associate value of the elliptic curve point Q. 0 0 -5 6 A d e,U, d e,V The ephemeral private keys of party U and party V, respectively. These are r3 integers in the interval [1, n − 1]. d , d The static private keys of party U and party V, respectively. These are s,U s,V integers in the interval [1, n − 1]. FR Field Representation indicator (an ECC domain parameter); an indication of the basis used for representing field elements. If a polynomial basis representation is used for a field of order 2m, then FR indicates the reduction polynomial (a trinomial or a pentanomial); otherwise, FR is Null. 1 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography G An ECC domain parameter, which is a distinguished (affine) point in an elliptic curve group that generates a subgroup of prime order n. GF(q) The finite field with q elements, where either q is an odd prime p, or q is equal to 2m for some prime integer m. The elements of GF(q) are represented by the set of integers {0, 1, …, p − 1} in the case that q is an odd prime p, or as bit strings of length m bits in the case that q = 2m. h An ECC domain parameter; the cofactor, a positive integer that is equal to the order of the elliptic curve group, divided by the order of the cyclic subgroup generated by the distinguished point G. That is, nh is the order of the elliptic curve, where n is the order of the cyclic subgroup generated by T h the distinguished point G. is p u n An ECC domain parameter; a prime that is the order of the cyclic subgroup b lic a generated by the distinguished point G. tio n is Ø The (additive) identity element of an elliptic curve group; also called the a v "neutral point" of that group. Ø is the unique element satisfying Q + Ø = a ila Ø + Q = Q for each Q in the group. For the (Weierstrass) elliptic curve b le groups considered in this Recommendation, a special “point at infinity” fre serves as Ø. e o f c q When used as an ECC domain parameter, q is the field size. It is either an h a rg odd prime p, or equal to 2m for some prime integer m. e fro Q , Q The ephemeral public keys of party U and party V, respectively. These are m e,U e,V : h points on the elliptic curve that is defined by the domain parameters. ttp s ://d Q s,U, Q s,V The static public keys of party U and party V, respectively. These are points o on the elliptic curve that is defined by the domain parameters. i.o rg /1 SEED An optional ECC domain parameter; an initialization value that is used 0 .6 during domain parameter generation that can also be used later to provide 0 2 assurance that the resulting domain parameters were generated using an 8 N/ approved process. IS T .S x ,y Elements of the finite field GF(q) representing the x and y coordinates, P P P .8 respectively, of a point P. 0 0 -5 6 A r3 1 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 4. Overview of Key-Establishment Schemes Secret cryptographic keying material may be electronically established between parties by using a key-establishment scheme, that is, by using either a key-agreement scheme or a key- transport scheme. This Recommendation specifies key-agreement schemes; however, Section 4.3 discusses how key transport may be conducted using the keying material derived during a key-agreement transaction. During a pair-wise key-agreement scheme, the secret keying material to be established is not sent directly from one entity to another. Instead, the two parties exchange information from which they each compute a shared secret that is used (along with other exchanged/known data) to derive the secret keying material. The method used to combine the information made T h available to both parties provides assurance that neither party can control the output of the is p key-agreement process. u b lic The key-agreement schemes described in this Recommendation employ public-key a tio techniques utilizing Discrete Logarithm Cryptography (DLC). The security of these DLC- n is based key-agreement schemes depends upon the intractability of the discrete logarithm a v a problem in certain settings. ila b le In this Recommendation, the approved key-agreement schemes are described in terms of fre the roles played by parties “U” and “V.” These are specific labels that are used to distinguish e o between the two participants engaged in key agreement – irrespective of the actual labels f c h that may be used by a protocol employing a given approved key-agreement scheme. a rg e To be in conformance with this Recommendation, a protocol employing any of the approved fro pair-wise key-agreement schemes shall unambiguously assign the roles of party U and party m : h V to the participants by clearly defining which participant performs the actions ascribed by ttp this Recommendation to party U, and which performs the actions ascribed herein to party V. s ://d o This Recommendation specifies several processes that are associated with key establishment i.o rg (including processes for generating domain parameters and for deriving secret keying /1 material from a shared secret). Some of these processes are used to provide assurance (for 0 .6 example, assurance of the arithmetic validity of a public key or assurance of the possession 0 2 8 of a private key associated with a public key). The party that provides the assurance is called N/ IS the “provider” (of the assurance), and the party that obtains the assurance is called the T .S “recipient” (of the assurance). For any of the specified processes, equivalent processes may P .8 be used. Two processes are equivalent if, when the same values are input to each process 0 0 (either as input parameters or as values made available during the process), the same output -5 6 is produced. A r3 The security of a key-establishment scheme depends on its implementation, and this document includes several practical recommendations for implementers. For example, good security practice dictates that implementations of procedures employed by primitives, operations, schemes, etc. include steps that destroy any potentially sensitive locally stored data that is created (and/or copied for use) during the execution of a given procedure, and whose continued local storage is not required after the procedure has been exited. The destruction of such locally stored data ideally occurs prior to or during any exit from the procedure. This is intended to limit opportunities for unauthorized access to sensitive 1 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography information that might compromise a key-establishment process and to prevent its use for any other purpose. Explicit instructions for the destruction of certain potentially sensitive values that are likely to be locally stored by procedures are included in the specifications found in this Recommendation. Examples of such values include local copies of any portions of secret or private keys that are employed or generated during the execution of a procedure, intermediate results produced during computations, and locally stored duplicates of values that are ultimately output by a procedure. However, it is not possible to anticipate the form of all possible implementations of the specified primitives, operations, schemes, etc., making it impossible to enumerate all potentially sensitive data that might be locally stored by a procedure employed in a given implementation. Nevertheless, the destruction of any T h potentially sensitive locally stored data is an obligation of all implementations. is p u Sections 4.1 and 4.2 describe the various steps that may be performed to establish secret b lic keying material during key agreement. a tio n is 4.1 Key Establishment Preparations a v a The owner of a private/public key pair is the entity that is authorized to use the private key ila b of that key pair. The precise steps required may depend upon the key-establishment scheme le fre and the type of key pair (static or ephemeral). e o The first step is to obtain appropriate domain parameters, as specified in Section 5.5.1 from f c h an approved list (see Appendix D) or (in the FFC case) generated as specified in Section 5.5 a rg by a trusted party. These parameters will determine the type of arithmetic used to generate e fro key pairs and compute shared secrets. The owner must have assurance of the validity of these m : h domain parameters; approved methods for obtaining this assurance are provided in Section ttp 5.5.2. s ://d If the owner will be using a key-establishment scheme that requires that the owner have a o i.o static key pair, the owner obtains this key pair. Either the owner or a trusted third party rg /1 generates the key pair as specified in Section 5.6.1. If the key pair is generated by a trusted 0 .6 third party, then the key pair shall be transported to the owner in a protected manner 0 2 8 (providing source authentication and integrity protection for the entire key pair, and N/ IS confidentiality protection of (at least) the private key). If the key-establishment scheme T .S requires an ephemeral key pair, the owner generates it (as close to the time of use as possible) P .8 as specified in Section 5.6.1. Before using a static or ephemeral key pair in a key- 0 0 establishment transaction, its owner is required to confirm its validity by obtaining the -5 6 assurances specified in Section 5.6.2.1. A r3 An identifier is used to label the entity that owns a static key pair used in a key-establishment transaction; an identifier may also be used to label the owner of an ephemeral key pair. This label may uniquely distinguish the owner from all other entities, in which case it could rightfully be considered an identity. However, the label may be something less specific – an organization, nickname, etc. – hence, the term identifier is used in this Recommendation, rather than the term identity. For example, an identifier could be “NIST123”, rather than an identifier that names a given person. A key pair’s owner (or an agent trusted to act on the 1 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography owner’s behalf) is responsible for ensuring that an identifier associated with its static public key is appropriate for the applications in which it will be used. For each static key pair, this Recommendation assumes that there is a trusted association between the owner’s identifier(s) and the owner’s static public key. The association may be provided using cryptographic mechanisms or by physical means. The use of cryptographic mechanisms may require the use of a binding authority (i.e., a trusted authority) that binds the information in a manner that can be verified by others; an example of such a trusted authority is a registration authority working with a CA who creates a certificate containing both the static public key and the identifier. The binding authority shall verify the owner’s intent to associate a specific identifier chosen for the owner and the public key; the means for accomplishing this is beyond the scope of this Recommendation. The binding authority T h shall also obtain assurance of the validity of the domain parameters associated with the is p owner’s key pair, the arithmetic validity of the owner’s static public key, and the owner’s u b possession of the static private key corresponding to that static public key (see Section 5.5.2, lic a Section 5.6.2.2.1 [method 1], and Section 5.6.2.2.3, respectively.) tio n is As an alternative to reliance upon a binding authority, trusted associations between a v identifiers and static public keys may be established by the direct exchange of this a ila information between entities using a mutually trusted method (e.g., a trusted courier or a b le face-to-face exchange). In this case, each entity receiving an identifier and the associated fre e static public key shall be responsible for obtaining the same assurances that would have been o f c obtained on their behalf by a binding authority (see the previous paragraph). Entities shall h a also be responsible for maintaining (by cryptographic or other means) the trusted associations rg e between any identifiers and static public keys received through such exchanges. fro m If an entity engaged in a key-establishment transaction owns a static key pair that is employed : h during the transaction, then the identifier used to label that party shall be one that has a ttp s trusted association with the static public key of that key pair. If an entity engaged in a key- ://d o establishment transaction contributes only an ephemeral public key during the transaction, i.o but an identifier is still desired/required for that party, then a non-null identifier shall be rg /1 selected/assigned in accordance with the requirements of the protocol relying upon the 0 .6 transaction. 0 2 8 N/ Figure_1 depicts the steps that may be required of an owner to obtain its key pair(s) in IS T preparation for key establishment. .S P .8 0 0 -5 6 A r3 1 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Obtain domain parameters (5.5.1) Obtain assurance of domain parameter validity (5.5.2) T Generate h is Obtain static key ephemeral key pair p pair (5.6.1) u (5.6.1) b lic a tio Scheme n is Establish trusted dependent a v association with a ila identifiers (4.1) b le fre e o Obtain required f c h assurances (5.6.2) a rg e fro m : h Ready for key establishment ttp s ://d Figure 1: Owner key-establishment preparations o i.o rg /1 4.2 Key-Agreement Process 0 .6 0 A key-agreement process specified in this Recommendation consists of a sequence of 2 8 N/ ordered steps. Figure 2 depicts the steps that may be required of an entity when establishing IS secret keying material with another entity using one of the key-agreement schemes described in T .S this Recommendation. Some discrepancies in the order of the steps may occur, depending P .8 upon the communication protocol in which the key-agreement process is performed. 0 -50 Depending on the key-agreement scheme and the available keys, the party whose actions are 6 A described could be either of the two participants in the key-agreement scheme (i.e., either r3 party U or party V). 1 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Figure 2: Key-agreement process Using Discrete Logarithm Cryptography Receive other Generate a nonce Obtain other party’s party’s ephemeral and/or an ephemeral static public key public key and/or key pair other public data (5.4 & 5.6.1) Obtain required Obtain required Provide ephemeral assurance for other assurance for other public key and/or party’s static public party’s ephemeral other public data to key (5.6.2.2) public key (5.6.2.2) other party T h is p u b lic a tio Generate shared n is secret and derive a keying material v a Complete key ila confirmation (6 & 5.8) b le fre (5.9 & 6) e o f c h a rg Obtain assurance of e fro m p po rs ivse as tesi ko en y o sf : h (5.6.2.2) ttp Destroy shared s ://d o sec pre rit v, ae tp eh ke em ye , ral i.o rg MacKey, etc. /1 0 .6 0 2 8 N/ Key agreement completed IS T .S P Figure 2: Key-agreement process. .8 0 0 Note that some of the actions shown in Figure 2 may be absent from certain schemes. The -5 6 specifications of this Recommendation indicate when an action is required. A r3 If required by the key-agreement scheme, a party generates an ephemeral key pair (in accordance with Section 5.6.1) and provides the ephemeral public key of that key pair to the other entity; the ephemeral private key is not provided to the other party. If required or desired for use in the key-agreement transaction, a party generates a nonce (as specified in Section 5.4) and provides it to the other party. Depending upon the circumstances, additional public information (e.g., a party’s static public key, an identifier, etc.) may be provided to or obtained from the other party. 1 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography If required by the key-agreement scheme, a party that requires the other entity’s static public key acquires that key (as well as the associated identifier) and obtains assurance of its validity. Approved methods for obtaining assurance of the validity of the other entity’s static public key are provided in Section 5.6.2.2.1. Assurance that the other entity is in possession of the corresponding static private key must also be obtained prior to using the derived keying material for purposes beyond those of the key-agreement transaction itself. (Note: this restriction does not prohibit the use of derived keying material for key confirmation performed during the key-agreement transaction.) See Section 5.6.2.2.3 for approved methods for obtaining this assurance. If a party receives an ephemeral public key from the other entity for use in the key-agreement transaction, that party must obtain assurance of its validity. Approved methods for obtaining T h assurance of the validity of the other entity’s ephemeral public key are provided in Section is p 5.6.2.2.2. u b lic If either of the participants in the key-agreement transaction requires evidence that the other a tio participant has computed the same shared secret and/or derived the same secret keying n is material, (unilateral or bilateral) key confirmation may be performed as specified in Section a v 5.9. a ila b le 4.3 DLC-based Key-Transport Process fre e o Key transport is a key-establishment procedure whereby one party (the sender) selects a f c h value for the secret keying material and then securely distributes that value to another party a rg (the receiver). Key transport may be performed using an approved key-wrapping algorithm e fro (see SP 800-38F12) and a key-wrapping key established during the execution of a key- m agreement scheme specified in Section 6. The security properties for this key-establishment : h ttp process depend on the key-agreement scheme, key-wrapping algorithm and communication s ://d protocol used; the roles assumed by the participants during the process; and all other o parameters used. i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 12 SP 800-38F, Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping. 1 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5. Cryptographic Elements This section describes the basic computations that are performed and the assurances that need to be obtained when performing DLC-based key establishment. The schemes described in Section 6 are based upon the correct implementation of these computations and assurances. 5.1 Cryptographic Hash Functions In this Recommendation, cryptographic hash functions may be used in key derivation and in MAC-tag computation during key confirmation. An approved hash function shall be used when a hash function is required. FIPS 180 and FIPS 202 specify approved hash functions. T 5.2 Message Authentication Code (MAC) Algorithm h is p A Message Authentication Code (MAC) algorithm defines a family of cryptographic u b lic functions that is parameterized by a symmetric key. It is computationally infeasible to a tio determine the MAC of a (newly formed) MacData value without knowledge of the MacKey n is value (even if one has seen the MACs corresponding to other MacData values that were a computed using that same MacKey value). v a ila b The input to a MAC algorithm includes a symmetric key, called MacKey and a binary data le fre string called MacData that serves as the “message.” That is, a MAC computation is e represented as MAC(MacKey, MacData). In this Recommendation, a MAC algorithm is used o f c if key confirmation is performed during key establishment (see Section 5.9); a (possibly h a different) MAC algorithm may be used for the required key-derivation process (see Section rg e 5.8 and SP 800-56C). fro m Key confirmation requires the use of an approved MAC algorithm, i.e., HMAC, AES- : h ttp CMAC or KMAC. HMAC is specified in FIPS 198 and requires the use of an approved hash s ://d function. AES-CMAC is specified in SP 800-38B for the AES block cipher algorithm o specified in FIPS 197. KMAC is specified in SP 800-185. i.o rg /1 When used for key confirmation, an entity is required to compute a MAC tag on received or 0 .6 derived data using a MAC algorithm with a MacKey that is derived from a shared secret. The 0 2 MAC tag is sent to the other entity participating in the key-establishment scheme in order to 8 N/ provide assurance that the shared secret or derived keying material was correctly computed. IS T MAC-tag computation and verification are defined in Sections 5.2.1 and 5.2.2. .S P .8 If a MAC algorithm is employed in key derivation, an approved MAC algorithm shall be 0 0 selected and used in accordance with SP 800-56C. -5 6 A r3 5.2.1 MAC Tag Computation for Key Confirmation Key confirmation can be performed as part of a key-agreement scheme. The computation of a MAC tag (denoted MacTag) is represented as follows: MacTag = T [MAC(MacKey, MacData)]. MacTagBits To compute a MacTag: 2 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. The agreed-upon MAC algorithm (see Section 5.2) is used with MacKey to compute the MAC of MacData, where MacKey is a symmetric key, and MacData represents the input “message” data. The minimum length of MacKey is specified in Table 5 of Section 5.9.3. MacKey is obtained from the DerivedKeyingMaterial (when a key-agreement scheme employs key confirmation), as specified in Section 5.9.1. The output of the MAC algorithm is a bit string whose length (in bits) is MacOutputBits. 2. Those bits are input to the truncation function T , which returns the leftmost MacTagBits (i.e., initial) bits of MacTagBits to be used as the value of MacTag. MacTagBits shall T be less than or equal to MacOutputBits. (When MacTagBits equals MacOutputBits, h is p T MacTagBits acts as the identity function.) The minimum value for MacTagBits is 64, as u b specified in Section 5.9.3. lic a tio n 5.2.2 MAC Tag Verification for Key Confirmation is a To verify a received MacTag (i.e., received during key confirmation), a new MAC tag, v a ila MacTag is computed using the values of MacKey, MacTagBits, and MacData possessed by b le the recipient (as specified in Section 5.2.1). MacTag is compared with the received MacTag. fre If their values are equal, then it may be inferred that the same MacKey, MacTagBits, and e o MacData values were used in the two MAC tag computations. f c h a rg 5.3 Random Number Generation e fro Whenever this Recommendation requires the use of a randomly generated value (for m : h example, for obtaining keys or nonces), the values shall be generated using an approved ttp random bit generator that supports the targeted security strength (see the SP 800-9013 series s ://d of publications). o i.o rg 5.4 Nonce /1 0 .6 0 A nonce is a time-varying value that has an acceptably small chance of repeating (where the 2 8 meaning of “acceptably small” may be application specific). In certain schemes specified in N/ IS this Recommendation, a party may be required to provide a (public) nonce that is used for T .S key-agreement and/or key-confirmation purposes. This circumstance arises when a scheme P .8 does not require that a party provide an ephemeral public key to the other party as part of the 0 0 key-establishment process. -5 6 A r3 This Recommendation requires the use of a nonce (supplied by Party U) in the C(0e, 2s) key- agreement schemes specified in Section 6.3. A nonce (supplied by party V) is also required by the C(1e, 2s) and C(0e, 2s) schemes when party V obtains key confirmation from party U 13 SP 800-90A, Recommendation for Random Number Generation Using Deterministic Random Bit Generators; SP800-90B, Recommendation for the Entropy Sources Used for Random Bit Generation; SP 800-90C, Recommendation for Random Bit Generator (RBG) Constructions. 2 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography in conformance with this Recommendation (see Section 6.2.1.5 and Section 6.3.3, respectively). A nonce may be composed of one (or more) of the following components (other components may also be appropriate): 1. A random bit string that is generated anew for each nonce, using an approved random bit generator. A nonce containing a component of this type is called a random nonce. 2. A timestamp of sufficient resolution so that it is different each time it is used. 3. A monotonically increasing sequence number, or T 4. A combination of a timestamp and a monotonically increasing sequence number, h is such that the sequence number is reset when and only when the timestamp changes. p u b (For example, a timestamp may show the date but not the time of day, so a sequence lic a number is appended that will not repeat during a particular day.) tio n is The specified use of a nonce in key-derivation and/or key-confirmation computations does a not provide the same benefits as the use of an ephemeral key pair in a key-agreement scheme. v a ila (For example, party U’s contribution of a public nonce during the execution of a C(0e, 2s) b le scheme does not protect the secrecy of derived keying material against a future compromise fre of party U’s static private key, but the use of an ephemeral key pair by party U during the e o execution of a C(1e, 2s) scheme can provide such protection.) Still, the contribution of an f c h appropriately formed nonce can support some of the security goals (e.g., assurance of the a rg freshness of derived keying material) that might otherwise be supported by the contribution e fro of an ephemeral public key generated (and used) in conformance with this Recommendation. m : h Whenever a nonce is required for key-agreement and/or key-confirmation purposes as ttp specified in this Recommendation, it should be a random nonce containing a random bit s ://d string output from an approved random bit generator, where both the security strength o i.o supported by the instantiation of the random bit generator and the bit length of the random rg /1 bit string are greater than or equal to the targeted security strength of the key-agreement 0 .6 scheme in which the nonce is used; when feasible, the bit length of the random bit 0 2 string should be (at least) twice the targeted security strength. 8 N/ IS For details concerning the security strength supported by an instantiation of a random bit T .S generator, see SP 800-90. P .8 0 As part of the proper implementation of this Recommendation, system users and/or agents 0 -5 trusted to act on their behalf should determine that the components selected for inclusion in 6 A r3 any required nonces meet their security requirements. The application tasked with performing key establishment on behalf of a party should determine whether to proceed with a key-establishment transaction, based upon the perceived adequacy of the method(s) used to form the required nonces. Such knowledge may be explicitly provided to the application in some manner, or may be implicitly provided by the operation of the application itself. 2 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.5 Domain Parameters Discrete Logarithm Cryptography (DLC), which includes Finite Field Cryptography (FFC) and Elliptic Curve Cryptography (ECC), requires that the public and private key pairs be generated with respect to a set of domain parameters. Both parties executing a key-establishment scheme shall have assurance of domain- parameter validity prior to using them (e.g., to generate key pairs). Although domain parameters are public information, they shall be managed so that the correct correspondence between a given key pair and its set of domain parameters is maintained for all parties that use the key pair. Domain parameters may remain fixed for an extended period, and one set of domain parameters may be used with multiple key pairs and with multiple key- T establishment schemes. h is p For this Recommendation, only one set of domain parameters shall be used during any key- u b establishment transaction. That is, when a key-establishment scheme uses both a static key lic a pair and an ephemeral key pair, they shall be generated using the same set of domain tio n parameters. is a v a 5.5.1 Domain-Parameter Selection/Generation ila b le fre 5.5.1.1 FFC Domain Parameter Selection/Generation e o f c If p is a prime number, then GF(p) denotes the finite field with p elements, which can be h a represented by the set of integers {0, 1, …, p − 1}. The addition and multiplication operations rg e for GF(p) can be realized by performing the corresponding integer operations and reducing fro the results modulo p. The multiplicative group of non-zero field elements is denoted by m : h GF(p)*. In this Recommendation, an FFC key-establishment scheme requires the use of ttp public keys that are restricted to a (unique) cyclic subgroup of GF(p)* with prime order q s ://d (where q divides p – 1). If g is a generator of this cyclic subgroup, then its elements can be o i.o represented as {1, g mod p, g2 mod p, …, gq−1 mod p}, and 1 = gq mod p. rg /1 Domain parameters for an FFC scheme are of the form (p, q, g{, SEED, counter}), where p 0 .6 is the (odd) prime field size, q is an (odd) prime divisor of p – 1, and g is a generator of the 0 2 8 cyclic subgroup of GF(p)* of order q. The optional parameters, SEED and counter, are N/ IS described below. T .S P Two classes of domain parameters are approved for FFC key agreement: a class of “safe” .8 0 domain parameters that are associated with approved safe-prime groups, and a class of 0 -5 “FIPS 18614-type” domain parameters that conform to one of the FIPS 186-type parameter- 6 A r3 size sets that are listed in Table 1. The safe-prime groups approved for use by U.S. Government applications are listed in Appendix D. The associated domain parameters have the form (p, q = (p – 1)/2, g = 2) for specific choices of p. (There are no SEED or counter values required for these groups as there are for the FIPS 186-type groups; see below.) Appendix D specifies the security strengths that can be supported by the approved safe-prime groups. 14 FIPS 186, Digital Signature Standard (DSS). 2 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography The generation of FIPS 186-type domain parameters conforming to parameter-size set FB or FC from Table 1 shall be performed as specified in Appendix A of FIPS 186.15 The resulting domain parameters are of the form (p, q, g{, SEED, counter}), where SEED and counter are parameters used in an approved process for generating and validating p, q, and possibly g (depending on the method of generation). The party that generated the domain parameters should retain SEED and counter and make them available upon request for domain- parameter validation. When the targeted security strength for key establishment is greater than 112 bits, an approved safe-prime group capable of supporting that security strength shall be used. When the targeted security strength is 112 bits, an approved safe-prime group should be used. FIPS 186-type domain parameters should only be used for backward compatibility with T h existing applications that cannot be upgraded to use the approved safe-prime groups. is p u b lic FB FC a Table 1: FIPS 186-type FFC parameter-size tio n sets16 is a v Targeted security strength (in bits) 112 112 a ila Bit length of field size p (i.e., len(p)) 2048 2048 b le Bit length of subgroup order q (i.e., len(q)) 224 256 fre e o f c In the binary representation of each of the odd primes p and q, both the leftmost bit and the h a rg rightmost bit shall be a 1 (i.e., no padding is permitted to artificially increase the bit lengths e fro of their representations). m : h The (safe or FIPS 186-type) domain parameters used for FFC key agreement shall be ttp selected in accordance with the targeted security strength of the relying key-establishment s ://d scheme. SP 800-57 provides guidance on determining security strengths that are appropriate o i.o for FFC key agreement. rg /1 0 5.5.1.2 ECC Domain-Parameter Selection .6 0 2 8 For ECC, let GF(q) denote the finite field with q elements, where either q is an odd prime p, N/ IS or q is equal to 2m for some prime integer m. For the purposes of this Recommendation, T .S an elliptic curve defined over GF(q) is assumed to be defined by either an equation of the P .8 form y2 = x3+ax+b (when q = p) or by an equation of the form y2+xy = x3+ax2+b (when q 0 0 = 2m), where a and b are (appropriately chosen) elements of GF(q). In such an equation, the -5 6 indicated arithmetic is performed in GF(q). (See SECG or SP 800-18617 for further A r3 information concerning arithmetic in finite fields.) For the purposes of this Recommendation, 15 Note that the generation of the domain parameters for FFC key establishment is performed using the methods for the generation of DSA domain parameters. 16 An additional parameter-size set (FA) that provides a maximum security strength of 80 bits is no longer approved for use (see SP 800-57 and SP 800-131A). 17 The recommended elliptic curves now listed in FIPS 186 will be moved to SP 800-186. Until SP 800-186 is published, the recommended elliptic curves should be taken from FIPS 186-4. 2 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography an affine point P on the corresponding elliptic curve is one that can be represented as an ordered pair (x , y ) whose coordinates are elements of GF(q) that satisfy the given equation. P P The set of elliptic curve points forms a group, given an appropriate binary operation “+” (elliptic-curve addition, as defined by the well-known secant-and-tangent rules) and the introduction of a special "point at infinity" to serve as “Ø” (the additive identity element). (See SECG or SP 800-186 for the details of elliptic-curve group operations.) As specified in this Recommendation, an ECC key-establishment scheme requires the use of public keys that are affine elliptic-curve points chosen from a specific cyclic subgroup with prime order n. Suppose that the point G is a generator for this cyclic subgroup. If, for each positive integer d, dG denotes G + G +…+ G, T h is p d terms u b lic where “+” is the elliptic-curve addition operation, then the elements of the cyclic subgroup a tio can be represented as {Ø, G, 2G,…, (n – 1)G}. Note that nG = Ø. The full elliptic-curve n is group has order nh, where the integer h is called a cofactor of the cyclic subgroup generated a v by G. a ila b Domain parameters for an ECC scheme have the form (q, FR, a, b{, SEED}, G, n, h). The le fre parameter q is the field size. As noted above, q may be an odd prime p, or q may be equal to e 2m for some prime integer m. The field representation parameter FR is used to provide o f c additional information (as specified in ANS X9.63 or the SECG) concerning the method used h a rg to represent elements of the finite field GF(q). FR is Null if q is equal to an odd prime p. In e fro m t qh i =s c 2a ms ,e , t hth ee e e ll ee mm ee nn tt ss oo ff t Ghe F f (i 2n mi )te a f ri ee ld re a pr re e sr ee np tr ee dse bn yte d b ib t y s t th rie n i gn st e og fe r les n0 g t th hr o mu ,g h w p it h– 1 e. a W chh be in t : h indicating the coefficient (0 or 1) of a specific element of a particular basis for GF(2m) viewed sttp as a vector space over GF(2). FR is Null if q = 2m and the representation of field elements ://d corresponds to a Gaussian normal basis for GF(2m) (as specified in SP 800-186). If q = 2m, o i.o and the representation of field elements corresponds to a polynomial basis (as specified in rg /1 SECG or SP 800-186), then FR specifies the reduction polynomial – either a trinomial or a 0 .6 pentanomial. The parameters a and b are elements of GF(q) that define the equation of an 0 2 N8 / elliptic curve. G = (x G, y G) is an affine point on the elliptic curve determined by a and b that IS is used to generate a cyclic subgroup of prime order n. The parameter h is the cofactor of the T .S cyclic subgroup generated by G. The bit string SEED is an optional parameter used in an P approved process for generating and validating a, b, and possibly G (depending on the .8 0 0 method of generation). -5 6 A The ECC domain parameters for key establishment for U.S. Government applications shall r3 be selected only from the elliptic-curve domain parameters in SP 800-186 that are listed in Appendix D, along with the security strengths that can be supported by each curve. The curves to be used for ECC key agreement shall be selected in accordance with the targeted security strength of the relying key-establishment scheme. SP 800-57 provides guidance on determining the security-strength requirements that are appropriate for ECC key agreement. 2 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.5.2 Assurances of Domain-Parameter Validity Secure key establishment depends on the arithmetic validity of the domain parameters used by the parties. Therefore, each party shall have assurance of the validity of candidate domain parameters before they are used for key establishment. Each party shall obtain assurance that the candidate domain parameters are valid in one of the following ways: 1. The domain parameters correspond to a specifically approved group: a. For FFC: An approved safe-prime group, as listed in Appendix D. b. For ECC: An elliptic-curve group approved for use by the key-establishment schemes specified in this Recommendation, as listed in Appendix D and specified in SP 800-186.18 T h is 2. For FFC domain parameters that conform to a FIPS 186-type parameter-size set (see p u Table 1): b lic a tio a. The party has generated the domain parameters using a method specified in n is Appendix A of FIPS 186 and/or a v b. The party has performed an explicit domain-parameter validation as specified in a ila SP 800-8919,20, using the provided SEED and counter values. b le fre (Method b can be used by the party that generated the FFC domain parameters to e o obtain renewed assurance of their validity, as necessary.) f c h a 3. A trusted third party (for example, a CA) has obtained assurance that the domain rg e parameters are valid in accordance with one of the methods above, and has fro communicated that fact through a trusted channel. m : h As part of the proper implementation of this Recommendation, system users and/or agents ttp s trusted to act on their behalf should determine which of the methods above meet their ://d security requirements. The application tasked with performing key establishment on behalf o i.o of a party should determine whether to proceed with a key-establishment transaction, based rg /1 upon the perceived adequacy of the method(s) used to obtain assurance of domain-parameter 0 .6 validity. Such knowledge may be explicitly provided to the application in some manner, or 0 2 8 may be implicitly provided by the operation of the application itself. N/ IS T .S 5.5.3 Domain Parameter Management P .8 The set of domain parameters used shall be protected against modification or substitution 0 0 until the set is deactivated (if it is no longer needed). Each private/public key pair shall be -5 6 correctly associated with its specific set of domain parameters. A r3 18 SP 800-186, Recommendations for Discrete Logarithm-Based Cryptography Elliptic Curve Domain Parameters. Specified in FIPS 186-4 until SP 800-186 is available. 19 SP 800-89, Recommendation for Obtaining Assurances for Digital Signature Applications. 20 Note that the validation of the FFC domain parameters uses the same methods as are used for the DSA domain parameters. 2 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.6 Key-Establishment Key Pairs This section specifies requirements for the generation of key pairs to be used in key- establishment transactions, provides methods for obtaining assurances that valid key pairs are used during key establishment, and specifies key-management requirements for the static and ephemeral key pairs used in key establishment. 5.6.1 Key-Pair Generation These generation methods assume the use of valid domain parameters (see Section 5.5). Prior to performing key-pair generation with the selected domain parameters, the party generating the key pair shall obtain assurance of domain-parameter validity in accordance with Section 5.5.2. T h is p 5.6.1.1 FFC Key-Pair Generation u b lic a Each FFC static and ephemeral key pair shall be generated using an approved method (see tio Section 5.6.1.1.3 or 5.6.1.1.4) and the selected valid domain parameters (p, q, g{, SEED, n is counter}). a v a ila 5.6.1.1.1 Using the Approved Safe-Prime Groups b le fre When the domain parameters (p, q = (p – 1)/2, g = 2) correspond to an approved safe-prime e group (named in Appendix D), private keys are integers in the the interval [1, q – 1] whose o f c binary representations require no more than N bits, for an appropriate choice of N, and the h a corresponding public keys are in the interval [2, p – 2]. For the key-pair generation methods rg e fro m i sn e cS ue ric tt yio sn trs e n5 g.6 t. h1 . t1 h. a3 t ca an nd b5 e. 6 s. u1 p.1 p. o4 r, t eth de b yv a tl hu ee n o af m t eh de si an fp eu -pt rp imar ea m gre ote ur p ,s as nh da tl hl eb ve at lh ue e l fa or rg te hs et : h input parameter N (the requested maximum bit length of the private key) shall satisfy the ttp s inequalities 2s  N  len(q). The generated key pairs shall be used only for key-agreement ://d purposes (see Section 6 for the approved key-agreement schemes). o i.o rg /1 5.6.1.1.2 Using the FIPS 186-Type FFC Parameter-size Sets 0 .6 When the domain parameters (p, q, g{, SEED, counter}) conform to a FIPS 186-type FFC 0 2 8 parameter-size set (see Table 1), private keys are generated in the interval [1, q – 1], and the N/ IS corresponding public keys are in the interval [2, p – 2]. For the key-pair generation methods T .S in Sections 5.6.1.1.3 and 5.6.1.1.4, the value used for the input parameter N shall be len(q), P .8 i.e., the bit length of the domain parameter q, and the value used for the input parameter s 0 0 shall be 112, which is the security strength that can be supported by the FIPS 186-type FFC -5 6 parameter-size set that was used to generate the domain parameters (see Table 1). The A r3 generated key pairs shall be used only for key-agreement purposes (see Section 6 for the approved key-agreement schemes), with the possible exception discussed in item 5 of Section 5.6.3.2. 5.6.1.1.3 Key-Pair Generation Using Extra Random Bits In this method, 64 more bits are requested from the random bit generator (RBG) than are needed for the private key so that bias produced by the mod function in process step 5 is negligible. 2 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography The following process or its equivalent may be used to generate an FFC key pair. Input: 1. (p, q, g) The FFC domain parameters used by this process. p, q and g shall either be provided as integers during input, or shall be converted to integers prior to use. 2. N The (maximum) bit length of the private key to be generated. 3. s The maximum security strength to be supported by the key pair. Output: 1. status The status returned from the key-pair generation process. The status will indicate SUCCESS or an ERROR. T h is p 2. (x, y) The generated private and public keys. If an error is encountered u b during the generation process, invalid values for x and y should be lic a returned, as represented by Invalid_x and Invalid_y in the following tio n specification; for example, both Invalid_x and Invalid_y could be 0. is a Otherwise, x and y are returned as integers. The generated private key v a x is in the interval [1, min(2N − 1, q − 1)], and the public key y is in the ila b interval [2, p – 2]. le fre Process: e o f c 1. If s is not the maximum security strength that can be supported by (p, q, g), then h a rg return an ERROR indication as the status and (Invalid_x, Invalid_y) as the key e fro pair; then exit the process without performing the remaining steps. m : h 2. If ((N < 2s) or (N > len(q)), then return an ERROR indication as the status and ttp (Invalid_x, Invalid_y) as the key pair; then exit the process without performing s ://d the remaining steps. o i.o 3. Obtain a string of N + 64 returned_bits using an RBG with a security strength of rg /1 s bits or more (see Section 5 in SP 800-13321). If an ERROR indication is 0 .6 returned, then return an ERROR indication as the status and (Invalid_x, 0 2 8 Invalid_y) as the key pair; then exit the process without performing the remaining N/ IS steps. T .S 4. Convert returned_bits to the (non-negative) integer c in the interval P .8 [0, 2(N + 64) – 1] (see Appendix C.4). 0 0 -5 6 5. Set M = min(2N, q), the minimum of 2N and q. A r3 6. Set x = (c mod (M – 1)) + 1. 7. Set y = gx mod p. 8. Return SUCCESS as the status and (x, y) as the key pair. Output: SUCCESS and (x, y), or 21 SP 800-133, Recommendation for Cryptographic Key Generation. 2 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography an ERROR indication and (Invalid_x, Invalid_y). 5.6.1.1.4 Key-Pair Generation by Testing Candidates In this method, a random number is obtained and tested to determine whether it will produce a value for the private key in the correct interval. If the private key would be outside the interval, then another random number is obtained (i.e., the process is iterated until an acceptable value for the private key is obtained). The following process or its equivalent may be used to generate an FFC key pair. Input: 1. (p, q, g) The FFC domain parameters used by for this process. p, q and g shall T either be provided as integers during input, or shall be converted to h is p integers prior to use. u b lic 2. N The (maximum) bit length of the private key to be generated. a tio 3. s The maximum security strength to be supported by the key pair. n is a Output: v a ila 1. status The status returned from the key-pair generation process. The status b le will indicate SUCCESS or an ERROR. fre e 2. (x, y) The generated private and public keys. If an error is encountered o f c during the generation process, invalid values for x and y should be h a returned, as represented by Invalid_x and Invalid_y in the following rg e specification; for example, both Invalid_x and Invalid_y could be 0. fro Otherwise, x and y are returned as integers. The generated private key m : h x is in the interval [1, min(2N − 1, q − 1)], and the public key y is in the ttp interval [2, p – 2]. s ://d o Process: i.o rg 1. If s is not the maximum security strength that can be supported by (p, q, g), then /1 0 return an ERROR indication as the status and (Invalid_x, Invalid_y) as the key .6 0 pair; then exit the process without performing the remaining steps. 2 8 N/ 2. If ((N < 2s) or (N > len(q)), then return an ERROR indication as the status and IS T (Invalid_x, Invalid_y) as the key pair; then exit the process without performing .S P the remaining steps. .8 0 0 3. Obtain a string of N returned_bits using an RBG with a security strength of s bits -5 6 or more (see Section 5 of SP 800-133). If an ERROR indication is returned, then A r3 return an ERROR indication as the status and (Invalid_x, Invalid_y) as the key pair; then exit the process without performing the remaining steps. 4. Convert returned_bits to the (non-negative) integer c in the interval [0, 2N – 1] (see Appendix C.4). 5. Set M = min(2N, q), the minimum of 2N and q. 6. If (c > M – 2), then go to step 3. 7. x = c + 1. 2 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 8. y = gx mod p. 9. Return SUCCESS as the status and (x, y) as the key pair. Output: SUCCESS and (x, y), or an ERROR indication and (Invalid_x, Invalid_y). 5.6.1.2 ECC Key-Pair Generation For the ECC schemes, each static and ephemeral private key d and public key Q shall be generated using an approved method (see Section 5.6.1.2.1 and 5.6.1.2.2) and domain parameters that have been selected in accordance with Section 5.5.1.2. For the key-pair generation methods in Sections 5.6.1.2.1 and 5.6.1.2.2, the value of the input parameter s T h is shall be the maximum security strength that can be supported by the corresponding elliptic- p u curve group, as specified in Appendix D. b lic a Given valid domain parameters, each valid private key d is an integer that is randomly tio n selected in the interval [1, n−1]. Whether static or ephemeral, each valid public key Q is is a related to the corresponding (valid) private key d by the following formula: Q = (x Q, y Q) = v a dG. ila b le fre 5.6.1.2.1 Key Pair Generation Using Extra Random Bits e o In this method, 64 more bits are requested from the RBG than are needed for d so that bias f c produced by the mod function in step 6 is negligible. h a rg e The following process or its equivalent may be used to generate an ECC key pair. fro m Input: : h ttp 1. (q, FR, a, b {, domain_parameter_seed}, G, n, h) s ://d The ECC domain parameters that are used for this process. n is a prime o i.o number, and G is a point on the elliptic curve (with additive order n). rg /1 2. s The maximum security strength to be supported by the key pair. 0 .6 0 2 Output: 8 N/ IS 1. status The status returned from the key-pair generation procedure. The status T .S will indicate SUCCESS or an ERROR. P .8 2. (d, Q) The generated private and public keys. If an error is encountered during 0 0 -5 the generation process, invalid values for d and Q should be returned, as 6 A represented by Invalid_d and Invalid_Q in the following specification; for r3 example, Invalid_d and Invalid_Q could be a point that is not on the elliptic curve defined by the domain parameters. The private key d is an integer in the interval [1, n – 1], and Q is an elliptic curve point. Process: 1. If the domain parameters are not approved, then return an ERROR indication as the status and (Invalid_d, Invalid_Q) as the key pair; then exit the process without performing the remaining steps. 3 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 2. If s is not the maximum security strength that can be supported by the domain parameters, then return an ERROR indication as the status and (Invalid_d, Invalid_Q) as the key pair; then exit the process without performing the remaining steps. 3. L = len(n) + 64. 4. Obtain a string of L returned_bits using an RBG with a security strength of s bits or more (see Section 5 in SP 800-133). If an ERROR indication is returned, then return an ERROR indication as the status and (Invalid_d, Invalid_Q) as the key pair; then exit the process without performing the remaining steps. 5. Convert returned_bits to the (non-negative) integer c in the interval T h [0, 2L – 1] (see Appendix C.4). is p 6. d = (c mod (n – 1)) + 1. u b lic a 7. Q = dG. tio n is 8. Return SUCCESS as the status and (d, Q) as the key pair. a v a Output: SUCCESS and (d, Q), or ila b le an ERROR indication and (Invalid_d, Invalid_Q). fre e o 5.6.1.2.2 Key Pair Generation by Testing Candidates f c h In this method, a random number is obtained and tested to determine whether or not it will a rg produce a value of d in the correct interval. If d would be outside the interval, another random e fro number is obtained (i.e., the process is iterated until an acceptable value of d is obtained). m : h The following process or its equivalent may be used to generate an ECC key pair. ttp s ://d Input: o i.o 1. (q, FR, a, b {, domain_parameter_seed}, G, n, h) rg /1 0 The ECC domain parameters that are used for this process. n is a prime .6 0 number, and G is a point on the elliptic curve (with the additive order n). 2 8 N/ 2. s The maximum security strength to be supported by the key pair. IS T .S Output: P .8 0 1. status The status returned from the key pair generation procedure. The status 0 -5 will indicate SUCCESS or an ERROR. 6 A r3 2. (d, Q) The generated private and public keys. If an error is encountered during the generation process, invalid values for d and Q should be returned, as represented by Invalid_d and Invalid_Q in the following specification; for example, Invalid_d and Invalid_Q could be a point that is not on the elliptic curve defined by the domain parameters. d is an integer in the interval [1, n–1], and Q is an elliptic curve point. 3 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Process: 1. If the domain parameters are not approved, then return an ERROR indication as the status and (Invalid_d, Invalid_Q) as the key pair; then exit the process without performing the remaining steps. 2. If s is not the maximum security strength that can be supported by the domain parameters, then return an ERROR indication as the status and (Invalid_d, Invalid_Q) as the key pair; then exit the process without performing the remaining steps. 3. L = len(n). 4. Obtain a string of L returned_bits using an RBG with a security strength of s bits T h is or more (see Section 5 in SP 800-133). If an ERROR indication is returned, then p return an ERROR indication as the status and (Invalid_d, Invalid_Q) as the key u b lic pair; then exit the process without performing the remaining steps. a tio n 5. Convert returned_bits to the (non-negative) integer c in the interval is a [0, 2L – 1] (see Appendix C.4). v a ila 6. If (c > n – 2), then go to step 4. b le fre 7. d = c + 1. e o 8. Q = dG. f c h a 9. Return SUCCESS as the status and (d, Q) as the key pair. rg e Output: SUCCESS and (d, Q), or fro m an ERROR indication and (Invalid_d, Invalid_Q). : h ttp s 5.6.2 Required Assurances ://d o To explain the assurance requirements associated with key-establishment key pairs, some i.o rg terminology needs to be introduced. The owner of a static key pair is defined as the entity /1 that is authorized to use the private key that corresponds to the public key; this is independent 0 .6 0 of whether or not the owner generated the key pair. The recipient of a static public key is 2 8 defined as the entity that is participating in a key-establishment transaction with the owner N/ IS and obtains the key before or during the current transaction. The owner of an ephemeral T .S public key is the entity that generated the key as part of a key-establishment transaction. The P .8 recipient of an ephemeral public key is the entity that receives that public key during a key- 0 0 establishment transaction with its owner. -5 6 A r3 Secure key establishment depends upon the use of valid key-establishment keys. Prior to obtaining the assurances described in this section, the owner of a key pair and the recipient of the public key of that key pair shall obtain assurance of the validity of the associated domain parameters (see Section 5.5.2). The security of key-agreement schemes also depends on limiting knowledge of the private keys to those who have been authorized to use them (i.e., their respective owners) and to a trusted third party if that party generated them. In addition to preventing unauthorized entities 3 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography from gaining access to private keys, it is also important that owners have access to their private keys. Note that as time passes, an owner may lose possession of the correct value of the private key component of their key pair, either by choice or due to an error; for this reason, current assurance of possession of a static private key can be of value for some applications, and renewing assurance of possession may be necessary. See Section 5.6.2.2.3.2 for techniques that the recipient of a static public key can use to directly obtain more current assurance of the owner’s possession of the corresponding private key. Prior to or during a key-establishment transaction, the participants in the transaction (i.e., parties U and V) shall obtain the appropriate assurances about the key pairs used during that transaction. The types of assurance that may be sought by one or both of the parties (U and/or T h is V) concerning the components of a key pair (i.e., the private key and public key) are p u discussed in Sections 5.6.2.1 and 5.6.2.2. The methods that will be specified to b lic provide/obtain these assurances presuppose the validity of the domain parameters associated a tio with the key pair (see Section 5.5). n is a The following sections include tables that summarize the types of assurance that are required v a by the parties to a key-establishment transaction. Table 2 in Section 5.6.2.1 summarizes ila b assurances that a key-pair owner may want to renew periodically. The shaded table entries le fre indicate a type of key pair (static or ephemeral) and a type of assurance that might be sought e o for such a key pair. The unshaded table entries indicate who can perform the actions f c necessary to obtain the assurance. h a rg e fro 5.6.2.1 Assurances Required by the Key Pair Owner m : h Prior to the use of a static or ephemeral key pair in a key-establishment transaction, the key- ttp pair owner shall confirm the validity of the key pair by obtaining the following assurances: s ://d • Assurance of correct generation – assurance that the key pair was generated as o i.o specified in Section 5.6.1 (see Section 5.6.2.1.1 for the methods for obtaining this rg /1 assurance). 0 .6 0 2 • Assurance of private-key validity – assurance that the private key is an integer in the 8 N/ correct interval, as determined by the domain parameters (see Section 5.6.2.1.2 for IS T the methods for obtaining this assurance). .S P .8 • Assurance of public-key validity – assurance that the public key has the correct 0 0 representation for a non-identity element of the correct cryptographic subgroup, as -5 6 uniquely determined by the domain parameters (see Section 5.6.2.1.3 for the methods A r3 for obtaining this assurance). • Assurance of pair-wise consistency – assurance that the private key and public key have the correct mathematical relationship to each other (see Section 5.6.2.1.4 for the methods for obtaining this assurance). Table 2 indicates the assurances to be obtained by the owner of a key pair for both static and ephemeral keys, identifies who can perform the actions necessary for the owner to obtain 3 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography each assurance, and indicates the sections of this document where further information is provided. Table 2: Initial assurances required by the key-pair owner Types of assurance Key-pair Correct Private-key Public-key Pair-wise type generation validation validation consistency Ownera or Ownerc Ownerd or Ownerf Static TTPb TTPe Ownera Ownerc Ownerd Ownerf T h Ephemeral is p a See Section 5.6.2.1.1, method a. u b b See Section 5.6.2.1.1, method b lic a c See Section 5.6.2.1.2 tio d See Section 5.6.2.1.3, methods a and b. n is e See Section 5.6.2.1.3, method c. a f See Section 5.6.2.1.4. v a ila A static key-pair owner may optionally renew certain assurances regarding its key pair at any b le time. Table 3 indicates which of the assurances obtained by the owner of a static key pair fre can be renewed and indicates the sections of this document where further information is e o provided. Note that for ephemeral key pairs, only initial assurances are required; renewed f c h assurance for ephemeral key pairs is not applicable, since ephemeral key pairs are short- a rg lived. Also, note that assurance of the correct generation of a static key pair is not renewable e fro since, after the fact, it is not feasible to verify that its private component was randomly m selected. : h ttp Table 3: Optional renewal of assurances by the key-pair owner s ://d o Types of assurance i.o rg Key-pair Correct Private-key Public-key Pair-wise /1 type generation validation validation consistency 0 .6 0 Static Infeasible Ownera Ownerb Ownerc 2 8 N/ a. See Section 5.6.2.1.2. IS T b. See Section 5.6.2.1.3. .S c. See Section 5.6.2.1.4. P .8 Note that the methods used to obtain the required assurances are not necessarily independent. 0 -50 For example, the key-pair owner may employ a key-generation routine that is consistent with 6 A the criteria of Section 5.6.1 and also incorporates the actions required to provide (initial) r3 assurance of the validity and consistency of the private and public components of the resulting key pair. As part of the proper implementation of this Recommendation, system users and/or agents trusted to act on their behalf should determine which of the methods above meet their security requirements. The application tasked with performing key establishment on behalf of a party should determine whether to proceed with a key-establishment transaction, based upon the perceived adequacy of the method(s) used to obtain the above assurances. 3 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.6.2.1.1 Owner Assurance of Correct Generation Prior to the use of a key pair in a key-establishment transaction, the owner of a static or ephemeral key-establishment key pair shall obtain an initial assurance that the key pair has been correctly formed (in a manner that is consistent with the criteria of Section 5.6.1) using one of the following methods: a. For both a static and ephemeral key pair: The owner generates the key pair as specified in Section 5.6, or b. For a static key pair (only): A trusted third party (TTP) (trusted by the owner and any recipient of the public key) generates the key pair as specified in Section 5.6.1 and provides it to the owner. Note that, in this case, the TTP needs to be trusted by both T the owner and any public-key recipient to generate the key pair as specified in Section h is 5.6.1 and not to use the owner’s private key to masquerade as the owner. This method p u is not appropriate for ephemeral key pairs, since the owner generates ephemeral keys. b lic a tio 5.6.2.1.2 Owner Assurance of Private-Key Validity n is Prior to the use of a key pair in a key-establishment transaction, the owner of a static or a v ephemeral key-establishment key pair shall obtain an initial assurance that the private key is a ila an integer in the correct interval, which depends on the type of domain parameters that are b le fre used to generate key pairs. e o • When FFC domain parameters (p, q, g{, SEED, counter}) are used that conform to a f c h FIPS 186-type FFC parameter-size set from Table 1, private keys are in the interval a rg [1, q – 1]. e fro • When an approved safe-prime group is used (see Section 5.5.1.1), and the m : h corresponding FFC domain parameters are (p, q = (p – 1)/2, g = 2), the private keys ttp are in the interval [1, M – 1], where M = min(2N, q), and N is the agreed-upon s ://d (maximum) bit length, satisfying 2s  N  len(q), where s is the maximum security o i.o strength that can be supported by the safe-prime group, as specified in Appendix D. rg /1 0 • When an approved elliptic-curve group is used, and the corresponding ECC domain .6 0 parameters are (q, FR, a, b{, SEED}, G, n, h), the private keys are in the interval [1, 2 8 N/ n – 1]. IS T The owner of a static or ephemeral key-establishment key pair shall obtain an initial .S P assurance that the private key is an integer in the correct interval by using one of the .8 0 following methods: 0 -5 6 A a. For both a static and ephemeral key pair: The owner generates the key pair as r3 specified in Section 5.6.1, or b. For a static key pair (only): After receiving a static key pair from a trusted third party (trusted by the owner), the owner performs a separate check to determine that the private key is in the correct interval. (While an entity can accept ownership of a static key pair that was generated by a TTP, an ephemeral key pair shall only be generated by its owner.) 3 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography To renew this assurance for a static key pair (if desired), the owner shall perform a separate check to determine that the private key is in the correct interval as determined by the domain parameters. 5.6.2.1.3 Owner Assurance of Public-Key Validity Prior to a key-establishment transaction, the owner of a key pair shall obtain an initial assurance that the public key has the expected representation for a non-identity element of the correct cryptographic subgroup, as determined by the domain parameters, using one of the following methods: a. For either a static key pair or an ephemeral key pair: The owner generates the key pair as specified in Section 5.6.1 and performs a full public-key validation or an T h equivalent procedure as part of its generation process (see Section 5.6.2.3.1 for FFC, is p and Section 5.6.2.3.3 for ECC); or u b lic b. For either a static key pair or an ephemeral key pair: The owner performs a full a tio public-key validation as a separate process from the key-pair generation process (see n is Sections 5.6.2.3.1 and 5.6.2.3.3) (either the owner or a TTP could have generated a a v static key pair; only the owner can generate an ephemeral key pair); or a ila b c. For a static key pair (only): A trusted third party (TTP) (trusted by the owner) le fre performs a full public-key validation (see Sections 5.6.2.3.1 and 5.6.2.3.3) and e o provides the validation result to the owner. This TTP could, for example, be a binding f c authority (see Section 4.1) and/or a TTP that generated the key pair (see method b in h a rg Section 5.6.2.1.1). In the case of TTP generation, the TTP shall either employ a key- e fro generation routine that performs a full public-key validation (or an equivalent m procedure) as part of its key-pair generation process, or perform a full public-key : h validation as a separate process, following its key-pair generation process. ttp s ://d To renew this assurance for a static public key (if desired), the owner shall perform a o i.o successful full public-key validation (see Section 5.6.2.3.1 for FFC, and Section 5.6.2.3.3 for rg ECC). Note that renewed assurance of validity for an ephemeral public key is not applicable, /1 0 since ephemeral key pairs are short-lived. .6 0 2 8 N/ 5.6.2.1.4 Owner Assurance of Pair-wise Consistency IS T Prior to a key-establishment transaction, the owner of a key pair shall obtain an initial .S P assurance that the private key and public key have the correct mathematical relationship to .8 0 each other by using one of the following methods: 0 -5 6 a. For either a static key pair or an ephemeral key pair: The owner generates the key A r3 pair as specified in Section 5.6.1, or b. For a static key pair (only): Subsequent to the generation of a static key pair by the owner or a trusted third party as specified in Section 5.6.1, the owner performs one of the following consistency tests (as appropriate for the FFC or ECC domain parameters used during the generation process). • For an FFC key pair (x, y): Use the private key, x, along with the generator g and prime modulus p included in the domain parameters associated with the key pair 3 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography to compute gx mod p. Compare the result to the public key, y. If gx mod p is not equal to y, then the pair-wise consistency test fails. • For an ECC key pair (d, Q): Use the private key, d, along with the generator G and other domain parameters associated with the key pair, to compute dG (according to the rules of elliptic-curve arithmetic). Compare the result to the public key, Q. If dG is not equal to Q, then the pair-wise consistency test fails. The static public key shall be successfully recomputed from the private key and the domain parameters to obtain assurance (via method b) that the private and public keys are consistent. If this pair-wise consistency test fails, the tested key pair shall not be used. T To renew assurance of pair-wise consistency for a static key pair (if desired), method b shall h is p be employed by the owner. Note that renewed assurance for ephemeral key pairs is not u b applicable, since ephemeral key pairs are short-lived. lic a tio n 5.6.2.1.5 Owner Assurance of Possession of the Private Key is a Prior to a key-establishment transaction, the owner of a key pair shall obtain an initial v a assurance of possession of the private key using one of the following methods: ila b le a. For either a static key pair or an ephemeral key pair: The owner generates the key pair as fre specified in Section 5.6.1, or e o f c b. For a static key pair (only): When a trusted third party (trusted by the owner) generates a h a rg static key pair and provides it to the owner, the owner performs the appropriate pair-wise e fro consistency test in method b of Section 5.6.2.1.4; if the pair-wise consistency test fails, m the tested key pair shall not be used. : h ttp To renew this assurance for a static private key (if desired), the appropriate pair-wise s ://d consistency tests in method b of Section 5.6.2.1.4 shall be employed by the owner. Note that o i.o renewed assurance of the possession of an ephemeral private key is not applicable, since rg ephemeral key pairs are short-lived. /1 0 .6 0 5.6.2.2 Assurances Required by a Public Key Recipient 2 8 N/ IS To successfully employ any of the schemes specified in this Recommendation, each T participant in a key-establishment transaction must receive at least one public key owned by .S P the other participant. The public key(s) may be received during the transaction (which is .8 0 0 usually the case for an ephemeral public key) or prior to the transaction (as is sometimes the -5 6 case for a static public key). Regardless of the timing, a transaction participant is said to be A r3 acting as a “public-key recipient” when it receives the other participant's public key(s). Note that besides the participants (i.e., party U and party V), a binding authority (e.g., a CA) may be a public key recipient (e.g., when obtaining assurance of possession). Prior to or during a key-establishment transaction, the recipient of a public key shall obtain assurance of public-key validity and/or private-key possession as required below: • Assurance of public-key validity – assurance that the public key of the other party (i.e., the claimed owner of the public key) has the (unique) correct representation for a non-identity element of the correct cryptographic subgroup, as determined by the 3 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography domain parameters. Recipients of static public keys are required to obtain this assurance (see Section 5.6.2.2.1). Recipients of ephemeral public keys are also required to obtain this assurance. • Assurance of private-key possession – assurance that the claimed owner of a public key-establishment key (i.e., the other party) actually has the (correct) private key associated with that public key. Recipients of static public keys are required to obtain this assurance (see Section 5.6.2.2.3). Recipients of ephemeral public keys are encouraged (but not required) to obtain this assurance; (optional) methods for obtaining this assurance are discussed in Section 5.6.2.2.4. Table 4 summarizes the assurances required by a public-key recipient for both the static and ephemeral public keys of the other party, identifying the party that may perform the actions T h is necessary for the recipient to obtain the assurance and indicating the sections in this p u document where further information is provided. b lic a Table 4: Assurances required by a public-key recipient tio n is Type of assurance a v a ila Key-pair Public-key Private-key b le type validation possession fre e o Static Recipienta or TTPb Recipientd or TTPe f c h a rg e Recipientc Not Requiredf fro Ephemeral m : h a See Section 5.6.2.2.1, method 1. ttp b See Section 5.6.2.2.1, method 2. s c See Section 5.6.2.2.2. ://d d. See Section 5.6.2.2.3.2. o i.o e. See Section 5.6.2.2.3.1. rg f However, see Section 5.6.2.2.4. /1 0 .6 As part of the proper implementation of this Recommendation, system users and/or agents 0 2 8 trusted to act on their behalf should determine which of the indicated methods for obtaining N/ IS the required (and/or desired) assurances meet their security requirements. The application T tasked with performing key establishment on behalf of the recipient should determine .S P whether to proceed with a key-establishment transaction, based upon the perceived adequacy .8 0 0 of the method(s) used to obtain the assurances described above. -5 6 A Once the necessary steps have been taken to provide the recipient of a static public key with r3 assurance of its validity, the assurance obtained by the recipient may endure for a protracted period without the need to reconfirm the validity of that public key. The same may be true of assurance provided to the recipient that the owner of the static public key possesses the corresponding static private key. This could be the case, for example, when the source of the assurance is a trusted CA whose (valid) signature on a certificate containing the static public key indicates to the recipient that the arithmetic validity of the static public key has been confirmed by the CA and that the owner’s possession of the corresponding static private key has been established to the CA’s satisfaction. Alternatively, a party could maintain a record 3 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography (i.e., an integrity-protected record) of previously received static public keys whose validity was confirmed and/or whose owners have provided assurance of private-key possession. On the other hand, the recipient of a static public key may choose to obtain renewed assurance of its validity and/or choose to obtain renewed assurance that the owner of the static public key (i.e., the other party) possesses the corresponding static private key. Deciding how often (if at all) to seek renewed assurance is a determination that should be made by the recipient (or an agent trusted to act on the recipient’s behalf), based on the recipient’s security needs. Renewed assurance of the validity of a received ephemeral public key and renewed assurance that the other party is in possession of the corresponding ephemeral private key are not addressed in this Recommendation, since ephemeral key pairs are short-lived. T h is p 5.6.2.2.1 Recipient Assurance of Static Public-Key Validity u b lic The recipient of another party’s static public key shall obtain assurance of the validity of that a tio public key in one or more of the following ways: n is a 1. The recipient performs a successful full public-key validation of the received public key v a (see Sections 5.6.2.3.1 for FFC domain parameters and Section 5.6.2.3.3 for ECC domain ila b parameters). le fre 2. The recipient receives assurance that a trusted third party (trusted by the recipient) has e o performed a successful full public-key validation of the received public key (see Sections f c h 5.6.2.3.1 and 5.6.2.3.3). This TTP could, for example, be a binding authority, such as a a rg CA (see Section 4.1). e fro m 5.6.2.2.2 Recipient Assurance of Ephemeral Public-Key Validity : h ttp The recipient of another party’s ephemeral public key shall obtain assurance of its validity s ://d by using one of the following methods: o i.o rg 1. When an approved FFC safe-prime group or an approved elliptic curve group is /1 0 used by the key-establishment scheme: .6 0 2 8 • The recipient performs a successful partial public-key validation on the received N/ public key (see Section 5.6.2.3.2 for FFC domain parameters and Section IS T .S 5.6.2.3.4 for ECC domain parameters) P .8 (As part of the proper implementation of this Recommendation, system users 0 -50 and/or agents trusted to act on their behalf should determine whether a partial 6 A validation of ephemeral public keys is sufficient to meet their security r3 requirements. If it is determined that partial public-key validation is insufficient, then full public-key validation shall be performed.) • The recipient performs a successful full public-key validation on the received public key (see Section 5.6.2.3.1 for FFC domain parameters and Section 5.6.2.3.3 for ECC domain parameters). 3 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 2. When FIPS 186-type FFC domain parameters are used in the key-establishment scheme: The recipient performs a successful full public-key validation on the received public key (see Section 5.6.2.3.1 for FFC domain parameters). 5.6.2.2.3 Recipient Assurance of the Owner’s Possession of a Static Private Key The recipient of another party’s static public key shall obtain an initial assurance that the other party (i.e., the claimed owner of the public key) possesses the associated private key, either prior to or concurrently with performing a key-agreement transaction with that other party. Assurance of the validity of the corresponding public key shall be obtained prior to obtaining this assurance (unless the assurance of public-key validity and assurance of private- key possession are obtained simultaneously from a trusted third party). T h As part of the proper implementation of this Recommendation, system users and/or agents is p trusted to act on their behalf should determine which of the methods for obtaining assurance u b of possession meet their security requirements. The application tasked with performing key lic a establishment on behalf of a party should determine whether to proceed with a key- tio n establishment transaction, based upon the perceived adequacy of the method(s) used. Such is a knowledge may be explicitly provided to the application in some manner, or may be v a ila implicitly provided by the operation of the application itself. b le A binding authority can be used to bind the key-pair owner’s identifier to his static public fre e key. In this case, at the time of binding an owner’s identifier to his static public key, the o f c binding authority (i.e., a trusted third party, such as a CA) shall obtain assurance that the h a owner is in possession of the correct static private key. This assurance shall either be rg e obtained using one of the methods specified in Section 5.6.2.2.3.2 (e.g., with the binding fro authority acting as the public-key recipient) or (only if using the FIPS 186-type domain m : h parameters or the approved ECC domain parameters) by using an approved alternative (see ttp SP 800-57, Sections 5.2 and 8.1.5.1.1.2). Note that the use of the signature-based s ://d alternative described in SP 800-57 is not approved for the safe-prime domain o i.o parameters. rg /1 Recipients not acting in the role of a binding authority shall obtain this assurance – either 0 .6 through a trusted third party (see Section 5.6.2.2.3.1) or directly from the owner (i.e., the 0 2 8 other party) (see Section 5.6.2.2.3.2) before using the derived keying material for purposes N/ IS beyond those required during the key-agreement transaction itself. If the recipient chooses T .S to obtain this assurance directly from the other party (i.e., the claimed owner of that public P .8 key), then to comply with this Recommendation, the recipient shall use one of the methods 0 0 specified in Section 5.6.2.2.3.2. -5 6 A r3 5.6.2.2.3.1 Recipient Obtains Assurance from a Trusted Third Party The recipient of a static public key may receive assurance that its owner (i.e., the other party in the key-agreement transaction) is in possession of the correct static private key from a trusted third party (trusted by the recipient) either before or during a key-agreement transaction that makes use of that static public key. The methods used by a third party trusted by the recipient to obtain that assurance are beyond the scope of this Recommendation (however, see the discussion in Section 5.6.2.2.3 above). 4 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.6.2.2.3.2 Recipient Obtains Assurance Directly from the Claimed Owner (i.e., the Other Party) When two parties engage in a key-agreement transaction, there is (at least) an implicit claim of ownership made whenever a static public key is provided on behalf of a given party. That party is considered to be a claimed owner of the corresponding static key pair – as opposed to being a true owner – until adequate assurance can be obtained that the party is actually the one authorized to use the static private key. The claimed owner can provide such assurance by demonstrating its knowledge of that private key. If all the following conditions are met during a key-agreement transaction that incorporates key confirmation as specified in this Recommendation, then while establishing keying material, the recipient of a static public key may be able to directly obtain (initial or renewed) T h assurance of the claimed owner’s (i.e., the other party’s) current possession of the is p corresponding static private key: u b lic 1. The recipient of the static public key contributes an ephemeral public key to the key- a tio agreement process, one that is intended to be arithmetically combined with the n is claimed owner’s (i.e., the other party’s) static private key in computations performed a v by the claimed owner. (If an appropriate key-agreement scheme is employed, the a ila claimed owner will be challenged to demonstrate current knowledge of his static b le fre private key by successfully performing those computations during the transaction.) e o 2. The recipient of the static public key is also a key-confirmation recipient, with the f c claimed owner (i.e., other party) serving as the key-confirmation provider. (By h a rg successfully providing key confirmation, the claimed owner can demonstrate e fro ownership of the received static public key and current knowledge of the m corresponding static private key.) : h ttp There are several key-agreement schemes specified in this Recommendation that can be used s ://d while satisfying both of the conditions above. To claim conformance with this o i.o Recommendation, the key-agreement transaction during which the recipient of a static public rg key seeks to obtain assurance of its owner’s current possession of the corresponding static /1 0 private key shall employ one of the following approved key-agreement schemes, .6 0 2 incorporating key confirmation as specified in the indicated sections, with the recipient of that 8 N/ static public key acting as party U and serving as a key-confirmation recipient: IS T .S • dhHybridOneFlow (see Section 6.2.1.1, and either Section 6.2.1.5.2 or Section P .8 6.2.1.5.3), 0 0 -5 • (Cofactor) One-Pass Unified Model (see Section 6.2.1.2, and either Section 6.2.1.5.2 6 A or Section 6.2.1.5.3), r3 • MQV1 (see Sections 6.2.1.3, and either Section 6.2.1.5.2 or Section 6.2.1.5.3), • One-Pass MQV (see Section 6.2.1.4, and either Section 6.2.1.5.2 or Section 6.2.1.5.3), • dhOneFlow (see Sections 6.2.2.1 and 6.2.2.3.1), or • (Cofactor) One-Pass Diffie-Hellman (see Sections 6.2.2.2 and 6.2.2.3.1). 4 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.6.2.2.4 Recipient Assurance of the Owner’s Possession of an Ephemeral Private Key This Recommendation does not require the recipient of an ephemeral public key to obtain assurance of the possession of the corresponding ephemeral private key by its claimed owner (i.e., the other participant in a key-establishment transaction). However, such assurance may be desired by the recipient, insisted upon by the recipient’s organization, and/or required by an application. Assurance of the validity of the ephemeral public key shall be obtained prior to obtaining assurance of possession of the private key. Ephemeral key pairs are generated by their owner when needed, and their private components are destroyed shortly thereafter (see Section 5.6.3.3 for details). Thus, the opportunity for the recipient of an ephemeral public key to obtain assurance that its claimed owner is in T h possession of the corresponding ephemeral private key is limited to the (single) key- is p establishment transaction during which it was received. u b lic If all the following conditions are met during a key-agreement transaction that incorporates a tio key confirmation as specified in this Recommendation, then in the course of establishing n is keying material, the recipient of an ephemeral public key may be able to obtain assurance a v that the other participant (i.e., the claimed owner of that ephemeral public key) is in a ila possession of the corresponding ephemeral private key: b le fre 1. The recipient of the ephemeral public key also receives a static public key that is e o presumed to be owned by the other party and is used in the key-agreement f c transaction. (Therefore, the other party is the claimed owner of both the received h a rg static public key and the received ephemeral public key.) e fro 2. The recipient of the static and ephemeral public keys contributes its own (distinct) m : h ephemeral public key to the key-agreement process, one that is intended to be ttp arithmetically combined with the private key corresponding to the received s ://d ephemeral public key in computations performed by the claimed owner of the o i.o received static and ephemeral public keys. (If an appropriate key-agreement scheme rg is employed, the claimed owner of the received public keys will be challenged to /1 0 demonstrate current knowledge of his ephemeral private key by successfully .6 0 2 performing those computations during the transaction.) 8 N/ IS 3. The recipient of the static and ephemeral public keys is also a key confirmation T .S recipient, with the claimed owner of the received public keys serving as the key- P .8 confirmation provider. (By successfully providing key confirmation, the claimed 0 0 owner of the received public keys can demonstrate that he is the owner of the received -5 6 static public key and that he knows the ephemeral private key corresponding to the A r3 received ephemeral public key.) There are a limited number of key-agreement schemes specified in this Recommendation that can be used while satisfying all three of the conditions above. To claim conformance with this Recommendation, the key-agreement transaction during which the recipient of an ephemeral public key seeks to obtain assurance of the claimed owner’s possession of the corresponding ephemeral private key shall employ one of the following approved key-agreement schemes, incorporating key confirmation as specified in the indicated 4 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography sections, with the recipient of the ephemeral public key serving as a key-confirmation recipient: • dhHybrid1 (see Section 6.1.1.1 and Section 6.1.1.5) or • (Cofactor) Full Unified Model (see Section 6.1.1.2 and Section 6.1.1.5). Note: If key confirmation is provided in both directions in a key-agreement transaction employing one of the schemes above, then each party can obtain assurance of the other party’s possession of their ephemeral private key. 5.6.2.3 Public Key Validation Routines Public-key validation refers to the process of checking the arithmetic properties of a T h is candidate public key. Both full and partial validation routines are provided for public keys p u that are associated with either FFC or ECC domain parameters. Public-key validation does b lic not require knowledge of the associated private key and so may be done at any time by a tio anyone. However, these routines assume a prior validation of the domain parameters n is a v 5.6.2.3.1 FFC Full Public-Key Validation Routine a ila FFC full public-key validation refers to the process of checking the arithmetic properties of b le a candidate FFC public key to ensure that it has the expected representation and is in the fre e correct subgroup of the multiplicative group of the finite field specified by the associated o f c FFC domain parameters. h a rg This routine shall be used when assurance of full public-key validity is required (or desired) e fro for a static or ephemeral FFC public key. m : h Input: ttp 1. (p, q, g{, SEED, counter}): A valid set of FFC domain parameters, and s ://d o 2. y: A candidate FFC public key. i.o rg Process: /1 0 .6 1. Verify that 2  y  p − 2. 0 2 8 N/ Success at this stage ensures that y has the expected representation for a nonzero field IS element (i.e., an integer in the interval [1, p – 1]) and that y is in the proper range for T .S a properly generated public key. P .8 0 0 2. Verify22 that 1 = yq mod p. -5 6 A Success at this stage ensures that y has the correct order and thus, is a non-identity r3 element in the correct subgroup of GF(p)*. Output: If any of the above verifications fail, immediately output an error indicator and exit without further processing. Otherwise, output an indication of successful validation. 22 When the FFC domain parameters correspond to a safe-prime group, 1 = yq mod p if and only if y is a (nonzero) quadratic residue modulo p, which can be verified by computing the value of the Legendre symbol of y with respect to p. 4 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.6.2.3.2 FFC Partial Public-Key Validation Routine FFC partial public-key validation refers to the process of performing only the first step of a full public-key validation, omitting the check that determines whether the candidate FFC public key is in the correct subgroup. This routine shall only be used with ephemeral FFC public keys generated using the approved safe-prime groups when assurance of the partial validity of such keys is to be obtained as specified in Section 5.6.2.2.2. Input: 1. (p, q = (p –1)/2, g = 2) A valid set of "safe" FFC domain parameters corresponding to a safe-prime group (see Section 5.5.1.1), and T h is 2. y: A candidate FFC public key. p u b Process: lic a tio Verify that 2  y  p − 2. n is a Success at this stage ensures that y has the expected representation for a nonzero field v a element (i.e., an integer in the interval [1, p – 1]) and that y is in the proper range for ila b a properly generated public key. le fre e Output: If the above verification fails, output an error indicator. Otherwise, output an o f c indication of successful validation. h a rg e 5.6.2.3.3 ECC Full Public-Key Validation Routine fro ECC full public-key validation refers to the process of checking all the arithmetic properties m : h of a candidate ECC public key to ensure that it has the expected representation for a non- ttp identity element of the correct subgroup of the appropriate elliptic-curve group, as specified s ://d by the associated ECC domain parameters. o i.o rg This routine shall be used when assurance of full public-key validity is required (or desired) /1 for a static or ephemeral ECC public key. 0 .6 0 2 Input: 8 N/ 1. (q, FR, a, b{, SEED}, G, n, h): A valid set of ECC domain parameters, and IS T 2. Q = (x , y ): A candidate ECC public key. .S Q Q P .8 Process: 0 0 -5 1. Verify that Q is not the identity element Ø. 6 A r3 Success at this stage ensures that Q is not the identity element of the elliptic-curve group (which would never be the value of a properly generated public key). 2. Verify that x and y are integers in the interval [0, p − 1] in the case that q is an odd Q Q prime p, or that x and y are bit strings of length m bits in the case that q = 2m. Q Q Success at this stage ensures that each coordinate of the public key has the expected representation for an element in the underlying field, GF(q). 3. Verify that Q is on the curve. In particular, 4 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography • If q is an odd prime p, verify that (y )2= ((x )3 + ax + b) mod p. Q Q Q • If q = 2m, verify that (y )2 + x y = (x )3 + a(x )2 + b in GF(2m), where the Q Q Q Q Q arithmetic is performed as dictated by the field representation parameter FR. Success at this stage ensures that the public key is a point on the correct elliptic curve. 4. Compute nQ (using elliptic curve arithmetic), and verify that nQ = Ø. Success at this stage ensures that the public key has the correct order. Along with the successful verifications in the previous steps, this step ensures that the public key is in the correct elliptic-curve subgroup and is not the identity element. T Output: If any of the above verifications fail, immediately output an error indicator and h is exit without further processing. Otherwise, output an indication of successful validation. p u b lic 5.6.2.3.4 ECC Partial Public-Key Validation Routine a tio ECC partial public-key validation refers to the process of checking some (but not all) of the n is arithmetic properties of a candidate ECC public key to ensure that it has the expected a v a representation for a non-identity element of the correct elliptic-curve group, as specified by ila the associated ECC domain parameters. ECC partial public-key validation omits the b le fre validation of subgroup membership23, and therefore, is usually faster than ECC full public- e key validation. o f c h This routine shall only be used when assurance of partial public-key validity is acceptable a rg for an ephemeral ECC public key. e fro Input: m : h 1. (q, FR, a, b{, SEED}, G, n, h): A valid set of ECC domain parameters, and s ://dttp 2. Q = (x Q, y Q): A candidate ECC public key. o i.o Process: rg /1 1. Verify that Q is not the identity element Ø. 0 .6 0 Success at this stage ensures that Q is not the identity element of the elliptic-curve 2 8 N/ group (which would never be the value of a properly generated public key). IS T .S 2. Verify that x Q and y Q are integers in the interval [0, p − 1] in the case that q is an odd P prime p, or that x and y are bit strings of length m bits in the case that q = 2m. .8 Q Q 0 0 -5 Success at this stage ensures that each coordinate of the public key has the expected 6 A representation for an element in the underlying field, GF(q). r3 3. Verify that Q is on the curve. In particular, • If q is an odd prime p, verify that (y Q) 2 = ((x Q)3 + ax Q + b) mod p. 23 In this Recommendation, co-factor multiplication is included in the ECC primitives for Diffie-Hellman and MQV, which forces the computed group element into the appropriate subgroup. 4 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography • If q = 2m, verify that (y )2 + x y = (x )3 + a(x )2 + b in GF(2m), where the Q Q Q Q Q arithmetic is performed as dictated by the field representation parameter FR. Together with the successful verifications in the previous steps, success at this stage ensures that the public key is a (finite) point on the correct elliptic curve. (Note: Since its order is not verified, there is no check that the public key is in the correct elliptic curve subgroup. The cofactor multiplication employed by the ECC primitives used to compute a shared secret is intended to compensate for this omission.) Output: If any of the above verifications fail, immediately output an error indicator and exit without further processing. Otherwise, output an indication of validation success. T h is p 5.6.3 Key Pair Management u b lic a tio 5.6.3.1 Common Requirements on Static and Ephemeral Key Pairs n is The following are requirements on both static and ephemeral FFC and ECC key pairs: a v a ila 1. Each private/public key pair shall be correctly associated with its corresponding b le specific set of domain parameters. A key pair shall not be used with more than one fre set of domain parameters. e o f c 2. Each key pair shall be generated as specified in Section 5.6.1. h a rg 3. Private keys shall be protected from unauthorized access, disclosure, modification e fro and substitution. m : h 4. Public keys shall be protected from unauthorized modification and substitution. This ttp s is often accomplished for static public keys by using public-key certificates that have ://d been signed by a Certification Authority (CA). Ephemeral public keys may be o i.o protected during communication using digital signatures or other protocol-specific rg /1 methods. 0 .6 0 2 5.6.3.2 Specific Requirements on Static Key Pairs 8 N/ IS The additional specific requirements for static key pairs are as follows: T .S P 1. The owner of a static key pair shall confirm the validity of the key pair by obtaining .8 0 assurance of the correct generation of the key pair, private and public-key validity, 0 -5 and pair-wise consistency. The owner shall know the methods used to provide/obtain 6 A r3 these assurances. See Section 5.6.2.1 for further details. 2. A recipient of a static public key shall be assured of the integrity and correct association of (a) the public key, (b) the set of domain parameters for that key, and (c) an identifier for the entity that owns the key pair (that is, the party with whom the recipient intends to establish secret keying material). This assurance is often provided by verifying a public-key certificate that was signed by a trusted third party (for example, a CA), but may be provided by direct distribution of the keying material 4 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography from the owner, provided that the recipient trusts the owner to do this. See Section 4.1. 3. A recipient of a static public key shall obtain assurance of the validity of the public key. This assurance may be provided, for example, through the use of a public-key certificate if the CA obtains sufficient assurance of public-key validity as part of its certification process. See Section 5.6.2.2.1. 4. A recipient of a static public key shall have assurance of the owner’s possession of the corresponding private key (see Section 5.6.2.2.3). The recipient shall know the method used to provide assurance to the recipient of the owner’s possession of the private key. This assurance may be provided, for example, using a public-key T certificate if the CA obtains sufficient assurance of possession as part of its h is certification process. p u b lic 5. A static key pair may be used in more than one key-establishment scheme. However, a tio one static public/private key pair shall not be used for different purposes (for n is example, a digital-signature key pair is not to be used for key establishment or vice a v versa; key-usage restrictions could be enforced by a CA when generating certificates) a ila with the following possible exception for ECC and FIPS 186-type FFC domain b le parameters: when requesting the (initial) certificate for a public static key- fre establishment key, the key-establishment private key associated with the public key e o may be used to sign the certificate request. See SP 800-57 on Key Usage for further f c h information. A key-establishment key pair generated using safe-prime domain a rg parameters shall not ever be used for the generation of a digital signature. e fro m : h 5.6.3.3 Specific Requirements on Ephemeral Key Pairs ttp s The additional specific requirements on ephemeral key pairs are as follows: ://d o 1. An ephemeral private key shall be used in exactly one key-establishment transaction. i.o rg After its use, an ephemeral private key shall be destroyed as soon as possible. Until /1 0 the private key is destroyed, its confidentiality shall be protected. An ephemeral .6 0 private key shall not be backed up or archived. 2 8 N/ 2. An ephemeral key pair should be generated as close to its time of use as possible. IS T Ideally, an ephemeral key pair is generated just before the ephemeral public key is .S P transmitted. .8 0 0 -5 3. The owner of an ephemeral key pair shall confirm the validity of the key pair by 6 A obtaining assurance of correct generation, private- and public-key validity, and pair- r3 wise consistency. The owner shall know the methods used to provide/obtain these assurances. These assurances can be obtained by the technique used by the owner to generate the ephemeral key pair. See Section 5.6.2.1 for further details. 4. A recipient of an ephemeral public key shall have assurance of the full or partial validity of the public key as specified in Section 5.6.2.2.2. 5. If a recipient of an ephemeral public key requires assurance that the claimed owner of that public key has possession of the corresponding private key, then, to obtain 4 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography that assurance in compliance with this Recommendation, such assurance shall be obtained as specified in Section 5.6.2.2.4. Although other methods are sometimes used to provide such assurance, this Recommendation makes no statement as to their adequacy. 5.7 DLC Primitives A primitive is a relatively simple operation that is defined to facilitate implementation in hardware or in a software subroutine. Each key-establishment scheme shall use exactly one DLC primitive. Each scheme in Section 6 shall use an appropriate primitive from the following list: 1. The FFC DH primitive (see Section 5.7.1.1): This primitive shall be used by the T h is dhHybrid1, dhEphem, dhHybridOneFlow, dhOneFlow and dhStatic schemes, which p are based on finite field cryptography and the Diffie-Hellman algorithm. u b lic a 2. The ECC CDH primitive (called the Modified Diffie-Hellman primitive in ANS tio n X9.63; see Section 5.7.1.2 below): This primitive shall be used by the Full Unified is a Model, Ephemeral Unified Model, One-Pass Unified Model, One-Pass Diffie- v a Hellman and Static Unified Model schemes, which are based on elliptic curve ila b cryptography and the Diffie-Hellman algorithm. le fre e 3. The FFC MQV primitive (see Section 5.7.2.1): This primitive shall be used by the o f c MQV2 and MQV1 schemes, which are based on finite field cryptography and the h a MQV algorithm. rg e fro 4. The ECC MQV primitive (see Section 5.7.2.3): This primitive shall be used by the m Full MQV and One-Pass MQV schemes, which are based on elliptic curve : h ttp cryptography and the MQV algorithm. s ://d The shared secret output from these primitives shall be used as input to a key-derivation o i.o method (see Section 5.8). rg /1 0 .6 5.7.1 Diffie-Hellman Primitives 0 2 8 N/ 5.7.1.1 Finite Field Cryptography Diffie-Hellman (FFC DH) Primitive IS T .S A shared secret Z is computed using the domain parameters (p, q, g{, SEED, counter}), the P .8 other party’s public key and one’s own private key. This primitive is used in Section 6 by 0 0 the dhHybrid1, dhEphem, dhHybridOneFlow, dhOneFlow and dhStatic schemes. Assume -5 6 that the party performing the computation is party A, and the other party is party B. Note that A r3 party A could be either party U or party V. Input: 1. (p, q, g{, SEED, counter}): Domain parameters, 2. x : One’s own private key, and A 3. y : The other party’s public key B . Process: 4 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. z = y x A mod p B . 2. If ((z ≤ 1) OR (z = p – 1)), destroy all intermediate values used in the attempted computation of Z (including z), then output an error indicator, and exit this process without further processing. 3. Else, convert z to Z using the integer-to-byte-string conversion routine defined in Appendix C.1. 4. Destroy the results of all intermediate calculations used in the computation of Z (including z). T 5. Output Z. h is p Output: The shared secret Z or an error indicator. u b lic a tio 5.7.1.2 Elliptic Curve Cryptography Cofactor Diffie-Hellman (ECC CDH) n Primitive is a v A shared secret Z is computed using the domain parameters (q, FR, a, b{, SEED}, G, n, h), a ila the other party’s public key, and one’s own private key. This primitive is used in Section 6 b le by the Full Unified Model, Ephemeral Unified Model, One-Pass Unified Model, One-Pass fre Diffie-Hellman and Static Unified Model schemes. Assume that the party performing the e o computation is party A, and the other party is party B. Note that party A could be either party f c h U or party V. a rg e Input: fro 1. (q, FR, a, b{, SEED}, G, n, h): Domain parameters, m : h 2. d : One’s own private key, and ttp A s ://d 3. Q B : The other party’s public key . o i.o Process: rg /1 0 1. Compute the point P = hd Q . .6 A B 0 2 8 2. If P = Ø, destroy all intermediate values used in the attempted computation of P, then N/ IS output an error indicator, and exit this process without further processing. T .S P 3. Else, set z = x P, where x P is the x-coordinate of P, and convert z to Z, using the field- .8 0 element-to-byte string conversion routine defined in Appendix C.2. 0 -5 6 4. Destroy the results of all intermediate calculations used in the computation of Z A r3 (including P and z). 5. Output Z. Output: The shared secret Z or an error indicator. 4 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.7.2 MQV Primitives 5.7.2.1 Finite Field Cryptography MQV (FFC MQV) Primitive A shared secret Z is computed using the domain parameters (p, q, g{, SEED, pgenCounter}), the other party’s public keys and one’s own public and private keys. Assume that the party performing the computation is party A, and the other party is party B. Note that party A could be either party U or party V. Input: 1. (p, q, g{, SEED, counter}): Domain parameters, 2. x : One’s own static private key, T A h is p 3. y B : The other party’s static public key , u b lic 4. r : One’s own second private key,24 a A tio n 5. t : One’s own second public key, and is A a v a ila 6. t B : The other party’s second public key. b le Process: fre e 1  o 1. w = log q . f c  2 2   h a rg e fro 2. T A =(t Amod2w)+2w. m : h 3. S =(r +T x )modq. ttp A A A A s ://d 4. T =(t mod2w)+2w. o B B i.o rg /1 5. z = ((t (y T B ))S A)mod p. 0 B B .6 0 2 6. If ((z ≤ 1) OR (z = p – 1)), destroy all intermediate values (including T , S , and T ) 8 A A B N/ used in the attempted computation of z, then output an error indicator, and exit this IS T process without further processing. .S P .8 7. Else, convert z to Z using the integer-to-byte-string conversion routine defined in 0 -50 Appendix C.1. 6 A r3 8. Destroy the results of all intermediate calculations used in the computation of Z (including T , S , T , and z). A A B 9. Output Z. Output: The shared secret Z or an error indicator. 24 In the FFC MQV primitive, a second key may be either ephemeral or static, depending on which form of the primitive is being used; see Sections 5.7.2.1.1 and 5.7.2.1.2. 5 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.7.2.1.1 MQV2 Form of the FFC MQV Primitive This form of invoking the FFC MQV primitive is used in Section 6.1.1.3 by the MQV2 scheme. In this form, each party uses both a static key pair and an ephemeral key pair. Assume that the party performing the computation is party A, and the other party is party B. Note that party A could be either party U or party V. In this form, one’s own second private and public keys (items 4 and 5 of the input list in Section 5.7.2.1) are one’s own ephemeral private and public keys (r and t ), and the other A A party’s second public key (item 6 in Section 5.7.2.1) is the other party’s ephemeral public key (t ). B 5.7.2.1.2 MQV1 Form of the FFC MQV Primitive T h This form of invoking the FFC MQV primitive is used in Section 6.2.1.3 by the MQV1 is p scheme. In this form, party U uses a static key pair and an ephemeral key pair, but party V u b lic uses only a static key pair. One-Pass MQV uses the MQV primitive with party V’s static key a tio pair as the second key pair (as party V has no ephemeral key pair). n is Party U uses party V’s static public key for the other party’s second public key; that is, when a v party U uses the algorithm in Section 5.7.2.1, item 6 of the input list is party V’s static public a ila key (y ). b B le fre Party V uses his/her static private key for the second private key; that is, when party V uses e o f c t ih tee m a l 5g o br ei cth om m ein s hS ie sc sti to atn i c5 p.7 u. b2 l. i1 c, kit ee ym ( y4 o ).f the input list is party V’s static private key x A, and h A a rg e fro 5.7.2.2 ECC MQV Associate Value Function m : h The associate value function is used by the ECC MQV family of key-agreement schemes to ttp compute an integer that is associated with an elliptic curve point. This Recommendation s ://d defines avf(Q) to be the associate value function of a public key Q using the domain o parameters (q, FR, a, b{, SEED}, G, n, h). i.o rg /1 Input: 0 .6 1. (q, FR, a, b{, SEED}, G, n, h): Domain parameters, and 0 2 8 2. Q: A public key (that is, Q is a point in the subgroup of order n and not equal to the N/ IS identity element Ø). T .S Process: P .8 0 1. Convert x to an integer xqi using the convention specified in Appendix C.3. 0 Q -5 6 A 2. Calculate r3 xqm= xqimod2f/2 (where f = log n). 2 3. Calculate the associate value function avf(Q) = xqm + 2f/2. (See footnote25). 25 Note that avf(Q) can be computed using only bit operations. 5 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Output: avf(Q), the associate value of Q. 5.7.2.3 Elliptic Curve Cryptography MQV (ECC MQV) Primitive The ECC MQV primitive is computed using the domain parameters (q, FR, a, b{, SEED}, G, n, h), the other party’s public keys, and one’s own public and private keys. Assume that the party performing the computation is party A, and the other party is party B. Note that party A could be either party U or party V. Input: 1. (q, FR, a, b{, SEED}, G, n, h): Domain parameters, 2. d : One’s own static private key, s,A T 3. Q :The other party’s static public key, h s,B is p u 4. d : One’s own second private key,26 b e,A lic a tio 5. Q e,A : One’s own second public key, and n is 6. Q : The other party’s second public key. a e,B v a ila Process: b le 1. implicitsig = (d + avf(Q )d )mod n. fre A e,A e,A s,A e o 2. P = h(implicitsig )(Q + avf(Q )Q ). f c A e,B e,B s,B h a 3. If P = Ø, destroy all intermediate values used in the attempted computation of P, then rg e output an error indicator, and exit this process without further processing. fro m : h 4. Else, set z = x P, where x P is the x-coordinate of P, and convert z to Z, using the field- ttp element-to-byte string conversion routine defined in Appendix C.2. s ://d 5. Destroy the results of all intermediate calculations used in the computation of Z o i.o (including P and z). rg /1 0 6. Output Z. .6 0 2 8 Output: The shared secret Z or an error indicator. N/ IS T .S 5.7.2.3.1 Full MQV Form of the ECC MQV Primitive P .8 This form of invoking the ECC MQV primitive is used in Section 6.1.1.4 by the Full MQV 0 0 scheme. In this form, each party has both a static key pair and an ephemeral key pair. Assume -5 6 that the party performing the computation is party A, and the other party is party B. Note that A r3 party A could be either party U or party V. In this form, one’s own second private and public keys (item 4 and 5 of the input list in Section 5.7.2.3) are one’s own ephemeral private and public keys (d and Q ), and the other e,A e,A party’s second public key (item 6 of the input list in Section 5.7.2.3) is the other party’s ephemeral public key (Q ). e,B 26 In the ECC MQV primitive, a second key may be either ephemeral or static, depending on which form of the primitive is being used; see Sections 5.7.2.3.1 and 5.7.2.3.2. 5 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.7.2.3.2 One-Pass Form of the ECC MQV Primitive This form of invoking the ECC MQV primitive is used in Section 6.2.1.4 by the One-Pass MQV scheme. In this form, party U has a static key pair and an ephemeral key pair, but party V has only a static key pair. One-Pass MQV uses the MQV primitive with party V’s static key pair as the second key pair (as party V has no ephemeral keys). Party U uses party V’s static public key as the other party’s second public key. When party U uses the algorithm in Section 5.7.2.3, item 6 of the input list is party V’s static public key (Q ). s,B Party V uses his static private key as his second private key. When party V uses the algorithm in Section 5.7.2.3, item 4 of the input list is V’s static private key d , and item 5 is his static s,A T public key (Q s,A). h is p u 5.8 Key-Derivation Methods for Key-Agreement Schemes b lic a tio An approved key-derivation method shall be used to derive keying material from the shared n secret, Z, that is computed during the execution of a key-agreement scheme specified in this is a Recommendation. The shared secret shall be used only by an approved key-derivation v a ila method (as specified in SP 800-56C) and shall not be used for any other purpose. b le When employed during the execution of a key-agreement scheme as specified in this fre e Recommendation, the agreed-upon key-derivation method uses input that includes a freshly o f c computed shared secret Z, along with other information. The derived keying material shall h a be computed in its entirety before outputting any portion of it, and (each copy of) Z shall be rg e treated as a critical security parameter in a cryptographic module and destroyed immediately fro following its use. m : h The output produced by a key-derivation method using input that includes the shared secret ttp s computed during the execution of any key-agreement scheme specified in this ://d o Recommendation shall only be used as secret keying material – such as a symmetric key i.o used for data encryption or message integrity, a secret initialization vector, or, perhaps, a rg /1 key-derivation key that will be used to generate additional keying material (possibly using a 0 .6 different process – see SP 800-10827). The derived keying material shall not be used as a key 0 2 8 stream for a stream cipher. Non-secret keying material (such as a non-secret initialization N/ IS vector) shall not be generated using a key-derivation method that includes the shared secret, T .S Z, as input (this restriction applies to all one-step and two-step key-derivation methods). P .8 0 0 5.8.1 Performing the Key Derivation -5 6 A Approved methods for key derivation from a shared secret are specified in SP 800-56C28. r3 These methods can be accessed using the following call: KDM(Z, OtherInput), where 27 SP 800-108, Recommendation for Key Derivation Using Pseudorandom Functions. 28 SP 800-56C, Recommendation for Key Derivation Methods in Key Establishment Schemes. 5 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. Z is a byte string that represents the shared secret, 2. OtherInput consists of additional input information that may be required by a given key-derivation method, for example: • L − an integer that indicates the length (in bits) of the secret keying material to be derived. • salt − a byte string. • IV – a bit string used as an initialization value. • FixedInfo – a bit sting of context-specific data (see Section 5.8.2). See SP 800-56C for details concerning the appropriate form of OtherInput. T h is p 5.8.2 FixedInfo u b lic The bit string FixedInfo should be used to ensure that the derived keying material is a tio adequately “bound” to the context of the key-agreement transaction. Although other methods n is may be used to bind keying material to the transaction context, this Recommendation makes a v no statement as to the adequacy of these other methods. Failure to adequately bind the a ila derived keying material to the transaction context could adversely affect the types of b le fre assurance that can be provided by certain key-agreement schemes. e o Context-specific information that may be appropriate for inclusion in FixedInfo: f c h a • Public information about parties U and V, such as their identifiers. rg e fro • The public keys contributed by each party to the key-agreement transaction. (In the m case of a static public key, one could include a certificate that contains the public : h ttp key.) s ://d • Other public and/or private information shared between parties U and V before or o i.o during the transaction, such as nonces or pre-shared secrets. rg /1 • An indication of the protocol or application employing the key-derivation method. 0 .6 0 2 • Protocol-related information, such as a label or session identifier. 8 N/ IS • Agreed-upon encodings (as bit strings) of the values of one or more of the other T .S parameters used as additional input to the KDM (e.g., L, salt, and/or IV). P .8 0 • An indication of the key-agreement scheme and/or key-derivation method used. 0 -5 6 • An indication of the domain parameters associated with the asymmetric key pairs A r3 employed for key establishment. • An indication of other parameter or primitive choices (e.g., the agreed-upon hash/MAC algorithms, the bit lengths of any MAC tags used for key confirmation, etc.). • An indication of how the derived keying material should be parsed, including an indication of which algorithm(s) will use the (parsed) keying material. 5 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography For rationale in support of including entity identifiers, scheme identifiers, and/or other information in FixedInfo, see Appendix B. When FixedInfo is used, the meaning of each information item and each item’s position within the FixedInfo bit string shall be specified. In addition, each item of information included in FixedInfo shall be unambiguously represented. For example, each item of information could take the form of a fixed-length bit string, or, if greater flexibility is needed, an item of information could be represented in a Datalen || Data format, where Data is a variable-length string of zero or more (eight-bit) bytes, and Datalen is a fixed-length, big- endian counter that indicates the length (in bytes) of Data. These requirements can be satisfied, for example, by using ASN.1 DER encoding for FixedInfo, as specified in Section 5.8.2.1.2. T h is SP 800-56C specifies both one-step key-derivation methods (i.e., key-derivation functions) p u and two-step key-derivation methods (i.e., key-derivation procedures). The following b lic subsections discuss possibilities for the form and format of FixedInfo when it is used by those a tio approved key-derivation methods. n is a v 5.8.2.1 One-step Key Derivation a ila b Recommended formats for FixedInfo when used by a one-step key-derivation method are le fre specified in Sections 5.8.2.1.1 and 5.8.2.1.2. One of those two formats should be used by a e o one-step key-derivation method specified in SP 800-56C when the auxiliary function f c employed is H = hash. h a rg When FixedInfo is included during the key-derivation process, and the recommended formats e fro are used, the included items of information shall be divided into (three, four, or five) m : h subfields as defined below. ttp s AlgorithmID: A required non-null subfield that indicates how the derived keying material ://d will be parsed and for which algorithm(s) the derived secret keying material will be used. o i.o For example, AlgorithmID might indicate that bits 1-112 are to be used as a 112-bit rg /1 HMAC key and that bits 113-240 are to be used as a 128-bit AES key. 0 .6 0 2 PartyUInfo: A required non-null subfield containing public information about party U. 8 N/ At a minimum, PartyUInfo shall include ID , an identifier for party U, as a distinct item IS U T of information. This subfield could also include information about the public key(s) .S P contributed to the key-agreement transaction by party U. The nonce provided by party U .8 0 as required in a C(0e, 2s) scheme (see Section 6.3) shall be included in this subfield. 0 -5 6 PartyVInfo: A required non-null subfield containing public information about party V. A r3 At a minimum, PartyVInfo shall include ID , an identifier for party V, as a distinct item V of information. This subfield could also include information about the public key(s) contributed to the key-agreement transaction by party V. The nonce provided by party V when acting as a key-confirmation recipient in a C(1e, 2s) scheme or a C(0e, 2s) scheme shall be included in this field (see Sections 6.2.1.5 and 6.3.3). SuppPubInfo: An optional subfield that contains additional, mutually known public information (e.g., L, the domain parameters associated with the keys used to derive the shared secret, an identifier for the particular key-agreement scheme that was used to form 5 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Z, an indication of the protocol or application employing that scheme, a session identifier, etc.; this is particularly useful if these aspects of the key-agreement transaction can vary – see Appendix B for further discussion). While an implementation may be capable of including this subfield, the subfield may be Null for a given transaction. SuppPrivInfo: An optional subfield that contains additional, mutually known private information (e.g., a shared symmetric key that has been communicated through a separate channel or established by other means). While an implementation may be capable of including this subfield, the subfield may be Null for a given transaction. 5.8.2.1.1 The Concatenation Format for FixedInfo This section specifies the concatenation format for FixedInfo. This format has been designed T h to provide a simple means of binding the derived keying material to the context of the key- is p agreement transaction, independent of other actions taken by the relying application. Note: u b lic When the one-step key-derivation method specified in SP 800-56C is used with H = hash as a tio the auxiliary function and this concatenation format for FixedInfo, the resulting key- n is derivation method is the Concatenation Key-Derivation Function specified in the original a version of SP 800-56A. v a ila For this format, FixedInfo is a bit string equal to the following concatenation: b le fre AlgorithmID || PartyUInfo || PartyVInfo {|| SuppPubInfo }{|| SuppPrivInfo }, e o f c where the five subfields are bit strings comprised of items of information as described in h a Section 5.8.2. rg e fro Each of the three required subfields AlgorithmID, PartyUInfo, and PartyVInfo shall be the m concatenation of a pre-determined sequence of substrings in which each substring represents : h a distinct item of information. Each such substring shall have one of these two formats: either ttp s it is a fixed-length bit string, or it has the form Datalen || Data – where Data is a variable- ://d o length string of zero or more (eight-bit) bytes, and Datalen is a fixed-length, big-endian i.o counter that indicates the length (in bytes) of Data. (In this variable-length format, a null rg /1 string of data shall be represented by a zero value for Datalen, indicating the absence of 0 .6 following data.) A protocol using this format for FixedInfo shall specify the number, 0 2 8 ordering and meaning of the information-bearing substrings that are included in each of the N/ IS subfields AlgorithmID, PartyUInfo, and PartyVInfo, and shall also specify which of the two T .S formats (fixed-length or variable-length) is used by each such substring to represent its P .8 distinct item of information. The protocol shall specify the lengths for all fixed-length 0 0 quantities, including the Datalen counters. -5 6 A Each of the optional subfields SuppPrivInfo and SuppPubInfo (when allowed by the protocol r3 employing the one-step key-derivation method) shall be the concatenation of a pre- determined sequence of substrings representing additional items of information that may be used during key derivation upon mutual agreement of parties U and V. Each substring representing an item of information shall be of the form Datalen || Data, where Data is a variable-length string of zero or more (eight-bit) bytes and Datalen is a fixed-length, big- endian value that indicates the length (in bytes) of Data; the use of this form for the information allows parties U and V to omit an information item without confusion about the meaning of the other information that is provided in the SuppPrivInfo or SuppPubInfo 5 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography subfield. The substrings representing items of information that parties U and V choose not to contribute are set equal to Null, and are represented in this variable-length format by setting Datalen equal to zero. If a protocol allows the use of the SuppPrivInfo and/or SuppPubInfo subfield(s), then the protocol shall specify the number, ordering and meaning of additional items of information that may be used in the allowed subfield(s) and shall specify the fixed-length of the Datalen values. 5.8.2.1.2 The ASN.1 Format for FixedInfo The ASN.1 format for FixedInfo provides an alternative means of binding the derived keying material to the context of the key-agreement transaction, independent of other actions taken by the relying application. Note: When the one-step key-derivation method specified in SP T 800-56C is used with H = hash as the auxiliary function and this ASN.1 format for FixedInfo, h is the resulting key-derivation method is the ASN.1 Key-Derivation Function specified in the p u original version of SP 800-56A. b lic a For the ASN.1 format, FixedInfo is a bit string resulting from the ASN.1 DER encoding (see tio n ISO/IEC 8825-1) of a data structure comprised of a sequence of three required subfields is a AlgorithmID, PartyUInfo, and PartyVInfo, and, optionally, a SuppPubInfo subfield and/or a v a SuppPrivInfo subfield – as described in Section 5.8.2. A protocol using this format for ila b FixedInfo shall specify the type, ordering and number of distinct items of information le fre included in each of the (three, four, or five) subfields employed. e o f c 5.8.2.2 Two-step Key-Derivation (Extraction-then-Expansion) h a rg For the two-step key-derivation method specified in SP 800-56C, FixedInfo is a bit string e fro m that contains component data fields such as a Label, Context information, and [L] 2, where: : h • Label is a binary string that identifies the purpose of the derived keying material. The ttp s encoding method for the label is defined in a larger context, for example, in a protocol ://d using the key-derivation method. o i.o rg • Context is a binary string containing information relating to the derived keying /1 0 material. Section 5.8.2 provides a list of context-specific information that may be .6 0 2 appropriate for the inclusion in this string. 8 N/ IS • [L] 2 is a binary string that specifies the length (in bits) of the keying material to be T .S derived. P .8 Different orderings of the component data fields of FixedInfo may be used, and one or more of 0 0 -5 the data fields may be combined (or omitted under certain circumstances). See Section 5 in SP 6 A 800-56C, and Sections 5, 7.4, 7.5 and 7.6 in SP 800-108 for details r3 5.8.2.3 Other Formats for FixedInfo Formats other than those provided in Sections 5.8.2.1 and 5.8.2.2 (e.g., those providing the items of information in a different arrangement) may be used for FixedInfo, but context- specific information should be included (see the discussion in Section 5.8.2). This Recommendation makes no statement as to the adequacy of other formats. 5 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.9 Key Confirmation The term key confirmation (KC) refers to actions taken to provide assurance to one party (the key-confirmation recipient) that another party (the key-confirmation provider) is in possession of a (supposedly) shared secret and/or confirm that the other party has the correct version of keying material that was derived during a key-establishment transaction. (Correct, that is, from the perspective of the key-confirmation recipient.) Such actions are said to provide unilateral key confirmation when they provide this assurance to only one of the participants in the key-establishment transaction; the actions are said to provide bilateral key confirmation when this assurance is provided to both participants (i.e., when unilateral key confirmation is provided in both directions). T Oftentimes, key confirmation is obtained (at least implicitly) by some means external to the h is key-establishment scheme employed during a transaction (e.g., by using a symmetric key p u that was established during the transaction to decrypt an encrypted message sent later by the b lic key-confirmation provider), but this is not always the case. In some circumstances, it may be a tio appropriate to incorporate the exchange of explicit key-confirmation information as an n is integral part of the key-establishment scheme itself. The inclusion of key confirmation may a v enhance the security services that can be offered by a key-establishment scheme. For a ila example, when certain key-agreement schemes incorporate key confirmation (as described b le fre in this Recommendation), they can be used to provide the recipient with assurance that the e provider is in possession of the private key corresponding to a particular public key, from o f c which the recipient may infer that the provider is the owner of that key pair (see Sections h a 5.6.2.2.3 and 5.6.2.2.4). rg e fro For key confirmation to comply with this Recommendation, key confirmation shall be m incorporated into an approved key-establishment scheme as specified in Sections 5.9.1 and : h ttp 5.9.2 for keying material derived during the execution of a key-agreement scheme. s ://d o 5.9.1 Unilateral Key Confirmation for Key-Agreement Schemes i.o rg As specified in this Recommendation, unilateral key confirmation occurs when one /1 0 participant in the execution of a key-agreement scheme (the key-confirmation “provider”) .6 0 demonstrates to the satisfaction of the other participant (the key-confirmation “recipient”) 2 8 N/ that both the provider and the recipient have possession of the same secret MacKey. IS T MacKey is a symmetric key derived using the (shared) secret Z that was computed by each .S P party during that particular execution of the key-agreement scheme (see Section 5.8 about .8 0 key-derivation methods). MacKey and certain context-specific MacData (see step 2 below) 0 -5 are used by the provider as input to an approved MAC algorithm to obtain a MacTag that is 6 A r3 sent to the recipient. The recipient performs an independent computation of the MacTag. If the MacTag value computed by the key-confirmation recipient matches the MacTag value received from the key-confirmation provider, then key confirmation is successful. See Section 5.2 for MacTag generation and verification, and Section 5.9.3 for a MacTag security discussion. Successful key confirmation provides assurance to the recipient that the same Z value has been computed by both parties and that the two parties have used Z in the same way to derive shared keying material. 5 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Unilateral key confirmation is an optional feature that can be incorporated into any key- agreement scheme in which the key-confirmation provider is required to own a static key- establishment key pair that is used in the key-establishment process. If the intended key- confirmation recipient is not required to contribute an ephemeral public key to the key- establishment process, then the recipient shall instead contribute a nonce that is used as part of the input to the key-derivation method employed by the scheme. Each party shall have an identifier, chosen in accordance with the assumptions stated for the key-agreement scheme. To include unilateral key confirmation from a provider (who has a static key pair) to a recipient, the following steps shall be incorporated into the scheme. Additional details will be provided for each scheme in the appropriate subsections of Section 6. In the discussion that follows, the key-confirmation provider, P, may be either party U or party V, as long as T h P has a static key pair. The key-confirmation recipient, R, is the other party. is p u 1. If the recipient, R, is not required to generate an ephemeral key pair as part of the b lic key-agreement scheme, then R shall contribute a nonce to be used (in addition to the a tio shared secret Z) as input to the key-derivation method employed by the scheme; that n is nonce will also be used as part of the ephemeral data input to the MAC tag a v computations performed during key conformation. See Section 5.4 for a discussion a ila of the length and security strength required for the nonce. b le fre 2. The provider, P, computes e o MacData = message_string || ID || ID || EphemData || EphemData {|| Text } f c P P P R P R P h a rg where e fro - message_string P is a six byte string with a value of “KC_1_U” when party U is m : h providing the MacTag, or “KC_1_V” when party V is providing the MacTag. ttp (Note that these values will be changed for bilateral key confirmation, as specified s ://d in Section 5.9.2.) o i.o rg - ID P is the identifier used to label the key-confirmation provider. /1 0 .6 - ID R is the identifier used to label the key-confirmation recipient. 0 2 - EphemData and EphemData are ephemeral values (corresponding to ephemeral 8 P R N/ public keys or nonces) contributed by the provider and recipient, respectively. IS T The ephemeral data is specified in the subsections of Section 6 that describe how .S P key confirmation can be incorporated into the particular schemes included in this .8 0 Recommendation. 0 -5 6 o EphemData is Null only in the case that the provider has contributed neither A P r3 an ephemeral public key nor a nonce during the scheme. For example, in a C(1e, 2s) scheme with unilateral key confirmation from party V to party U as introduced in Section 6.2.1.5.2, party V only contributes a static key pair; in this case, EphemData can be Null. V o When EphemData, (where i is P or R) is an ephemeral public key, the public i key EphemPubKey is a byte string determined as follows: i 5 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography For FFC schemes, i’s ephemeral public key, t, is converted from a field i element in GF(p) to a byte string by representing the field element as an integer in the interval [2, p − 2], and then converting the integer to a byte string as specified in Appendix C.1. For ECC schemes, the coordinates of i’s ephemeral public key, Q , are e,i converted from field elements to byte strings as specified in Appendix C.2 and concatenated (with the x coordinate first) to form a single byte string. - Text isan optional byte string that may be used during key confirmation and P that is known by both parties. The content of each of the components that are concatenated to form MacData shall P T be precisely defined and unambiguously represented. A component’s content may be h is p represented, for example, as a fixed-length bit string or in the form Datalen || Data, u b where Data is a variable-length string of zero or more (eight-bit) bytes, and Datalen lic a is a fixed-length, big-endian counter that indicates the length (in bytes) of Data. tio n These requirements could also be satisfied by using a specific ASN.1 DER encoding is a of each component. It is imperative that the provider and recipient have agreed upon v a the content and format that will be used for each component of MacData . ila P b le 3. After computing the shared secret Z and applying the key-derivation method to obtain fre DerivedKeyingMaterial (see Section 5.8 and SP 800-56C), the provider uses agreed- e o upon bit lengths to parse DerivedKeyingMaterial into two parts, MacKey and f c h KeyData, of the pre-agreed lengths: a rg e fro MacKey || KeyData = DerivedKeyingMaterial. m : h 4. Using an agreed-upon bit length for MacTagBits, the provider computes MacTag P ttp (see Sections 5.2.1 and 5.9.3): s ://d MacTag = T [MAC (MacKey, MacData )], o P MacTagBits P i.o rg and sends it to the recipient. /1 0 .6 5. The recipient forms MacData P, determines MacKey, computes MacTag P in the same 0 2 manner as the provider, and then verifies that the computed MacTag is equal to the 8 P N/ value received from the provider. If the values are equal, then the recipient is assured IS T that the provider has derived the same value for MacKey and that the provider shares .S P the recipient’s value of MacData . The assurance of a shared value for MacKey .8 P 0 provides assurance to the recipient that the provider also shares the secret value (Z) 0 -5 from which MacKey and KeyData are derived. Thus, the recipient also has assurance 6 A r3 that the provider could compute KeyData correctly. Both parties shall destroy the MacKey once it is no longer needed to provide or obtain key confirmation. If, during a key-agreement transaction, it happens that MacTag cannot be verified by the P recipient, then key confirmation has failed, and all of the derived keying material (MacKey and KeyData) shall be destroyed by each participant. In particular, DerivedKeyingMaterial shall not be revealed by either participant to any other party (not even to the other 6 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography participant), and the derived keying material shall not be used for any further purpose. In the case of a key-confirmation failure, the key-agreement transaction shall be discontinued. Unilateral key confirmation may be added in either direction to any of the C(2e, 2s), C(1e, 2s) and C(0e, 2s) schemes; it may also be added to the C(1e, 1s) schemes, but only when party V (the party contributing the static key pair) is the key-confirmation provider, and party U is the key-confirmation recipient. See the relevant subsections of Section 6. 5.9.2 Bilateral Key Confirmation for Key-Agreement Schemes Bilateral key confirmation is an optional feature that can be incorporated into any key- agreement scheme in which each party is required to own a static key-establishment key pair that is used in the key-establishment process. Bilateral key confirmation is accomplished by T h performing unilateral key confirmation in both directions (with party U providing MacTag is U p to recipient party V, and party V providing MacTag to recipient party U) during the same u V b lic key-agreement transaction. If a party is not also required to contribute an ephemeral public a tio key to the key-establishment process, then that party shall instead contribute a nonce that is n is used as part of the input to the key-derivation method employed by the scheme; the nonce a will also be used as part of the ephemeral data input to the MAC tag computations performed v a ila during key conformation. See Section 5.4 for a discussion of the length and security strength b le required for the nonce. Each party shall have an identifier, chosen in accordance with the fre assumptions stated for the key-agreement scheme. e o f c To include bilateral key confirmation, two instances of unilateral key confirmation (as h a specified in Section 5.9.1, subject to the modifications listed below) shall be incorporated rg e into the scheme, once with party U as the key-confirmation provider (i.e., P = U and R = V) fro and once with party V as the provider (i.e., P = V and R = U). Additional details will be m : h provided for each scheme in the appropriate subsections of Section 6. ttp s ://d In addition to setting P = U and R = V in one instance of the unilateral key-confirmation o procedure described in Section 5.9.1 and setting P = V and R = U in a second instance, the i.o rg following changes/clarifications apply when using the procedure for bilateral key /1 confirmation: 0 .6 0 2 1. When computing MacTag , the value of the six-byte message_string that forms the 8 U U N/ initial segment of MacData is “KC_2_U”. IS U T .S 2. When computing MacTag V, the value of the six-byte message_string V that forms the P .8 initial segment of MacData V is “KC_2_V”. 0 0 -5 6 3. If used at all, the value of the (optional) byte string Text U used to form the final A segment of MacData can be different than the value of the (optional) byte string r3 U Text used to form the final segment of MacData , provided that both parties are V V aware of the value(s) used. Bilateral key confirmation may be added to the C(2e, 2s), C(1e, 2s) and C(0e, 2s) schemes, as specified in the relevant subsections of Section 6. 6 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5.9.3 Selecting the MAC and Other Key-Confirmation Parameters Key confirmation as specified in this Recommendation requires that a MacKey of an appropriate length be generated as part of the derived keying material (see Section 5.9.1). The MacKey is then used with a MAC algorithm to generate a MAC; the length of the MAC output by the MAC algorithm is MacOutputBits. The MAC is subsequently used to form a MAC tag (see Section 5.9.1 for the generation of the MAC and Section 5.2.1 for the formation of the MAC tag from the MAC). Table 5 provides a list of approved MAC algorithms for key confirmation and the security strengths that each can support, along with the corresponding value of MacOutputBits and permissible MacKey lengths for each MAC algorithm. T Table 5: Approved MAC algorithms for key confirmation. h is p Supported Security u Permissable b lic MAC Algorithm MacOutputBits MacKey Lengths Strengths for Key a tio ( bits) Confirmation n is (s bits) a HMAC_SHA-1 160 v a ila HMAC_SHA-224 224 b le HMAC_SHA-512/224 224 fre HMAC_SHA-256 256 e o HMAC_SHA-512/256 256 f c 112  s  256 h a HMAC_SHA-384 384 s    512 rg e HMAC_SHA-512 512 fro HMAC_SHA3-224 224 m : h HMAC_SHA3-256 256 ttp HMAC_SHA3-384 384 s ://d HMAC_SHA3-512 512 o i.o KMAC128  22040 – 1 112  s  128 rg /1 KMAC256 (see * below) 112  s  256 0 .6 AES-128-CMAC 128  = 128 112  s  128 0 2 8 AES-192-CMAC 128  = 192 112  s  192 N/ IS AES-256-CMAC 128  = 256 112  s  256 T .S P * Although KMAC128 and KMAC256 can accommodate values as large as 22040 − 1 .8 0 for MacOutputBits, practical considerations dictate that the lengths of 0 -5 transmitted MAC tags be limited to sizes that are more realistic and commensurate 6 A with the actual performance/security requirements of the relying applications. r3 The MAC algorithm used to compute a key-confirmation MAC tag in compliance with this Recommendation shall be selected from among the approved MAC algorithms capable of supporting a security strength s that is at least as large as the targeted security strength of the key-establishment scheme (as indicated in Table 5 above). Note that when an HMAC or KMAC algorithm is used for key confirmation as specified in this Recommendation, MacKey lengths can be no greater than 512 bits (an upper bound that is at least twice the maximum supported security strength). This upper bound is smaller than 6 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography any of the upper bounds imposed in the HMAC or KMAC algorithm specifications, but is sufficient for this application. In the case of HMAC, the 512-bit upper bound has the advantage of being less than the input block length of whatever hash function is used in the algorithm’s implementation. If MacKey were allowed to be longer than the input block length, it would be hashed down to a string of length MacOutputBits during the HMAC computation (see step 2 in Table 1 of FIPS 198); allowing MacKey to be longer than the input block length would not be an efficient use of keying material. The length of the MAC tag for key confirmation also needs to be selected. Note that in many cases, the length of the MAC tag (MacTagBits) has been selected by the protocol in which the key-establishment is conducted. MacTagBits shall be at least 64 bits, and its maximum length shall be no more than the MacOutputBits for the MAC algorithm selected for key T h confirmation. The 64-bit minimum for the MAC tag length assumes that the protocol imposes is p a limit on the number of retries for key confirmation. u b lic a tio n is a v a ila b le fre e o f c h a rg e fro m : h ttp s ://d o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 6 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6. Key Agreement Schemes This Recommendation provides three categories of key-agreement schemes (see Table 6). The classification of the categories is based on the number of ephemeral keys used by the two parties to the key-agreement process, parties U and V. In category C(ie), parties U and V have a total of i ephemeral key pairs. The first category, C(2e), consists of schemes requiring the generation of ephemeral key pairs by both parties; a C(2e) scheme is suitable for an interactive key-establishment protocol. The second category, C(1e), consists of schemes requiring the generation of an ephemeral key pair by only one party; a C(1e) scheme is suitable for a store-and-forward scenario, but may also be used in an interactive key- establishment protocol. The third category, C(0e), consists of schemes that do not use ephemeral keys. T h is Key confirmation may be added to many of these schemes to provide assurance that the p u b participants share the same keying material; see Section 5.9 for details on key confirmation. lic a Each party should have such assurance. Although other methods are often used to provide tio n this assurance, this Recommendation makes no statement as to the adequacy of these other is a methods. v a ila Table 6: Key-agreement scheme categories. b le fre Category Comment e o f c C(2e): Two ephemeral key pairs Each party generates an ephemeral key pair. h a rg e fro C(1e): One ephemeral key pair Only party U generates an ephemeral key pair. m : h C(0e): Zero ephemeral key pairs No ephemeral keys are used. ttp s ://d Each category is comprised of one or more subcategories that are classified by the use of o i.o static keys by the parties (see Table 7). In subcategory C(ie, js), parties U and V have a total rg /1 of i ephemeral key pairs and j static key pairs. The suitability for interactive or store-and- 0 .6 forward protocols of each subcategory is discussed in Section 7. 0 2 8 N/ Table 7: Key-agreement scheme subcategories. IS T .S Category Subcategory P .8 0 0 C(2e, 2s): Each party generates an ephemeral key pair and -5 6 A C(2e): Two ephemeral key uses a static key pair. r3 pairs C(2e, 0s): Each party generates an ephemeral key pair; no static key pairs are used. C(1e): One ephemeral key C(1e, 2s): Party U generates an ephemeral key pair and uses pair a static key pair; party V uses only a static key pair. 6 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Category Subcategory C(1e, 1s): Party U generates an ephemeral key pair, but uses no static key pair; party V uses only a static key pair. C(0e): Zero ephemeral key C(0e, 2s): Each party uses only a static key pair. pairs The schemes may be further classified by whether they use finite field cryptography (FFC) or elliptic curve cryptography (ECC). A scheme may use either Diffie-Hellman or MQV primitives (see Section 5.7). Thus, for example, notation C(2e, 2s, FFC DH) completely T classifies the dhHybrid1 scheme of Section 6.1.1.1 as a scheme with two ephemeral keys and h is two static keys that uses finite field cryptography and a Diffie-Hellman primitive (see Table p u b 8). The names of these schemes are taken from ANS X9.42 and ANS X9.63. lic a tio Table 8: Key-agreement schemes. n is a Category Subcategory Primitive Scheme Notation v a ila b le C(2e) C(2e, 2s) FFC DH dhHybrid1 C(2e, 2s, FFC DH) fre e o C(2e) C(2e, 2s) ECC CDH (Cofactor) Full Unified C(2e, 2s, ECC CDH) f c Model h a rg e fro C(2e) C(2e, 2s) FFC MQV MQV2 C(2e, 2s, FFC m MQV) : h ttp s C(2e) C(2e, 2s) ECC MQV Full MQV C(2e, 2s, ECC ://d MQV) o i.o rg /1 C(2e) C(2e, 0s) FFC DH dhEphem C(2e, 0s, FFC DH) 0 .6 0 2 C(2e) C(2e, 0s) ECC CDH (Cofactor) Ephemeral C(2e, 0s, ECC CDH) 8 N/ Unified Model IS T .S P C(1e) C(1e, 2s) FFC DH dhHybridOneFlow C(1e, 2s, FFC DH) .8 0 0 -5 C(1e) C(1e, 2s) ECC CDH (Cofactor) One-Pass C(1e, 2s, ECC CDH) 6 A Unified Model r3 C(1e) C(1e, 2s) FFC MQV MQV1 C(1e, 2s, FFC MQV) C(1e) C(1e, 2s) ECC MQV One-Pass MQV C(1e, 2s, ECC MQV) C(1e) C(1e, 1s) FFC DH dhOneFlow C(1e, 1s, FFC DH) 6 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Category Subcategory Primitive Scheme Notation C(1e) C(1e, 1s) ECC CDH (Cofactor) One-Pass C(1e, 1s, ECC CDH) Diffie-Hellman C(0e) C(0e, 2s) FFC DH dhStatic C(0e, 2s, FFC DH) C(0e) C(0e, 2s) ECC CDH (Cofactor) Static Unified C(0e, 2s, ECC CDH) Model Each party in a key-agreement process shall use the same set of valid domain parameters. T These parameters shall be established, and assurance of their validity shall be obtained prior h is to the generation of key pairs and the initiation of the key-agreement process. See Section p u 5.5 for a discussion of domain parameters. b lic a tio If party U uses a static key pair in a key-agreement transaction, then party U shall have an n is identifier, ID U, that has an association with the static key pair that is known (or discoverable) a and trusted by party V (i.e., there shall be a trusted association between ID and party U’s v U a ila static public key). If party U does not contribute a static public key as part of a key-agreement b le transaction, then ID U (if required for that transaction) is a non-null identifier selected in fre accordance with the relying application/protocol. Similar rules apply to Party V’s identifier, e o ID . f c V h a A general flow diagram is provided for each subcategory of schemes. The dotted-line arrows rg e represent the distribution of static public keys that may be distributed by the parties fro themselves or by a third party, such as a Certification Authority (CA). The solid-line arrows m : h represent the distribution of ephemeral public keys or nonces that occur during the key- ttp agreement or key-confirmation process. Note that the flow diagrams in this Recommendation s ://d omit explicit mention of various validation checks that are required. The flow diagrams and o i.o descriptions in this Recommendation assume a successful completion of the key- rg /1 establishment process. The error conditions are handled in the process text. 0 .6 0 For each scheme, there are conditions that must be satisfied to enable proper use of that 2 8 scheme. These conditions are listed as the assumptions. Failure to meet all such conditions N/ IS could yield undesirable results, such as the inability to communicate or the loss of security. T .S As part of the proper implementation of this Recommendation, system users and/or agents P .8 trusted to act on their behalf (including application developers, system installers, and system 0 0 administrators) are responsible for ensuring that all assumptions are satisfied at the time a -5 6 A key-establishment transaction takes place. r3 6.1 Schemes Using Two Ephemeral Key Pairs, C(2e) In this category, each party generates an ephemeral key pair and sends the ephemeral public key to the other party. This category consists of two subcategories that are determined by the static keys used by the parties. In the first subcategory, each party contributes both static and ephemeral keys to the key-agreement computations (see Section 6.1.1), while in the second subcategory, each party contributes only ephemeral keys (see Section 6.1.2). 6 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.1.1 C(2e, 2s) Schemes Figure_3 depicts a typical flow for a C(2e, 2s) scheme. For these schemes, each party (U and V) contributes a static key pair and generates an ephemeral key pair during the key- agreement process. All key pairs shall be generated using the same domain parameters. Party U and party V obtain each other’s static public keys, which have been generated prior to the key-establishment process. Both parties generate ephemeral private/public key pairs and exchange the ephemeral public keys. Using the static and ephemeral keys, both parties generate a shared secret. The secret keying material is derived from the shared secret. U V T h is p u b U’s Static Public Key lic a tio Obtain static public n V’s Static Public Key is keys a v a ila b le U’s Ephemeral Public Key fre Exchange e o ephemeral f c V’s Ephemeral Public Key public keys h a rg e fro m : h ttp s Figure 3: C(2e, 2s) schemes: each party contributes a static and an ephemeral key ://d pair o i.o rg Assumptions: In order to execute a C(2e, 2s) key-establishment scheme in compliance with /1 0 this Recommendation, the following assumptions shall be true. .6 0 2 1. Each party has an authentic copy of the same set of domain parameters, D, that are 8 N/ approved for use (see Section 5.5.1). For FFC schemes, D = (p, q, g{, SEED, IS T counter}); for ECC schemes, D = (q, FR, a, b{, SEED}, G, n, h). Furthermore, each .S P party has obtained assurance of the validity of these domain parameters as specified .8 0 in Section 5.5.2. 0 -5 6 A 2. Each party has been designated as the owner of a static key pair that was generated r3 as specified in Section 5.6.1 using the set of domain parameters, D. For FFC schemes, the static key pair is (x, y); for ECC schemes, the static key pair is (d, Q). Each party s s has obtained assurance of the validity of its own static public key as specified in Section 5.6.2.1.3 and has obtained assurance of its possession of the correct value for its own private key as specified in Section 5.6.2.1.5. 3. The parties have agreed upon an approved key-derivation method, as well as an approved algorithm to be used with that method (e.g., a hash function) and other associated parameters to be used for key derivation (see Section 5.8). 6 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 4. If key confirmation is used, the parties have also agreed upon an approved MAC and associated parameters, including the lengths of MacKey and MacTag, as specified in Section 5.9.3). 5. Prior to or during the key-agreement process, each party receives the other party’s static public key in a trusted manner (e.g., from a certificate signed by a trusted CA or directly from the other party, who is trusted by the recipient). Each party has obtained assurance of the validity of the other party’s static public key as specified in Section 5.6.2.2. 6. The recipient of a static public key has obtained assurance that its (claimed) owner is (or was) in possession of the corresponding static private key, as specified in Section 5.6.2.2.3. T h is 7. When an identifier is used to label a party during the key-agreement process, that p u identifier has a trusted association to that party’s static public key. (In other words, b lic whenever both the identifier and static public key of one participant are employed in a tio the key-agreement process, they are associated in a manner that is trusted by the other n is participant.) When an identifier is used to label a party during the key-agreement a v process, both parties are aware of the identifier employed for that purpose. a ila b le 6.1.1.1 dhHybrid1, C(2e, 2s, FFC DH) Scheme fre e o This section describes the dhHybrid1 scheme. Assurance of secure key establishment using f c this scheme can only be obtained when the assumptions in Section 6.1.1 are true. In h a rg particular, it is assumed that party U has obtained the static public key y V of party V, and e fro party V has obtained the static public key y U of party U. m : h With the exception of key derivation, the dhHybrid1 scheme is “symmetric” in the actions ttp of parties U and V. Only the actions performed by party U are specified here; a specification s ://d of the actions performed by party V may be obtained by systematically replacing the letter o i.o “U” by “V” (and vice versa) in the actions listed below. Note, however, that parties U and V rg must use identical orderings of the bit strings that are input to the key-derivation method. /1 0 .6 Party U shall execute the following actions to a) establish a shared secret value Z with party 0 2 8 V, and b) derive secret keying material from Z. N/ IS Actions: Party U generates a shared secret and derives secret keying material as follows: T .S P 1. Generate an ephemeral key pair (r t ) from the domain parameters D as specified in .8 U, U 0 Section 5.6.1.1. Send the public key t to party V. Receive an ephemeral public key 0 U -5 6 A t V (purportedly) from party V. If t V is not received, destroy the ephemeral private key r3 r U, then output an error indicator, and exit this process without performing the remaining actions. 2. Verify that t is a valid ephemeral public key for the parameters D as specified in V Section 5.6.2.3. If assurance of public key validity cannot be obtained, destroy the ephemeral private key r ; then, output an error indicator, and exit this process without U performing the remaining actions. 3. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret Z from the set s of domain parameters D, party U’s static private key x , and party V’s static public U 6 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography key y . If the call to the FFC DH primitive outputs an error indicator, destroy the V ephemeral private key r , and destroy the results of all intermediate calculations used U in the attempted computation of Z; then output an error indicator, and exit this s process without performing the remaining actions. 4. Use the FFC DH primitive to derive a shared secret Z from the set of domain e parameters D, party U’s ephemeral private key r , and party V’s ephemeral public U key t If this call to the FFC DH primitive outputs an error indicator, destroy Z and V. s the ephemeral private key r , and destroy the results of all intermediate calculations U, used in the attempted computation of Z ; then, output an error indicator, and exit this e process without performing the remaining actions. 5. Compute the shared secret Z = Z || Z. Destroy Z and Z. T e s e s h is p 6. Use the agreed-upon key-derivation method to derive secret keying material with the u b specified length from the shared secret value Z and other input (see Section 5.8). If lic a the key-derivation method outputs an error indicator, destroy all copies of Z and the tio n ephemeral private key r , then output an error indicator, and exit this process without is U a performing the remaining actions. v a ila b 7. Destroy r U and all copies of the shared secret Z. le fre 8. Output the derived keying material. e o Output: The derived keying material or an error indicator. f c h a Note: Key confirmation can be incorporated into this scheme. See Section 6.1.1.5 for details. rg e fro dhHybrid1 is summarized in Table 9. m : h Table 9: dhHybrid1 key-agreement scheme summary ttp s ://d Party U Party V o i.o rg Domain D = (p, q, g{, SEED, counter}) D = (p, q, g{, SEED, counter}) /1 0 parameters .6 0 2 8 N/ Static Data Static private key x U Static private key x V IS T Static public key y Static public key y .S U V P .8 0 Ephemeral private key r Ephemeral private key r 0 U V -5 Ephemeral Data 6 A Ephemeral public key t U Ephemeral public key t V r3 1. Compute Z by calling FFC 1. Compute Z by calling FFC DH s s DH using x and y using x and y U V V U Computation 2. Compute Z by calling FFC 2. Compute Z by calling FFC DH e e DH using r and t using r and t U V V U 3. Compute Z = Z || Z 3. Compute Z = Z || Z e s e s 6 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. Compute 1. Compute Derive Secret DerivedKeyingMaterial DerivedKeyingMaterial Keying Material 2. Destroy Z 2. Destroy Z 6.1.1.2 (Cofactor) Full Unified Model, C(2e, 2s, ECC CDH) Scheme This section describes the Full Unified Model scheme. Assurance of secure key establishment using this scheme can only be obtained when the assumptions in Section 6.1.1 are true. In particular, it is assumed that party U has obtained the static public key Q s,V of party V, and party V has obtained the static public key Q of party U. s,U T With the exception of key derivation, the Full Unified Model scheme is “symmetric” in the h is p actions of parties U and V. Only the actions performed by party U are specified here; a u b specification of the actions performed by party V may be obtained by systematically lic a replacing the letter “U” by “V” (and vice versa) in the actions listed below. Note, however, tio n that parties U and V must use identical orderings of the bit strings that are input to the key- is a derivation method. v a ila Party U shall execute the following actions to a) establish a shared secret value Z with party b le V, and b) derive secret keying material from Z. fre e Actions: Party U generates a shared secret and derives secret keying material as follows: o f c h a 1. Generate an ephemeral key pair (d e,U, Q e,U) from the domain parameters D as specified rg in Section 5.6.1.2. Send the public key Q to party V. Receive an ephemeral public e e,U fro key Q e,V (purportedly) from party V. If Q e,V is not received, destroy the ephemeral m private key d ; then output an error indicator, and exit this process without : h e,U ttp performing the remaining actions. s ://d o 2. Verify that Q e,V is a valid ephemeral public key for the parameters D as specified in i.o Section 5.6.2.3. If assurance of public key validity cannot be obtained, destroy the rg /1 ephemeral private key d e,U, then output an error indicator, and exit this process 0 .6 without performing the remaining actions. 0 2 8 3. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the N/ s IS set of domain parameters D, party U’s static private key d , and party V’s static T s,U .S public key Q . If the call to the ECC CDH primitive outputs an error indicator, P s,V .8 0 destroy the ephemeral private key d e,U, and destroy the results of all intermediate 0 calculations used in the attempted computation of Z ; then output an error indicator, -5 s 6 A and exit this process without performing the remaining actions. r3 4. Use the ECC CDH primitive to derive a shared secret Z from the set of domain e parameters D, party U’s ephemeral private key d , and party V’s ephemeral public e,U key Q . If this call to the ECC CDH primitive outputs an error indicator, destroy Z e,V s and the ephemeral private key d , and destroy the results of all intermediate e,U calculations used in the attempted computation of Z ; then output an error indicator, e and exit this process without performing the remaining actions. 5. Compute the shared secret Z = Z || Z . Destroy Z and Z . e s e s 7 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z and the ephemeral private key d ; then output an error indicator, and exit this process e,U without performing the remaining actions. 7. Destroy d and all copies of the shared secret Z. e,U 8. Output the derived keying material. Output: The derived keying material or an error indicator. Note: Key confirmation can be incorporated into this scheme. See Section 6.1.1.5 for details. T The Full Unified Model is summarized in Table 10. h is p Table 10: Full unified model key-agreement scheme summary u b lic a tio Party U Party V n is a Domain D = (q, FR, a, b{, SEED}, G, n, h) D = (q, FR, a, b{, SEED}, G, n, h) v a ila parameters b le fre Static data Static private key d s,U Static private key d s,V e o f c Static public key Q s,U Static public key Q s,V h a rg Ephemeral data Ephemeral private key d Ephemeral private key d e e,U e,V fro m Ephemeral public key Q e,U Ephemeral public key Q e,V : h ttp 1. Compute Z by calling ECC 1. Compute Z by calling ECC s s s ://d o CDH using d s,U and Q s,V CDH using d s,V and Q s,U i.o rg Computation 2. Compute Z e by calling ECC 2. Compute Z e by calling ECC /1 CDH using d and Q CDH using d and Q 0 .6 e,U e,V e,V e,U 0 2 8 3. Compute Z = Z e || Z s 3. Compute Z = Z e || Z s N/ IS T 1. Compute 1. Compute .S Derive secret P DerivedKeyingMaterial DerivedKeyingMaterial .8 keying material 0 -50 2. Destroy Z 2. Destroy Z 6 A r3 6.1.1.3 MQV2, C(2e, 2s, FFC MQV) Scheme This section describes the MQV2 scheme. Assurance of secure key establishment using this scheme can only be obtained when the assumptions in Section 6.1.1 are true. In particular, it is assumed that party U has obtained the static public key y of party V, and party V has V obtained the static public key y of party U. U With the exception of key derivation, MQV2 is “symmetric” in the actions of parties U and V. Only the actions performed by party U are specified here; a specification of the actions 7 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography performed by party V may be obtained by systematically replacing the letter “U” by “V” (and vice versa) in the actions listed below. Note, however, that parties U and V must use identical orderings of the bit strings that are input to the key-derivation method. Party U shall execute the following actions to a) establish a shared secret value Z with party V, and b) derive secret keying material from Z. Actions: Party U generates a shared secret and derives secret keying material as follows: 1. Generate an ephemeral key pair (r t ) from the domain parameters D as specified in U, U Section 5.6.1.1. Send the public key t to party V. Receive an ephemeral public key U t (purportedly) from party V. If t is not received, destroy the ephemeral private key V V r ; then output an error indicator, and exit this process without performing the U T remaining actions. h is p 2. Verify that t is a valid ephemeral public key for the parameters D as specified in u V b lic Section 5.6.2.3. If assurance of public key validity cannot be obtained, destroy the a tio ephemeral private key r U; then output an error indicator, and exit this process without n is performing the remaining actions. a v a 3. Use the MQV2 form of the FFC MQV primitive in Section 5.7.2.1 to derive a shared ila b secret Z from the set of domain parameters D, party U’s static private key x , party le U fre V’s static public key y V, party U’s ephemeral private key r U, party U’s ephemeral e public key t , and party V’s ephemeral public key t . If the call to the FFC MQV o U V f c h primitive outputs an error indicator, destroy the ephemeral private key r U, and destroy a rg the results of all intermediate calculations used in the attempted computation of Z; e fro then output an error indicator, and exit this process without performing the remaining m actions. : h ttp 4. Use the agreed-upon key-derivation method to derive secret keying material with the s ://d specified length from the shared secret value Z and other input (see Section 5.8). If o the key-derivation method outputs an error indicator, destroy all copies of Z and the i.o rg /1 ephemeral private key r U; then output an error indicator, and exit this process without 0 performing the remaining actions. .6 0 2 5. Destroy r and all copies of the shared secret Z. 8 U N/ IS 6. Output the derived keying material. T .S P Output: The derived keying material or an error indicator. .8 0 0 Note: Key confirmation can be incorporated into this scheme. See Section 6.1.1.5 for details. -5 6 A MQV2 is summarized in Table 11. r3 Table 11: MQV2 key-agreement scheme summary Party U Party V Domain D = (p, q, g{, SEED, counter}) D = (p, q, g{, SEED, counter}) parameters 7 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Static private key x Static private key x U V Static data Static public key y Static public key y U V Ephemeral Ephemeral private key r U Ephemeral private key r V data Ephemeral public key t Ephemeral public key t U V Compute Z by calling FFC MQV Compute Z by calling FFC MQV Computation using x , y , r , t , and t using x , y , r , t , and t U V U U V V U V V U Derive secret 1. Compute 1. Compute T keying DerivedKeyingMaterial DerivedKeyingMaterial h is p u material 2. Destroy Z 2. Destroy Z b lic a tio 6.1.1.4 Full MQV, C(2e, 2s, ECC MQV) Scheme n is a This section describes the Full MQV scheme. Assurance of secure key establishment using v a ila this scheme can only be obtained when the assumptions in Section 6.1.1 are true. In b le particular, it is assumed that party U has obtained the static public key Q s,V of party V, and fre party V has obtained the static public key Q s,U of party U. e o f c With the exception of key derivation, the Full MQV scheme is “symmetric” in the actions of h a parties U and V. Only the actions performed by party U are specified here; a specification of rg e the actions performed by party V may be obtained by systematically replacing the letter “U” fro by “V” (and vice versa) in the actions listed below. Note, however, that parties U and V must m : h use identical orderings of the bit strings that are input to the key-derivation method. ttp s Party U shall execute the following actions to a) establish a shared secret value Z with party ://d V, and b) derive secret keying material from Z. o i.o rg Actions: Party U generates a shared secret and derives secret keying material as follows: /1 0 .6 0 1. Generate an ephemeral key pair (d e,U, Q e,U) from the domain parameters D as specified N2 8 / in Section 5.6.1.2. Send the public key Q e,U to party V. Receive an ephemeral public IS key Q e,V (purportedly) from party V. If Q e,V is not received, destroy the ephemeral T .S private key d e,U; then output an error indicator, and exit this process without P performing the remaining actions. .8 0 0 -5 2. Verify that Q e,V is a valid ephemeral public key for the parameters D as specified in 6 A Section 5.6.2.3. If assurance of public key validity cannot be obtained, destroy the r3 ephemeral private key d ; then output an error indicator, and exit this process e,U without performing the remaining actions. 3. Use the Full MQV form of the ECC MQV primitive in Section 5.7.2.3.1 to derive a shared secret value Z from the set of domain parameters D, party U’s static private key d , party V’s static public key Q , party U’s ephemeral private key d , party s,U s,V e,U U’s ephemeral public key Q , and party V’s ephemeral public key Q . If the call to e,U e,V the ECC MQV primitive outputs an error indicator, destroy the ephemeral private key d , and destroy the results of all intermediate calculations used in the attempted e,U 7 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography computation of Z; then output an error indicator, and exit this process without performing the remaining actions. 4. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z and the ephemeral private key d ; then output an error indicator, and exit this process e,U without performing the remaining actions. 5. Destroy d and all copies of the shared secret Z. e,U 6. Output the derived keying material. Output: The derived keying material or an error indicator. T h is Note: Key confirmation can be incorporated into this scheme. See Section 6.1.1.5 for details. p u b lic The Full MQV is summarized in Table 12. a tio Table 12: Full MQV key-agreement scheme summary n is a v Party U Party V a ila b le Domain D = (q, FR, a, b{, SEED}, G, n, h) D = (q, FR, a, b{, SEED}, G, n, h) fre e parameters o f c h Static data 1. Static private key d 1. Static private key d a s,U s,V rg e fro 2. Static public key Q s,U 2. Static public key Q s,V m : h ttp Ephemeral data 1. Ephemeral private key d e,U 1. Ephemeral private key d e,V s ://d 2. Ephemeral public key Q e,U 2. Ephemeral public key Q e,V o i.o rg /1 0 .6 Computation C uso inm gp du st ,e U ,Z Q b s,y V, c da el ,Uli ,n Qg e E ,U,C aC n dM QQ e,V V C uso inm gp du st ,e V , Z Q sb ,Uy , dc ea ,Vll , i Qng e, VE , aC nC d QM eQ ,U V 0 2 8 1. Compute 1. Compute N/ Derive secret IS DerivedKeyingMaterial DerivedKeyingMaterial T keying material .S P 2. Destroy Z 2. Destroy Z .8 0 0 -5 6 6.1.1.5 Incorporating Key Confirmation into a C(2e, 2s) Scheme A r3 The subsections that follow illustrate how to incorporate key confirmation (as described in Section 5.9) into the C(2e, 2s) key-agreement schemes described above. The flow depictions separate the key-establishment flow from the key-confirmation flow. The depictions and accompanying discussions presume that the assumptions of the scheme have been satisfied, that the key-agreement transaction has proceeded successfully through key derivation, and that the received MacTags are successfully verified as specified in Section 5.2.2. 7 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.1.1.5.1 C(2e, 2s) Scheme with Unilateral Key Confirmation Provided by Party U to Party V Figure_4 depicts a typical flow for a C(2e, 2s) scheme with unilateral key confirmation from party U to party V. In this scenario, party U and party V assume the roles of key-confirmation provider and recipient, respectively. The successful completion of this process provides party V with a) assurance that party U has derived the same secret Z value, and b) assurance that party U has actively participated in the process. U V T h is p u U’s Static Public Key b lic Obtain static a tio public keys n V’s Static Public Key is a v a ila b U’s Ephemeral Public Key le fre Exchange e ephemeral o f c V’s Ephemeral Public Key public keys h a rg e fro MacTag U U’s key- m : h confirmation ttp s ://d o i.o rg /1 Figure 4: C(2e, 2s) scheme with unilateral key confirmation from party U to party V 0 .6 0 2 To provide (and receive) key confirmation (as described in Section 5.9.1), party U (and party 8 N/ V) set IS T .S P EphemData U = EphemPubKey U, and EphemData V = EphemPubKey V. .8 0 Party U provides MacTag to party V (as specified in Section 5.9.1, with P = U and R = V), 0 U -5 where MacTag is computed (as specified in Section 5.2.1) using 6 U A r3 MacData = “KC_1_U” || ID || ID || EphemPubKey || EphemPubKey {|| Text }. U U V U V U Party V (the key-confirmation recipient) uses the same format for MacData to compute its U own version of MacTag , and then verifies that the newly computed MacTag matches the U U value provided by party U. Party U shall destroy its copy of MacKey immediately after computing MacTag . Party V U shall immediately destroy its copy of MacKey after determining whether or not the received and newly computed MacTag values match. If they do not match, then party V shall also U 7 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify party U that MacTag could not be verified. In this case, party U shall also destroy the U KeyData portion of the DerivedKeyingMaterial. 6.1.1.5.2 C(2e, 2s) Scheme with Unilateral Key Confirmation Provided by Party V to Party U Figure_5 depicts a typical flow for a C(2e, 2s) scheme with unilateral key confirmation from party V to party U. In this scenario, party V and party U assume the roles of key-confirmation provider and recipient, respectively. The successful completion of the key-confirmation process provides party U with a) assurance that party V has derived the same secret Z value, and b) assurance that party V has actively participated in the process. T h is p u U V b lic a tio n is U’s Static Public Key a v a Obtain static ila V’s Static Public Key b public keys le fre e o f c U’s Ephemeral Public Key U sends an h ephemeral a rg public key e fro m : h V’s Ephemeral Pub lic Key, MacTag V V sends an ttp ephemeral public s ://d o k coey nf w irmith a tk ioe ny i.o rg /1 0 Figure 5: C(2e, 2s) scheme with unilateral key confirmation from party V to party U .6 0 2 N8 / To provide (and receive) key confirmation (as described in Section 5.9.1), party V (and party IS U) set T .S P EphemData = EphemPubKey , and EphemData = EphemPubKey . .8 V V U U 0 0 -5 6 Party V provides MacTag to party U (as specified in Section 5.9.1, with P = V and R = U), A V r3 where MacTag is computed (as specified in Section 5.2.1) using V MacData = “KC_1_V” || ID || ID || EphemPubKey || EphemPubKey {|| Text }. V V U V U V Party U (the key-confirmation recipient) uses the same format for MacData to compute its V own version of MacTag and then verifies that the newly computed MacTag matches the V V value provided by party V. Note that in Figure_5, party V’s ephemeral public key (EphemPubKey ) and the MacTag V (MacTag ) are depicted as being sent in the same message (to reduce the number of passes V 7 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography in the combined key-agreement/key-confirmation process). They may also be sent separately. Party V shall destroy its copy of MacKey immediately after computing MacTag . Party U V shall immediately destroy its copy of MacKey after determining whether or not the received and newly computed MacTag values match. If they do not match, then party U shall also V destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify party V that MacTag could not be verified. In this case, party V shall also destroy the V KeyData portion of the DerivedKeyingMaterial. 6.1.1.5.3 C(2e, 2s) Scheme with Bilateral Key Confirmation Figure_6 depicts a typical flow for a C(2e, 2s) scheme with bilateral key confirmation. In T h this method, party U and party V assume the roles of both the provider and the recipient in is p order to obtain bilateral key confirmation. The successful completion of the key-confirmation u b process provides each party with a) assurance that the other party has derived the same secret lic a Z value, and b) assurance that the other party has actively participated in the process. tio n is a v a ila U V b le fre e o U’s Static Public Key f c h a rg V’s Static Public Key Obtain static e fro public keys m : h ttp U’s Ephemeral Public Key U sends an ephemeral s ://d public key o i.o rg /1 V’s Ephemeral Public Key, MacTag V V sends an ephemeral 0 public key with key .6 0 confirmation 2 8 N/ MacTag IS U U’s key T .S confirmation P .8 0 0 -5 6 A Figure 6: C(2e, 2s) scheme with bilateral key confirmation r3 To provide bilateral key confirmation (as described in Section 5.9.2), party U and party V exchange and verify MacTags that have been computed (as specified in Section 5.2.1) using EphemData = EphemPubKey , and EphemData = EphemPubKey . U U V V Party V provides MacTag to party U (as specified in Sections 5.9.1 and 5.9.2, with P = V V and R = U); MacTag is computed by party V (and verified by party U) using V MacData = “KC_2_V” || ID || ID || EphemPubKey || EphemPubKey {|| Text }. V V U V U V 7 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Party U provides MacTag to party V (as specified in Sections 5.9.1 and 5.9.2, with P = U U and R = V); MacTag is computed by party U (and verified by party V) using U MacData = “KC_2_U” || ID || ID || EphemPubKey || EphemPubKey {|| Text }. U U V U V U Note that in Figure_6, party V’s ephemeral public key (EphemPubKey ) and the MacTag V (MacTag ) are depicted as being sent in the same message (to reduce the number of passes V in the combined key-agreement/key-confirmation process). They may also be sent separately, and if sent separately, then the order in which the MacTags are sent could be reversed. Each party shall destroy its copy of MacKey immediately after 1) using it to generate a MAC tag to be sent to the other party and 2) determining whether or not the MAC tag received T from the other party matches the MAC tag that it computed. However, if either party is not h is p able to verify the received MAC tag, that party shall also destroy the KeyData portion of the u b DerivedKeyingMaterial (see Section 5.9.1) and notify the other party of the failure. In this lic a case, the other party shall destroy both the MacKey (if it has not already done so) as well as tio n the KeyData portion of the DerivedKeyingMaterial. is a v a 6.1.2 C(2e, 0s) Schemes ila b For this category, only Diffie-Hellman schemes are specified. Each party generates le fre ephemeral key pairs with the same domain parameters. The two parties exchange ephemeral e o public keys and then compute the shared secret. The secret keying material is derived using f c the shared secret (see Figure 7). h a rg e fro m U V : h ttp s ://d o i.o U’s Ephemeral Public Key rg /1 0 Exchange .6 0 ephemeral 2 V’s Ephemeral Public Key 8 public keys N/ IS T .S P .8 0 0 -5 Figure 7: C(2e, 0s) schemes: each party contributes only an ephemeral key pair 6 A r3 Assumptions: In order to execute a C(2e, 0s) key-establishment scheme in compliance with this Recommendation, the following assumptions shall be true. 1. Each party has an authentic copy of the same set of domain parameters, D. These parameters are either approved for use in the intended application (see Section 5.5.1). For FFC schemes, D = (p, q, g{, SEED, counter}); for ECC schemes, D = (q, FR, a, b{, SEED}, G, n, h). Furthermore, each party has obtained assurance of the validity of these domain parameters as specified in Section 5.5.2. 7 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 2. The parties have agreed upon an approved key-derivation method, as well as an approved algorithm to be used with that method (e.g., a hash function) and other associated parameters to be used (see Section 5.8). 3. When an identifier is used to label a party during the key-agreement process, it has been selected/assigned in accordance with the requirements of the protocol relying upon the use of the key-agreement scheme, and its value is known to both parties. 6.1.2.1 dhEphem, C(2e, 0s, FFC DH) Scheme This section describes the dhEphem scheme. Assurance of secure key establishment using this scheme can only be obtained when the assumptions in Section 6.1.2 are true. T With the exception of key derivation, the dhEphem scheme is “symmetric” in the actions of h is p parties U and V. Only the actions performed by party U are specified here; a specification of u b the actions performed by party V may be obtained by systematically replacing the letter “U” lic a by “V” (and vice versa) in the actions listed below. Note, however, that parties U and V must tio n use identical orderings of the bit strings that are input to the key-derivation method. is a v Party U shall execute the following actions to a) establish a shared secret value Z with party a ila V, and b) derive secret keying material from Z. b le fre Actions: Party U generates a shared secret and derives secret keying material as follows: e o 1. Generate an ephemeral key pair (r t ) from the domain parameters D as specified in f c U, U h Section 5.6.1.1. Send the public key t to party V. Receive an ephemeral public key a U rg t (purportedly) from party V. If t is not received, destroy the ephemeral private key e V V fro r U; then output an error indicator, and exit this process without performing the m : h remaining actions. sttp 2. Verify that t V is a valid ephemeral public key for the parameters D as specified in ://d Section 5.6.2.3. If assurance of public key validity cannot be obtained, destroy the o i.o ephemeral key r ; then output an error indicator, and exit this process without rg U /1 performing the remaining actions. 0 .6 0 3. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret Z from the set 2 N8 / of domain parameters D, party U’s ephemeral private key r U, and party V’s ephemeral IS public key t . Then destroy the ephemeral private key r . If the call to the FFC DH T V U .S primitive outputs an error indicator, destroy the results of all intermediate calculations P .8 used in the attempted computation of Z; then output an error indicator, and exit this 0 -50 process without performing the remaining actions. 6 A r3 4. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; then output an error indicator, and exit this process without performing the remaining action. 5. Destroy all copies of the shared secret Z and output the derived keying material. Output: The derived keying material or an error indicator. 7 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography dhEphem is summarized in Table 13. Table 13: dhEphem key-agreement scheme summary Party U Party V Domain (p, q, g{, SEED, counter}) (p, q, g{, SEED, counter}) parameters Static data N/A N/A Ephemeral private key r Ephemeral private key r U V Ephemeral data T h Ephemeral public key t Ephemeral public key t is U V p u b Compute Z by calling FFC DH Compute Z by calling FFC DH lic Computation a using r and t using r and t tio U V V U n is a 1. Compute 1. Compute v Derive secret a DerivedKeyingMaterial DerivedKeyingMaterial ila keying material b le 2. Destroy Z 2. Destroy Z fre e o f c 6.1.2.2 (Cofactor) Ephemeral Unified Model, C(2e, 0s, ECC CDH) Scheme h a rg This section describes the Ephemeral Unified Model scheme. Assurance of secure key e fro establishment using this scheme can only be obtained when the assumptions in Section 6.1.2 m : h are true. sttp With the exception of key derivation, the Ephemeral Unified Model scheme is “symmetric” ://d in the actions of parties U and V. Only the actions performed by party U are specified here; o i.o a specification of the actions performed by party V may be obtained by systematically rg /1 replacing the letter “U” by “V” (and vice versa) in the actions listed below. Note, however, 0 .6 that parties U and V must use identical orderings of the bit strings that are input to the key- 0 2 8 derivation method. N/ IS Party U shall execute the following actions to a) establish a shared secret value Z with party T .S V, and b) derive secret keying material from Z. P .8 0 Actions: Party U generates a shared secret and derives secret keying material as follows: 0 -5 6 A 1. Generate an ephemeral key pair (d e,U, Q e,U) from the domain parameters D as specified r3 in Section 5.6.1.2. Send the public key Q e,U to party V. Receive an ephemeral public key Q (purportedly) from party V. If Q is not received, destroy the ephemeral e,V e,V private key d ; then output an error indicator, and exit this process without e,U performing the remaining actions. 2. Verify that Q is a valid ephemeral public key for the parameters D as specified in e,V Section 5.6.2.3. If assurance of public key validity cannot be obtained, destroy the ephemeral private key d ; then output an error indicator, and exit this process e,U without performing the remaining actions. 8 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 3. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the set of domain parameters D, party U’s ephemeral private key d , and party V’s e,U ephemeral public key Q . Then destroy the ephemeral private key d . If the call to e,V e,U the ECC CDH primitive outputs an error indicator, destroy the results of all intermediate calculations used in the attempted computation of Z, then output an error indicator, and exit this process without performing the remaining actions. 4. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; then output an error indicator, and exit this process without performing the remaining action. T h is 5. Destroy all copies of the shared secret Z and output the derived keying material. p u b Output: The derived keying material or an error indicator. lic a tio The Ephemeral Unified Model is summarized in Table 14. n is a Table 14: Ephemeral unified model key-agreement scheme summary v a ila b Party U Party V le fre e Domain (q, FR, a, b{, SEED}, G, n, h) (q, FR, a, b{, SEED}, G, n, h) o f c parameters h a rg e Static data N/A N/A fro m : h Ephemeral data Ephemeral private key d e,U Ephemeral private key d e,V ttp s Ephemeral public key Q Ephemeral public key Q ://d e,U e,V o i.o Compute Z by calling ECC CDH Compute Z by calling ECC CDH rg Computation /1 0 using d e,U and Q e,V using d e,V and Q e,U .6 0 2 1. Compute 1. Compute 8 N/ Derive secret DerivedKeyingMaterial DerivedKeyingMaterial IS T keying material .S 2. Destroy Z 2. Destroy Z P .8 0 0 -5 6.1.2.3 Key Confirmation for C(2e, 0s) Schemes 6 A r3 In a C(2e, 0s) key-agreement scheme, none of the parties contributes a static key pair. Only ephemeral key pairs are used to derive the secret value Z. Without a trusted association with an identifier of either party, key confirmation cannot achieve the expected purposes. Therefore, in this Recommendation, key confirmation is not incorporated for the C(2e, 0s) key-agreement schemes. 8 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.2 Schemes Using One Ephemeral Key Pair, C(1e) Schemes This category consists of two subcategories that are determined by the use (or non-use) of a static key pair by each of the parties. Only party U generates an ephemeral key pair. In the first subcategory, both party U and party V use a static key pair, and party U also generates an ephemeral key pair (see Section 6.2.1). In the second subcategory, party U generates an ephemeral key pair, but uses no static key pair; party V uses only a static key pair (see Section 6.2.2). 6.2.1 C(1e, 2s) Schemes Figure_8 depicts a typical flow for a C(1e, 2s) scheme. For these schemes, party U uses both static and ephemeral private/public key pairs. Party V uses only a static private/public key T h pair. Party U and party V obtain each other’s static public keys in a trusted manner. Party U is p also sends its ephemeral public key to party V. A shared secret is generated by both parties u b lic using the available static and ephemeral keys. The secret keying material is derived using the a tio shared secret. n is a v a ila b U V le fre e o f c U’s Static Public Key h a Obtain static public rg e keys fro V’s Static Public Key m : h ttp s ://d U’s Ephemeral Public Key U sends an ephemeral o i.o public key rg /1 0 .6 0 2 8 N/ IS Figure 8: C(1e, 2s) schemes: party U contributes a static and an ephemeral key pair T .S while party V contributes only a static key pair P .8 0 Assumptions: In order to execute a C(1e, 2s) key-establishment scheme in compliance with 0 -5 this Recommendation, the following assumptions shall be true. 6 A r3 1. Each party has an authentic copy of the same set of domain parameters, D. These parameters are approved for use in the intended application (see Section 5.5.1). For FFC schemes, D = (p, q, g{, SEED, counter}); for ECC schemes, D = (q, FR, a, b{, SEED}, G, n, h). Furthermore, each party has obtained assurance of the validity of these domain parameters as specified in Section 5.5.2. 2. Each party has been designated as the owner of a static key pair that was generated as specified in Section 5.6.1 using the set of domain parameters, D. For FFC schemes, the static key pair is (x, y); for ECC schemes, the static key pair is (d , Q ). Each party s s 8 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography has obtained assurance of the validity of its own static public key as specified in Section 5.6.2.1.3. Each party has also obtained assurance of its possession of the correct value for its own private key as specified in Section 5.6.2.1.5. 3. The parties have agreed upon an approved key-derivation method, as well as an approved algorithm to be used with that method (e.g., a hash function) and other associated parameters to be used for key derivation (see Section 5.8). 4. If key confirmation is used, the parties have also agreed upon an approved MAC and associated parameters, including the lengths of MacKey and MacTag (see Section 5.9.3). If party V provides key confirmation to party U, the parties have agreed upon the form of Nonce , which should be a random nonce (see Section 5.4). V T 5. Prior to or during the key-agreement process, each party receives the other party’s h is p static public key in a trusted manner (e.g., from a certificate signed by a trusted CA u b or directly from the other party, who is trusted by the recipient). Each party has lic a obtained assurance of the validity of the other party’s static public key as specified in tio n Section 5.6.2.2.1. is a v 6. The recipient of a static public key has obtained assurance that its (claimed) owner is a ila (or was) in possession of the corresponding static private key, as specified in Section b le 5.6.2.2.3. fre e 7. When an identifier is used to label a party during the key-agreement process, that o f c identifier has a trusted association to that party’s static public key. (In other words, h a rg whenever both the identifier and static public key of one participant are employed in e fro the key-agreement process, they are associated in a manner that is trusted by the other m participant.) When an identifier is used to label a party during the key-agreement : h process, both parties are aware of the particular identifier employed for that purpose. ttp s ://d 6.2.1.1 dhHybridOneFlow, C(1e, 2s, FFC DH) Scheme o i.o rg This section describes the dhHybridOneFlow scheme. Assurance of secure key establishment /1 0 using this scheme can only be obtained when the assumptions in Section 6.2.1 are true. In .6 0 particular, it is assumed that party U has obtained the static public key y of party V, and 2 V 8 N/ party V has obtained the static public key y U of party U. IS T In this scheme, each party has different actions, which are presented separately below. .S P However, note that parties U and V must use identical orderings of the bit strings that are .8 0 input to the key-derivation method. 0 -5 6 A r3 Party U shall execute the following actions to a) establish a shared secret value Z with party V, and b) derive secret keying material from Z. Actions: Party U generates a shared secret and derives secret keying material as follows: 1. Generate an ephemeral key pair (r , t ) from the domain parameters D as specified U U in Section 5.6.1.1. Send the public key t to party V. U 2. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret Z from the set s of domain parameters D, party U’s static private key x , and party V’s static public U 8 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography key y . If the call to the FFC DH primitive outputs an error indicator, destroy the V ephemeral private key r , and destroy the results of all intermediate calculations used U in the attempted computation of Z ; then output an error indicator, and exit this s process without performing the remaining actions. 3. Use the FFC DH primitive to derive a shared secret Z from the set of domain e parameters D, party U’s ephemeral private key r and party V’s static public key y . U, V If this call to the FFC DH primitive outputs an error indicator, destroy Z and the s ephemeral private key r , and destroy the results of all intermediate calculations used U in the attempted computation of Z ; then output an error indicator, and exit this e process without performing the remaining actions. 4. Compute the shared secret Z = Z || Z . Destroy Z and Z . T e s e s h is p 5. Use the agreed-upon key-derivation method to derive secret keying material with the u b specified length from the shared secret value Z and other input (see Section 5.8). If lic a the key-derivation method outputs an error indicator, destroy all copies of Z and the tio n ephemeral private key r ; then output an error indicator, and exit this process without is U a performing the remaining actions. v a ila b 6. Destroy r U and all copies of the shared secret Z. le fre 7. Output the derived keying material. e o Output: The derived keying material or an error indicator. f c h a rg Party V shall execute the following actions to a) establish a shared secret value Z with party e fro U, and b) derive secret keying material from Z. m : h Actions: Party V derives secret keying material as follows: ttp s 1. Receive an ephemeral public key t (purportedly) from party U. If t is not received, ://d o then output an error indicator, and eU xit this process without performiU ng the remaining i.o rg actions. /1 0 2. Verify that t is a valid ephemeral public key for the parameters D as specified in .6 U 0 2 Section 5.6.2.3. If assurance of public key validity cannot be obtained, then output an 8 N/ error indicator, and exit this process without performing the remaining actions. IS T .S 3. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret value Z s from P .8 the set of domain parameters D, party V’s static private key x V, and party U’s static 0 0 public key y . If the call to the FFC DH primitive outputs an error indicator, destroy -5 U 6 the results of all intermediate calculations used in the attempted computation of Z ; A s r3 then output an error indicator, and exit this process without performing the remaining actions. 4. Use the FFC DH primitive to derive a shared secret Z from the set of domain e parameters D, party V’s static private key x , and party U’s ephemeral public key t . V U If this call to the FFC DH primitive outputs an error indicator, destroy Z , and destroy s the results of all intermediate calculations used in the attempted computation of Z ; e then output an error indicator, and exit this process without performing the remaining actions. 8 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 5. Compute the shared secret Z = Z || Z . Destroy Z and Z . e s e s 6. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; output an error indicator and exit this process without performing the remaining action. 7. Destroy all copies of the shared secret Z and output the derived keying material. Output: The derived keying material or an error indicator. Note: Key confirmation can be incorporated into this scheme. See Section 6.2.1.5 for details. T dhHybridOneFlow is summarized in Table 15. h is p Table 15: dhHybridOneFlow key-agreement scheme summary u b lic a tio Party U Party V n is a Domain (p, q, g{, SEED, counter}) (p, q, g{, SEED, counter}) v a ila parameters b le fre Static private key x U Static private key x V e Static data o f c Static public key y U Static public key y V h a rg Ephemeral private key r N/A e U fro m Ephemeral data Ephemeral public key t U : h ttp 1. Compute Z by calling FFC 1. Compute Z by calling FFC s s s ://d DH using x and y DH using x and y o U V V U i.o rg Computation 2. Compute Z e by calling FFC 2. Compute Z e by calling FFC /1 DH using r and y DH using x and t 0 .6 U V V U 0 2 8 3. Compute Z = Z e || Z s 3. Compute Z = Z e || Z s N/ IS T 1. Compute 1. Compute .S Derive secret P DerivedKeyingMaterial DerivedKeyingMaterial .8 keying material 0 0 2. Destroy Z 2. Destroy Z -5 6 A r3 6.2.1.2 (Cofactor) One-Pass Unified Model, C(1e, 2s, ECC CDH) Scheme This section describes the One-Pass Unified Model scheme. Assurance of secure key establishment using this scheme can only be obtained when the assumptions in Section 6.2.1 are true. In particular, it is assumed that party U has obtained the static public key Q of s,V party V, and party V has obtained the static public key Q s,U of party U. 8 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography In this scheme, each party has different actions, which are presented separately below. However, note that parties U and V must use identical orderings of the bit strings that are input to the key-derivation method. Party U shall execute the following actions to a) establish a shared secret value Z with party V, and b) derive secret keying material from Z. Actions: Party U generates a shared secret and derives secret keying material as follows: 1. Generate an ephemeral key pair (d ,Q ) from the domain parameters D as specified e,U e,U in Section 5.6.1.2. Send the public key Q to V. e,U 2. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the s T set of domain parameters D, party U’s static private key d , and party V’s static h s,U is public key Q . If the call to the ECC CDH primitive outputs an error indicator, p s,V u b lic a d cae ls ct uro lay t it oh ne s e up sh ee dm ine r ta hl e p ar ti tv ea mte p tk ee dy c od me,U p, ua tn ad ti od ne s ot fr o Zy s; t th he e nr e os uu tl pts u to af n a ell r ri on rt e inrm die cd ai ta ot re , tio n and exit this process without performing the remaining actions. is a 3. Use the ECC CDH primitive to derive a shared secret Z , from the set of domain v e a ila parameters D, party U’s ephemeral private key d e,U, and party V’s static public key b le fre Q ths e,V . e pIf h t eh mis e rc aa ll l p t ro iv t ah te e E keC yC d CD , aH n dp r di em si tt ri ov ye to hu et p reu st us la tsn o e fr r ao llr ii nn td ei rc ma eto dr i, a d tee s ct ar lo cy u lZ as t ia on nd s e e,U o used in the attempted computation of Z ; then output an error indicator, and exit this f c e h process without performing the remaining actions. a rg e 4. Compute the shared secret Z = Z || Z . Destroy Z and Z . fro e s e s m 5. Use the agreed-upon key-derivation method to derive secret keying material with the : h ttp specified length from the shared secret value Z and other input (see Section 5.8). If s ://d the key-derivation method outputs an error indicator, destroy all copies of Z and the o ephemeral private key d ; then output an error indicator, and exit this process i.o e,U rg without performing the remaining actions. /1 0 .6 6. Destroy d e,U and all copies of the shared secret Z. 0 2 8 7. Output the derived keying material. N/ IS T Output: The derived keying material or an error indicator. .S P .8 Party V shall execute the following actions to a) establish a shared secret value Z with party 0 0 -5 U, and b) derive secret keying material from Z. 6 A r3 Actions: Party V derives secret keying material as follows: 1. Receive an ephemeral public key Q (purportedly) from party U. If Q is not e,U e,U received, then output an error indicator, and exit this process without performing the remaining actions. 2. Verify that Q is a valid ephemeral public key for the parameters D as specified in e,U Section 5.6.2.3. If assurance of public key validity cannot be obtained, then output an error indicator, and exit this process without performing the remaining actions. 8 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 3. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the s set of domain parameters D, party V’s static private key d , and party U’s static s,V public key Q . If the call to the ECC CDH primitive outputs an error indicator, s,U destroy the results of all intermediate calculations used in the attempted computation of Z ; then output an error indicator, and exit this process without performing the s remaining actions. 4. Use the ECC CDH primitive to derive a shared secret Z from the set of domain e parameters D, party V’s static private key d , and party U’s ephemeral public key s,V Q .If this call to the ECC CDH primitive outputs an error indicator, destroy Z , and e,U s destroy the results of all intermediate calculations used in the attempted computation of Z ; then output an error indicator, and exit this process without performing the e T h remaining actions. is p u b 5. Compute the shared secret Z = Z e || Z s. Destroy Z e and Z s. lic a 6. Use the agreed-upon key-derivation method to derive secret keying material with the tio n specified length from the shared secret value Z and other input (see Section 5.8). If is a the key-derivation method outputs an error indicator, destroy all copies of Z; then v a output an error indicator, and exit this process without performing the remaining ila b action. le fre 7. Destroy all copies of the shared secret Z and output the derived keying material. e o f c Output: The derived keying material or an error indicator. h a rg Note: Key confirmation can be incorporated into this scheme. See Section 6.2.1.5 for e fro details. m : h The One-Pass Unified Model is summarized in Table 16. ttp s ://d Table 16: One-pass unified model key-agreement scheme summary o i.o rg Party U Party V /1 0 .6 Domain (q, FR, a, b{, SEED}, G, n, h) (q, FR, a, b{, SEED}, G, n, h) 0 2 8 parameters N/ IS T .S Static private key d s,U Static private key d s,V P Static data .8 Static public key Q Static public key Q 0 s,U s,V 0 -5 6 A r3 Ephemeral data Ephemeral private key d e,U N/A Ephemeral public key Q e,U 1. Compute Z by calling ECC 1. Compute Z by calling ECC DH s s CDH using d and Q using d and Q s,U s,V s,V s,U Computation 2. Compute Z by calling ECC 2. Compute Z by calling ECC DH e e CDH using d and Q using d and Q e,U s,V s,V e,U 8 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Party U Party V 3. Compute Z = Z || Z 3. Compute Z = Z || Z e s e s 1. Compute 1. Compute Derive secret DerivedKeyingMaterial DerivedKeyingMaterial keying material 2. Destroy Z 2. Destroy Z 6.2.1.3 MQV1, C(1e, 2s, FFC MQV) Scheme This section describes the MQV1 scheme. Assurance of secure key establishment using this T h is scheme can only be obtained when the assumptions in Section 6.2.1 are true. In particular, it p u b is assumed that party U has obtained the static public key y V of party V, and party V has lic a obtained the static public key y U of party U. tio n In this scheme, each party has different actions, which are presented separately below. is a However, note that parties U and V must use identical orderings of the bit strings that are v a input to the key-derivation method. ila b le Party U shall execute the following actions in order to a) establish a shared secret value Z fre with party V, and b) derive secret keying material from Z. e o f c Actions: Party U generates a shared secret and derives secret keying material as follows: h a rg e 1. Generate an ephemeral key pair (r U, t U) from the domain parameters D as specified in fro Section 5.6.1.1. Send the public key t U to V. m : h 2. Use the MQV1 form of the FFC MQV primitive in Section 5.7.2.1.2 to derive a ttp shared secret Z from the set of domain parameters D, party U’s static private key x , s U ://d o party V’s static public key y V, party U’s ephemeral private key r U, party U’s i.o ephemeral public key t U, and (for a second time) party V’s static public key y V. If the rg /1 call to the FFC MQV primitive outputs an error indicator, destroy the ephemeral 0 .6 private key r U, and destroy the results of all intermediate calculations used in the 0 2 attempted computation of Z; then output an error indicator, and exit this process 8 N/ without performing the remaining actions. IS T .S 3. Use the agreed-upon key-derivation method to derive secret keying material with the P .8 specified length from the shared secret value Z and other input (see Section 5.8). If 0 0 the key-derivation method outputs an error indicator, destroy all copies of Z and the -5 6 A ephemeral private key r U; then output an error indicator, and exit this process without r3 performing the remaining actions. 4. Destroy r and all copies of the shared secret Z. U 5. Output the derived keying material. Output: The derived keying material or an error indicator. Party V shall execute the following actions to a) establish a shared secret value Z with party U, and b) derive secret keying material from Z. 8 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Actions: Party V derives secret keying material as follows: 1. Receive an ephemeral public key t (purportedly) from party U. If t is not received, U U then output an error indicator, and exit this process without performing the remaining actions. 2. Verify that t is a valid ephemeral public key for the parameters D as specified in U Section 5.6.2.3. If assurance of public key validity cannot be obtained, then output an error indicator, and exit without performing the remaining actions. 3. Use the MQV1 form of the FFC MQV primitive in Section 5.7.2.1.2 to derive a shared secret Z from the set of domain parameters D, party V’s static private key x , V party U’s static public key y , party V’s static private key x (for a second time), party U V T V’s static public key y , and party U’s ephemeral public key t If the call to the FFC h V U. is p MQV primitive outputs an error indicator, destroy the results of all intermediate u b calculations used in the attempted computation of Z; then output an error indicator, lic a and exit this process without performing the remaining actions. tio n is 4. Use the agreed-upon key-derivation method to derive secret keying material with the a v specified length from the shared secret value Z and other input (see Section 5.8). If a ila the key-derivation method outputs an error indicator, destroy all copies of Z; then b le output an error indicator, and exit this process without performing the remaining fre action. e o f c 5. Destroy all copies of the shared secret Z and output DerivedKeyingMaterial. h a rg Output: The bit string DerivedKeyingMaterial of length L bits or an error indicator. e fro Note: Key confirmation can be incorporated into this scheme. See Section 6.2.1.5 for m : h details. ttp s ://d MQV1 is summarized in Table 17. o i.o Table 17: MQV1 key-agreement scheme summary. rg /1 0 .6 Party U Party V 0 2 8 N/ Domain (p, q, g{, SEED, counter}) (p, q, g{, SEED, counter}) IS T parameters .S P .8 Static private key x Static private key x 0 U V 0 Static data -5 6 A Static public key y U Static public key y V r3 Ephemeral private key r N/A U Ephemeral data Ephemeral public key t U C Compute Z by calling FFC MQV Compute Z by calling FFC MQV Computation using x , y , r , t , and y (again) using x , y , x (again), y , and t U V U U V V U V V U 8 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. Compute 1. Compute Derive secret DerivedKeyingMaterial DerivedKeyingMaterial keying material 2. Destroy Z 2. Destroy Z 6.2.1.4 One-Pass MQV, C(1e, 2s, ECC MQV) Scheme This section describes the One-Pass MQV scheme. Assurance of secure key establishment using this scheme can only be obtained when the assumptions in Section 6.2.1 are true. In particular, it is assumed that party U has obtained the static public key Q of party V, and s,V party V has obtained the static public key Q of party U. s,U T In this scheme, each party has different actions, which are presented separately below. h is p However, note that party U and party V must use identical orderings of the bit strings that u b are input to the key-derivation method. lic a tio Party U shall execute the following actions to a) establish a shared secret value Z with party n is V, and b) derive secret keying material from Z. a v a Actions: Party U generates a shared secret and derives secret keying material as follows: ila b le fre e 1. G ine Sn ee cra tit oe n a n 5 .e 6p .1h .e 2m . Ser ea nl d k te hy e p pa uir b ( lid ce ,U k, e Q ye , QU) e ,f Ur o tom p t ah re ty d Vom . ain parameters D as specified o f c 2. Use the One-Pass MQV form of the ECC MQV primitive in Section 5.7.2.3.2 to h a derive a shared secret value Z from the set of domain parameters D, party U’s static rg e private key d , party V’s static public key Q , party U’s ephemeral private key d , fro party U’s ephs, eU meral public key Q , and (fos r,V a second time) party V’s static pube l, iU c m e,U : h ttp k epey h eQ ms, eV r. aI lf t ph re iv c aa tell t ko e yth e d EC , C an M d Q deV st rp or yim ti ht eiv e re o suu lt tp su t os f a an l le r inro ter ri mnd ei dc ia at to er , c d ae lcs utr lo aty i oth ne s s e,U ://d used in the attempted computation of Z; then output an error indicator, and exit this o i.o process without performing the remaining actions. rg /1 3. Use the agreed-upon key-derivation method to derive secret keying material with the 0 .6 0 specified length from the shared secret value Z and other input (see Section 5.8). If 2 8 the key-derivation method outputs an error indicator, destroy all copies of Z and the N/ IS ephemeral private key d ; then output an error indicator, and exit this process T e,U .S without performing the remaining actions. P .8 0 4. Destroy d and all copies of the shared secret Z. 0 e,U -5 6 5. Output the derived keying material. A r3 Output: The derived keying material or an error indicator. Party V shall execute the following actions to a) establish a shared secret value Z with party U, and b) derive shared secret keying material from Z. Actions: Party V derives secret keying material as follows: 9 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. Receive an ephemeral public key Q (purportedly) from party U. If Q is not e,U e,U received, then output an error indicator, and exit this process without performing the remaining actions. 2. Verify that Q is a valid ephemeral public key for the parameters D as specified in e,U Section 5.6.2.3.2 or 5.6.2.3.3. If assurance of public key validity cannot be obtained, then output an error indicator, and exit without performing the remaining actions. 3. Use the One-Pass MQV form of the ECC MQV primitive in Section 5.7.2.3.2 to derive a shared secret value Z from the set of domain parameters D, party V’s static private key d , party U’s static public key Q , party V’s static private key d (for a s,V s,U s,V second time), party V’s static public key Q , and party U’s ephemeral public key s,V Q . If the call to the ECC MQV primitive outputs an error indicator, destroy the T e,U h is results of all intermediate calculations used in the attempted computation of Z; then p u output an error indicator, and exit this process without performing the remaining b lic actions. a tio n 4. Use the agreed-upon key-derivation method to derive secret keying material with the is a specified length from the shared secret value Z and other input (see Section 5.8). If v a the key-derivation method outputs an error indicator, destroy all copies of Z; then ila b output an error indicator, and exit this process without performing the remaining le fre action. e o 5. Destroy all copies of the shared secret Z and output the derived keying material. f c h a rg Output: The derived keying material or an error indicator. e fro Note: Key confirmation can be incorporated into this scheme. See Section 6.2.1.5 for m : h details. ttp The One-Pass MQV scheme is summarized in Table 18. s ://d o Table 18: One-pass MQV model key-agreement scheme summary i.o rg /1 Party U Party V 0 .6 0 2 8 Domain (q, FR, a, b{, SEED}, G, n, h) (q, FR, a, b{, SEED}, G, n, h) N/ IS parameters T .S P .8 Static private key d s,U Static private key d s,V 0 Static data 0 -5 Static public key Q s,U Static public key Q s,V 6 A r3 Ephemeral data Ephemeral private key d e,U N/A Ephemeral public key Q e,U Compute Z by calling ECC MQV Compute Z by calling ECC MQV Computation using d s,U, Q s,V, d e,U, Q e,U, and Q s,V using d s,V, Q s,U, d s,V (again), Q s,V, and (again) Q e,U 9 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Party U Party V 1. Compute 1. Compute Derive secret DerivedKeyingMaterial DerivedKeyingMaterial Keying material 2. Destroy Z 2. Destroy Z 6.2.1.5 Incorporating Key Confirmation into a C(1e, 2s) Scheme The subsections that follow illustrate how to incorporate key confirmation (as described in Section 5.9) into the C(1e, 2s) key-agreement schemes described above. Note that party V cannot act as a key-confirmation recipient unless a nonce (Nonce ) is provided by party V to T V h party U and is used (in addition to the shared secret Z) as input to the key-derivation method is p employed by the scheme. This would be accomplished by including (a copy of) Nonce in u V b lic the OtherInput provided to the KDM, as part of the FixedInfo (see Section 5.8), in addition a tio to using (a copy of) Nonce V as the EphemData V employed in the MacTag computations for n is key confirmation. a v a The flow depictions separate the key-establishment flow from the key-confirmation flow. ila b The depictions and accompanying discussions presume that the assumptions of the scheme le fre have been satisfied, that the key-agreement transaction has proceeded successfully through e key derivation, and that the received MacTags are successfully verified as specified in o f c Section 5.2.2. h a rg e 6.2.1.5.1 C(1e, 2s) Scheme with Unilateral Key Confirmation Provided by Party U to fro Party V m : h Figure_9 depicts a typical flow for a C(1e, 2s) scheme with unilateral key confirmation from sttp party U to party V. In this situation, party U and party V assume the roles of key-confirmation ://d provider and recipient, respectively. Since party V does not contribute an ephemeral public o i.o key during the key-agreement process, a nonce (Nonce ) shall be provided by party V to rg V /1 party U and used (in addition to the shared secret Z) as input to the key-derivation method 0 .6 employed by the scheme. Nonce is also used as EphemData during MacTag computations. 0 V V 2 The successful completion of the key-confirmation process provides party V with assurance 8 N/ that party U has derived the same secret Z value. If Nonce is a random nonce, then party V IS V T also obtains assurance that party U has actively participated in the process; see Section 5.4 .S P for a discussion of the length and security strength required for the nonce. .8 0 0 -5 6 A r3 9 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography U V U’s Static Public Key Obtain static public keys V’s Static Public Key U’s Ephemeral Public Key U sends an ephemeral public key T h is p Nonce V u b lic V sends a nonce a tio MacTag n U is U’s key a v confirmation a ila b le fre e o f c Figure 9: C(1e, 2s) scheme with unilateral key confirmation from party U to party V h a rg e fro To provide (and receive) key confirmation (as described in Section 5.9.1), party U (and party m V) set : h sttp EphemData U = EphemPubKey U, and EphemData V = Nonce V. ://d o i.o rg Party U provides MacTag U to party V (as specified in Section 5.9.1, with P = U and R = V), /1 where MacTag U is computed (as specified in Section 5.2.1) using 0 .6 0 MacData = “KC_1_U” || ID || ID || EphemPubKey || Nonce {|| Text }. 2 U U V U V U 8 N/ Party V (the key-confirmation recipient) uses the same format for MacData to compute its IS U T own version of MacTag and then verifies that the newly computed MacTag matches the .S U P value provided by party U. .8 0 0 Party U shall destroy its copy of MacKey immediately after computing MacTag . Party V -5 U 6 shall immediately destroy its copy of MacKey after determining whether or not the received A r3 and newly computed MacTag values match. If they do not match, then party V shall also U destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify party U that MacTag could not be verified. In this case, party U shall also destroy the U KeyData portion of the DerivedKeyingMaterial. 9 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.2.1.5.2 C(1e, 2s) Scheme with Unilateral Key Confirmation Provided by Party V to Party U Figure_10 depicts a typical flow for a C(1e, 2s) scheme with unilateral key confirmation from party V to party U. In this scenario, party V and party U assume the roles of key- confirmation provider and recipient, respectively. The successful completion of the key- confirmation process provides party U with a) assurance that party V has derived the same secret Z value, and b) assurance that party V has actively participated in the process. U V T h is p U’s Static Public Key u b Obtain static public lic a keys tio V’s Static Public Key n is a v a ila U’s Ephemeral Public Key U sends an ephemeral b le public key fre e o MacTag V f c V’s key- h a confirmation rg e fro m : h ttp Figure 10: C(1e, 2s) scheme with unilateral key confirmation from party V to party U s ://d o i.o To provide (and receive) key confirmation (as described in Section 5.9.1), both parties set rg /1 EphemData = Null, and EphemData = EphemPubKey . 0 V U U .6 0 2 Party V provides MacTag to party U (as specified in Section 5.9.1, with P = V and R = U), 8 V N/ where MacTag is computed (as specified in Section 5.2.1) using IS V T .S P MacData V = “KC_1_V” || ID V || ID U || Null || EphemPubKey U {|| Text V}. .8 0 Party U (the key-confirmation recipient) uses the same format for MacData to compute its 0 V -5 own version of MacTag , and then verifies that the newly computed MacTag matches the 6 V A r3 value provided by party V. Party V shall destroy its copy of MacKey immediately after computing MacTag . Party U V shall immediately destroy its copy of MacKey after determining whether or not the received and newly computed MacTag values match. If they do not match, then party U shall also V destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify party V that MacTag could not be verified. In this case, party V shall also destroy the V KeyData portion of the DerivedKeyingMaterial. 9 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.2.1.5.3 C(1e, 2s) Scheme with Bilateral Key Confirmation Figure_11 depicts a typical flow for a C(1e, 2s) scheme with bilateral key confirmation. In this method, party U and party V assume the roles of both the provider and the recipient to obtain bilateral key confirmation. Since party V does not contribute an ephemeral public key during the key-agreement process, a nonce (Nonce ) shall be provided by party V to party U V and used (in addition to the shared secret Z) as input to the key-derivation method employed by the scheme. Nonce is also used as the EphemData during MacTag computations. The V V successful completion of the key-confirmation process provides each party with assurance that the other party has derived the same secret Z value. Party U obtains assurance that party V has actively participated in the process; if Nonce is a random nonce, then party V also V obtains assurance that party U has actively participated in the process; see Section 5.4 for a T discussion of the length and security strength required for the nonce. h is p u b lic a U V tio n is a v U’s Static Public Key a Obtain static public ila b keys le fre V’s Static Public Key e o f c U sends an ephemeral h a U’s Ephemeral Public Key rg public key e fro m : h Nonce V, MacTag V V’s key confirmation ttp with a nonce s ://d MacTag U o i.o U’s key confirmation rg /1 0 .6 0 2 8 N/ Figure 11: C(1e, 2s) scheme with bilateral key confirmation IS T To provide bilateral key confirmation (as described in Section 5.9.2), party U and party V .S P exchange and verify MacTags that have been computed (as specified in Sections 5.2.1) using .8 0 0 EphemData = EphemPubKey and EphemData = Nonce . -5 U U V V 6 A r3 Party V provides MacTag V to party U (as specified in Sections 5.9.1 and 5.9.2, with P = V and R = U); MacTag is computed by party V (and verified by U) using V MacData = “KC_2_V” || ID || ID || Nonce || EphemPubKey {|| Text }. V V U V U V Party U provides MacTag to party V (as specified in Sections 5.9.1 and 5.9.2, with P = U U and R = V); MacTag is computed by party U (and verified by party V) using U MacData = “KC_2_U” || ID || ID || EphemPubKey || Nonce {|| Text }. U U V U V U 9 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Note that in Figure_11 party V’s nonce (Nonce ) and the MacTag (MacTag ) are depicted as V V being sent in the same message (to reduce the number of passes in the combined key- agreement/key-confirmation process). They may also be sent separately (as long as Nonce V is sent before the MacTags are exchanged). The MacTag and MacTag can be sent in any V U order, as long as Nonce is available to generate and verify both MAC tags. V Each party shall destroy its copy of MacKey immediately after 1) using it to generate a MAC tag to be sent to the other party and 2) determining whether or not the MAC tag received from the other party matches the MAC tag that it computed. However, if either party is not able to verify the received MAC tag, that party shall also destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify the other party of the failure. In this case, the other party shall destroy both the MacKey (if it has not already done so) as well as T h the KeyData portion of the DerivedKeyingMaterial. is p u b 6.2.2 C(1e, 1s) Schemes lic a tio For each of the C(1e, 1s) schemes, party U generates an ephemeral key pair, but uses no n is static key pair; party V has only a static key pair. Party U obtains party V’s static public key a in a trusted manner (for example, from a certificate signed by a trusted CA or directly from v a ila party V, who is trusted) and sends its ephemeral public key to party V. The parties compute b le a shared secret using their private keys and the other party’s public key. Each party uses the fre shared secret to derive secret keying material (see Figure 12). e o f c h a rg e fro U V m : h ttp s V’s Static Public Key U obtains V’s static ://d public key o i.o rg /1 0 U’s Ephemeral Public Key .6 U sends an ephemeral 0 2 public key 8 N/ IS T .S P .8 0 0 -5 Figure 12: C(1e, 1s) schemes: party U contributes an ephemeral key pair, and party V 6 A r3 contributes a static key pair Assumptions: In order to execute a C(1e, 1s) key-establishment scheme in compliance with this Recommendation, the following assumptions shall be true. 1. Each party has an authentic copy of the same set of domain parameters, D. These parameters are either approved for use in the intended application (see Section 5.5.1). For FFC schemes, D = (p, q, g{, SEED, counter}); for ECC schemes, D = (q, FR, a, b{, SEED}, G, n, h). Furthermore, each party has obtained assurance of the validity of these domain parameters as specified in Section 5.5.2. 9 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 2. Party V has been designated as the owner of a static key pair that was generated as specified in Section 5.6.1 using the set of domain parameters, D. For FFC schemes, the static key pair is (x, y); for ECC schemes, the static key pair is (d , Q ). Party V s s has obtained assurance of the validity of its own static public key as specified in Section 5.6.2.1. Party V has obtained assurance of its possession of the correct value of its own private key as specified in Section 5.6.2.1.5. 3. The parties have agreed upon an approved key-derivation method, as well as an approved algorithm to be used with that method (e.g., a hash function) and other associated parameters to be used (see Section 5.8). 4. If key confirmation is used, the parties have also agreed upon an approved MAC and associated parameters, including the lengths of MacKey and MacTag (see Section T h is 5.9.3). p u b 5. Prior to or during the key-agreement process, party U receives party V’s static public lic a key in a trusted manner (e.g., from a certificate signed by a trusted CA or directly tio n from party V, who is trusted by the recipient). Party U has obtained assurance of the is a validity of party V’s static public key as specified in Section 5.6.2.2.1. v a ila 6. When an identifier is used to label either party during the key-agreement process, b le both parties are aware of the identifier employed for that purpose. In particular, when fre an identifier is used to label party V during the key-agreement process, that identifier e o has a trusted association to party V’s static public key. (In other words, whenever f c h both the identifier and static public key of one participant are employed in the key- a rg agreement process, they are associated in a manner that is trusted by the other e fro participant.) When an identifier is used to label party U during the key-agreement m : h process, it has been selected/assigned in accordance with the requirements of the ttp protocol relying upon the use of the key-agreement scheme. s ://d The following is an assumption for using the derived keying material for purposes beyond o i.o the C(1e,1s) scheme itself. rg /1 0 Party U has obtained assurance that party V is (or was) in possession of the .6 0 appropriate static private key, as specified in Section 5.6.2.2.3. 2 8 N/ IS 6.2.2.1 dhOneFlow, C(1e, 1s, FFC DH) Scheme T .S P This section describes the dhOneFlow scheme. Assurance of secure key establishment using .8 0 this scheme can only be obtained when the assumptions in Section 6.2.2 are true. In 0 -5 6 A particular, it is assumed that party U has obtained the static public key y V of party V. r3 In this scheme, each party has different actions, which are presented separately below. However, note that parties U and V must use identical orderings of the bit strings that are input to the key-derivation method. Party U shall execute the following actions to a) establish a shared secret value Z with party V, and b) derive secret keying material from Z. Actions: Party U generates a shared secret and derives secret keying material as follows: 9 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 1. Generate an ephemeral key pair (r t ) from the domain parameters D as specified in U, U Section 5.6.1.1. Send the public key t to party V. U 2. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret Z from the set of domain parameters D, party U’s ephemeral private key r , and party V’s static U public key y . If the call to the FFC DH primitive outputs an error indicator, destroy V the ephemeral private key r , and destroy the results of all intermediate calculations U used in the attempted computation of Z; then output an error indicator, and exit this process without performing the remaining actions. 3. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z and the T h is p ephemeral private key r U; then output an error indicator, and exit this process without u performing the remaining actions. b lic a 4. Destroy r and all copies of the shared secret Z. tio U n is 5. Output the derived keying material. a v a Output: The derived keying material or an error indicator. ila b le fre Party V shall execute the following actions to a) establish a shared secret value Z with party e U, and b) derive secret keying material from Z. o f c h Actions: Party V derives secret keying material as follows: a rg e 1. Receive an ephemeral public key t (purportedly) from party U. If t is not received, fro then output an error indicator, and eU xit this process without performiU ng the remaining m : h actions. ttp s 2. Verify that t is a valid ephemeral public key for the parameters D as specified in ://d o Section 5.6.2U .3 . If assurance of public key validity cannot be obtained, then output an i.o rg error indicator, and exit this process without performing the remaining actions. /1 0 3. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret Z from the set .6 0 2 8 of domain parameters D, party V’s static private key x V, and party U’s ephemeral N IS/ public key t U. If the call to the FFC DH primitive outputs an error indicator, destroy T the results of all intermediate calculations used in the attempted computation of Z; .S P then output an error indicator, and exit this process without performing the remaining .8 0 actions. 0 -5 6 4. Use the agreed-upon key-derivation method to derive secret keying material with the A r3 specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; then output an error indicator, and exit this process without performing the remaining action. 5. Destroy all copies of the shared secret Z and output the derived keying material. Output: The derived keying material or an error indicator. 9 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Note: Key confirmation can be incorporated into this scheme. See Section 6.2.2.3 for details. dhOneFlow is summarized in Table 19. Table 19: dhOneFlow key-agreement scheme summary Party U Party V Domain (p, q, g{, SEED, counter}) (p, q, g{, SEED, counter}) parameters N/A Static private key x T Static data V h is Static public key y p V u b lic Ephemeral private key r N/A a U tio Ephemeral data n Ephemeral public key t is U a v a Compute Z by calling FFC DH Compute Z by calling FFC DH using ila Computation b using r and y x and t le U V V U fre e 1. Compute 1. Compute o f c Derive secret DerivedKeyingMaterial DerivedKeyingMaterial h a material rg 2. Destroy Z 2. Destroy Z e fro m : h 6.2.2.2 (Cofactor) One-Pass Diffie-Hellman, C(1e, 1s, ECC CDH) Scheme ttp s ://d This section describes the One-Pass Diffie-Hellman scheme. Assurance of secure key o establishment using this scheme can only be obtained when the assumptions in Section 6.2.2 i.o rg are true. In particular, it is assumed that party U has obtained the static public key Q s,V of /1 0 party V. .6 0 2 In this scheme, each party has different actions, which are presented separately below. 8 N/ However, note that parties U and V must use identical orderings of the bit strings that are IS T input to the key-derivation method. .S P .8 Party U shall execute the following actions to a) establish a shared secret value Z with party 0 0 V, and b) derive secret keying material from Z. -5 6 A r3 Actions: Party U generates a shared secret and derives secret keying material as follows: 1. Generate an ephemeral key pair (d ,Q ) from the domain parameters D as specified e,U e,U in Section 5.6.1.2. Send the public key Q to party V. e,U 2. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the set of domain parameters D, party U’s ephemeral private key d , and party V’s static e,U public key Q . If this call to the ECC CDH primitive outputs an error indicator, s,V destroy the ephemeral private key d , and destroy the results of all intermediate e,U 9 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography calculations used in the attempted computation of Z; then output an error indicator, and exit this process without performing the remaining actions. 3. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z and other input (see Section 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z and the ephemeral private key d ; then output an error indicator, and exit this process e,U without performing the remaining actions. 4. Destroy d and all copies of the shared secret Z. e,U 5. Output the derived keying material. Output: The derived keying material or an error indicator. T h is p Party V shall execute the following actions to a) establish a shared secret value Z with party u b lic U, and b) derive secret keying material from Z. a tio Actions: Party V derives secret keying material as follows: n is a 1. Receive an ephemeral public key Q (purportedly) from party U. If Q is not v e,U e,U a ila received, then output an error indicator, and exit this process without performing the b le remaining actions. fre e o 2. Verify that Q e,U is a valid ephemeral public key for the parameters D as specified in f c Section 5.6.2.3. If assurance of public key validity cannot be obtained, then output an h a error indicator, and exit without performing the remaining actions. rg e fro 3. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the m set of domain parameters D, party V’s static private key d , and party U’s ephemeral : h ttp public key Q e,U. If this call to the ECC CDH primitive s o,V utputs an error indicator, s destroy the results of all intermediate calculations used in the attempted computation ://d o of Z; then output an error indicator, and exit this process without performing the i.o rg remaining actions. /1 0 4. Use the agreed-upon key-derivation method to derive secret keying material with the .6 0 2 specified length from the shared secret value Z and other input (see Section 5.8). If 8 N/ the key-derivation method outputs an error indicator, destroy all copies of Z; then IS T output an error indicator, and exit this process without performing the remaining .S P action. .8 0 0 6. Destroy all copies of the shared secret Z and output the derived keying material. -5 6 A Output: The derived keying material or an error indicator. r3 Note: Key confirmation can be incorporated into this scheme. See Section 6.2.2.3 for details. The One-Pass Diffie-Hellman is summarized in Table 20. 10 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Table 20: One-pass Diffie-Hellman key-agreement scheme summary Party U Party V Domain (q, FR, a, b{, SEED}, G, n, h) (q, FR, a, b{, SEED}, G, n, h) parameters N/A Static private key d s,V Static data Static public key Q s,V Ephemeral data Ephemeral private key d N/A e,U T h is Ephemeral public key Q e,U p u b Compute Z by calling ECC CDH Compute Z by calling ECC CDH lic Computation a using d and Q using d and Q tio e,U s,V s,V e,U n is a 1. Compute 1. Compute v a Derive secret DerivedKeyingMaterial DerivedKeyingMaterial ila keying material b le 2. Destroy Z 2. Destroy Z fre e o f c 6.2.2.3 Incorporating Key Confirmation into a C(1e, 1s) Scheme h a rg The subsection that follows illustrates how to incorporate key confirmation (as described in e fro Section 5.9) into the C(1e, 1s) key-agreement schemes described above. Note that only m : h unilateral key confirmation from party V to party U is specified, since only party V has a ttp static key pair that is used in the key-establishment process. s ://d The flow depiction separates the key-establishment flow from the key-confirmation flow. o i.o The depiction and accompanying discussion presumes that the assumptions of the scheme rg /1 have been satisfied, that the key-agreement transaction has proceeded successfully through 0 .6 key derivation, and that the received MacTag is successfully verified as specified in Section 0 2 8 5.2.2. N/ IS T 6.2.2.3.1 C(1e, 1s) Scheme with Unilateral Key Confirmation Provided by Party V to .S P Party U .8 0 Figure_13 depicts a typical flow for a C(1e, 1s) scheme with unilateral key confirmation 0 -5 from party V to party U. In this scenario, party V and party U assume the roles of the key- 6 A r3 confirmation provider and recipient, respectively. The successful completion of the key- confirmation process provides party U with a) assurance that party V has derived the same secret Z value, and b) assurance that party V has actively participated in the process. 10 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography U V V’s Static Public Key U obtains V’s static public key U’s Ephemeral Public Key U sends an ephemeral public key T MacTag h V is p V’s key-confirmation u b lic a tio n is a Figure 13: C(1e, 1s) scheme with unilateral key confirmation from party V to party U v a ila b To provide (and receive) key confirmation (as described in Section 5.9.1), both parties set le fre e EphemData = Null, and EphemData = EphemPubKey . o V U U f c h Party V provides MacTag to party U (as specified in Section 5.9.1, with P = V and R = U), a V rg where MacTag is computed (as specified in Section 5.2.1) using e V fro m MacData V = “KC_1_V” || ID V || ID U || Null || EphemPubKey U {|| Text V}. : h ttp Party U (the key-confirmation recipient) uses the same format for MacData V to compute its s ://d own version of MacTag V and then verifies that the newly computed MacTag matches the o i.o value provided by V. rg /1 Party V shall destroy its copy of MacKey immediately after computing MacTag V. Party U 0 .6 shall immediately destroy its copy of MacKey after determining whether or not the received 0 2 and newly computed MacTag values match. If they do not match, then party U shall also 8 V N/ destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify IS T party V that MacTag could not be verified. In this case, party V shall also destroy the .S V P KeyData portion of the DerivedKeyingMaterial. .8 0 0 -5 6.3 C(0e, 2s) Schemes 6 A r3 In this category, the parties use only static key pairs. Each party obtains the other party’s static public key. A nonce, Nonce , is sent by party U to party V to ensure that the derived U keying material is different for each key-establishment transaction. This would be accomplished by including (a copy of) Nonce in the OtherInput provided to the KDM, as U part of the FixedInfo (see Section 5.8). The parties calculate the shared secret using their own static private key and the other party’s static public key. Secret keying material is derived using the key-derivation method, the shared secret, and the nonce (see Figure 14). 10 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography U V U’s Static Public Key Obtain static public V’s Static Public Key keys Nonce U T U sends a nonce h is p u b lic a tio n is a Figure 14: C(0e, 2s) schemes: each party contributes only a static key pair v a ila Assumptions: In order to execute a C(0e, 2s) key-establishment scheme in compliance with b le this Recommendation, the following assumptions shall be true. fre e 1. Each party has an authentic copy of the same set of domain parameters, D. These o f c parameters are either approved for use in the intended application (see Section h a 5.5.1). For FFC schemes, D = (p, q, g{, SEED, counter}); for ECC schemes, D = (q, rg e FR, a, b{, SEED}, G, n, h). Furthermore, each party has assurance of the validity of fro these domain parameters as specified in Section 5.5.2. m : h 2. Each party has been designated as the owner of a static key pair that was generated ttp s as specified in Section 5.6.1 using the set of domain parameters, D. For FFC schemes, ://d the static key pair is (x, y); for ECC schemes, the static key pair is (d , Q ). Each party o s s i.o has obtained assurance of the validity of its own static public key as specified in rg /1 Section 5.6.2.1.3. Each party has obtained assurance of its possession of the correct 0 .6 value for its own private key as specified in Section 5.6.2.1.5. 0 2 8 N/ 3. The parties have agreed upon an approved key-derivation method (see Section 5.8), IS as well as an approved algorithm used with the method (e.g., a hash function) and T .S other associated parameters to be used. In addition, the parties have agreed on the P .8 form of the nonce (see Section 5.4), which should be a random nonce. 0 0 -5 6 4. If key confirmation is used, the parties have also agreed upon an approved MAC and A r3 associated parameters, including the lengths of MacKey and MacTag (see Section 5.9.3). If party V provides key confirmation to party U, the parties have agreed upon the form of Nonce , which should be a random nonce. V 5. Prior to or during the key-agreement process, each party receives the other party’s static public key in a trusted manner (e.g., from a certificate signed by a trusted CA or directly from the other party, who is trusted by the recipient). Each party has obtained assurance of the validity of the other party’s static public key as specified in Section 5.6.2.2.1. 10 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6. The recipient of a static public key has obtained assurance that its (claimed) owner is (or was) in possession of the corresponding static private key, as specified in Section 5.6.2.2.3. 7. When an identifier is used to label a party during the key-agreement process, that identifier has a trusted association with that party’s static public key. (In other words, whenever both the identifier and static public key of one participant are employed in the key-agreement process, they are associated in a manner that is trusted by the other participant.) When an identifier is used to label a party during the key-agreement process, both parties are aware of the particular identifier employed for that purpose. 6.3.1 dhStatic, C(0e, 2s, FFC DH) Scheme T h This section describes the dhStatic scheme. Assurance of secure key establishment using this is p scheme can only be obtained when the assumptions in Section 6.3 are true. In particular, it u b lic is assumed that party U has obtained the static public key y V of party V, and party V has a tio obtained the static public key y U of party U. n is In this scheme, each party has different actions, which are presented separately below. a v However, note that parties U and V must use identical orderings of the bit strings that are a ila input to the key-derivation method. b le fre Party U shall execute the following actions to a) establish a shared secret value Z with party e o V, and b) derive secret keying material from Z. f c h a Actions: Party U generates a shared secret and derives secret keying material as follows: rg e fro 1. Obtain a nonce, Nonce U (see Section 5.4). Send Nonce U to party V. m : h 2. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret Z from the set ttp of domain parameters D, party U’s static private key x U, and party V’s static public s ://d key y V. If the call to the FFC DH primitive outputs an error indicator, destroy Nonce U, o i.o and destroy the results of all intermediate calculations used in the attempted rg computation of Z; then output an error indicator, and exit this process without /1 0 performing the remaining actions. .6 0 2 8 3. Use the agreed-upon key-derivation method to derive secret keying material with the N/ IS specified length from the shared secret value Z, Nonce U and other input (see Section T .S 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; P then output an error indicator, and exit this process without performing the remaining .8 0 0 actions. -5 6 A 4. Destroy all copies of the shared secret Z and output the derived keying material. r3 Output: The derived keying material bits or an error indicator. Party V shall execute the following actions to a) establish a shared secret value Z with party U, and b) derive secret keying material from Z. Actions: Party V derives secret keying material as follows: 1. Obtain party U’s nonce, Nonce from party U. If Nonce is not available, then output U, U an error indicator, and exit this process without performing the remaining actions. 10 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 2. Use the FFC DH primitive in Section 5.7.1.1 to derive a shared secret from the set of domain parameters D, party V’s static private key x and party U’s static public key V, y If the call to the FFC DH primitive outputs an error indicator, destroy the results U. of all intermediate calculations used in the attempted computation of Z; then output an error indicator, and exit this process without performing the remaining actions. 3. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z, Nonce , and other input (see Section U 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; then output an error indicator, and exit this process without performing the remaining action. 4. Destroy all copies of the shared secret Z and output the derived keying material. T h is p Output: The derived keying material or an error indicator. u b lic Note: Key confirmation can be incorporated into this scheme. See Section 6.3.3 for details. a tio n dhStatic is summarized in Table 21. is a Table 21: dhStatic key-agreement scheme summary v a ila b le Party U Party V fre e o Domain (p, q, g{, SEED, counter}) (p, q, g{, SEED, counter}) f c parameters h a rg e fro Static data Static private key x U Static private key x V m : h Static public key y U Static public key y V ttp s ://d Ephemeral Nonce U o i.o data rg /1 0 Compute Z by calling FFC DH Compute Z by calling FFC DH .6 Computation 0 using x ,and y using x , and y 2 U V V U 8 N/ IS 1. Compute 1. Compute T .S Derive secret DerivedKeyingMaterial using DerivedKeyingMaterial using P .8 0 keying material Z and Nonce U Z and Nonce U 0 -5 2. Destroy Z 2. Destroy Z 6 A r3 6.3.2 (Cofactor) Static Unified Model, C(0e, 2s, ECC CDH) Scheme This section describes the Static Unified Model scheme. Assurance of secure key establishment using this scheme can only be obtained when the assumptions in Section 6.3 are true. In particular, it is assumed that party U has obtained the static public key Q of s,V party V, and party V has obtained the static public key Q of party U. s,U 10 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography In this scheme, each party has different actions, which are presented separately below. However, note that parties U and V must use identical orderings of the bit strings that are input to the key-derivation method. Party U shall execute the following actions to a) establish a shared secret value Z with party V, and b) derive secret keying material from Z. Actions: Party U generates a shared secret and derives secret keying material as follows: 1. Obtain a nonce, Nonce (see Section 5.4). Send Nonce to party V. U U 2. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the set of domain parameters D, party U’s static private key d , and party V’s static s,U T public key Q . If the call to the ECC CDH primitive outputs an error indicator, h s,V is destroy the results of all intermediate calculations used in the attempted computation p u b of Z; then output an error indicator, and exit this process without performing the lic a remaining actions. tio n is 3. Use the agreed-upon key-derivation method to derive secret keying material with the a specified length from the shared secret value Z, Nonce , and other input (see Section v U a ila 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; b le then output an error indicator, and exit this process without performing the remaining fre actions. e o f c 4. Destroy Nonce U and all copies of the shared secret Z. h a rg 5. Output the derived keying material. e fro Output: The derived keying material or an error indicator. m : h ttp Party V shall execute the following actions to a) establish a shared secret value Z, with party s U, and b) derive secret keying material from Z. ://d o i.o Actions: Party V derives secret keying material as follows: rg /1 0 1. Obtain party U’s nonce, Nonce U, from party U. If Nonce U is not available, then output .6 an error indicator, and exit this process without performing the remaining actions. 0 2 8 N/ 2. Use the ECC CDH primitive in Section 5.7.1.2 to derive a shared secret Z from the IS set of domain parameters D, party V’s static private key d and party U’s static T s,V, .S public key Q If the call to the ECC CDH primitive outputs an error indicator, P s,U. .8 destroy the results of all intermediate calculations used in the attempted computation 0 0 -5 of Z; then output an error indicator, and exit this process without performing the 6 A remaining actions. r3 3. Use the agreed-upon key-derivation method to derive secret keying material with the specified length from the shared secret value Z, Nonce , and other input (see Section U 5.8). If the key-derivation method outputs an error indicator, destroy all copies of Z; then output an error indicator, and exit this process without performing the remaining action. 4. Destroy all copies of the shared secret Z and output the derived keying material. Output: The derived keying material or an error indicator. 10 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Note: Key confirmation can be incorporated into this scheme. See Section 6.3.3 for details. Static Unified Model is summarized in Table 22. Table 22: Static unified model key-agreement scheme summary Party U Party V Domain (q, FR, a, b{, SEED}, G, n, h) (q, FR, a, b{, SEED}, G, n, h) parameters Static private key d Static private key d s,U s,V Static data T h Static public key Q s,U Static public key Q s,V is p u Ephemeral data Nonce b U lic a tio Compute Z by calling ECC CDH Compute Z by calling ECC n Computation is a using d s,U, and Q s,V CDH using d s,V, and Q s,U v a ila 1. Compute DerivedKeyingMaterial 1. Compute b le fre e D kee yr ii nv ge s mec ar tee rt ial 2. u Ds ei sn tg r oN yo Zn ce U D use ir ni gv e Nd oK ne cy ei Un gMaterial o f c 2. Destroy Z h a rg e fro 6.3.3 Incorporating Key Confirmation into a C(0e, 2s) Scheme m : h The subsections that follow illustrate how to incorporate key confirmation (as described in ttp Section 5.9) into the C(0e, 2s) key-agreement schemes described above. Note that party V s ://d cannot act as a key confirmation unless a nonce (Nonce V) is provided by party V to party U o i.o and is used (in addition to the shared secret Z) as input to the key-derivation method rg employed by the scheme. This would be accomplished by including (a copy of) Nonce in /1 V 0 the OtherInput provided to the KDM, as part of the FixedInfo (see Section 5.8), in addition .6 0 to using (a copy of) Nonce as the EphemData employed in the MacTag computations for 2 V V 8 N/ key confirmation. IS T .S The flow depictions separate the key-establishment flow from the key-confirmation flow. P The depictions and accompanying discussions presume that the assumptions of the scheme .8 0 0 have been satisfied, that the key-agreement transaction has proceeded successfully through -5 6 key derivation, and that the received MacTags are successfully verified as specified in A r3 Section 5.2.2. 6.3.3.1 C(0e, 2s) Scheme with Unilateral Key Confirmation Provided by Party U to Party V Figure_15 depicts a typical flow for a C(0e, 2s) scheme with unilateral key confirmation from party U to party V. In this scenario, party U and party V assume the roles of key- confirmation provider and recipient, respectively. A nonce (Nonce ) shall be provided by V party V to party U and used (in addition to the shared secret Z and the nonce provided by 10 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography party U) as input to the key-derivation method employed by the scheme. Nonce is also used V as the EphemData during MacTag computations. The successful completion of the key- V confirmation process provides party V with assurance that party U has derived the same secret Z value. If Nonce is a random nonce, then party V also obtains assurance that party V U has actively participated in the process; see Section 5.4 for a discussion of the length and security strength required for the nonce. U V U’s Static Public Key T h Obtain static is p V’s Static Public Key public keys u b lic a tio n Nonce U U sends a nonce is a v a Nonce ila b V V sends a nonce le fre e o MacTag U f c U’s key confirmation h a rg e fro m : h ttp Figure 15: C(0e, 2s) scheme with unilateral key confirmation from party U to party V s ://d o i.o To provide (and receive) key confirmation (as described in Section 5.9.1), party U (and party rg V) set /1 0 .6 0 EphemData U = Nonce U, and EphemData V = Nonce V. 2 8 N/ Party U provides MacTag U to party V (as specified in Section 5.9.1, with P = U and R = V), IS T where MacTag U is computed (as specified in Section 5.2.1) using .S P MacData = “KC_1_U” || ID || ID || Nonce || Nonce {|| Text }. .8 U U V U V U 0 0 -5 Party V (the key-confirmation recipient) uses the same format for MacData U to compute its 6 A own version of MacTag and then verifies that the newly computed MacTag matches the r3 U value provided by party U. Party U shall destroy its copy of MacKey immediately after computing MacTag . Party V U shall immediately destroy its copy of MacKey after determining whether or not the received and newly computed MacTag values match. If they do not match, then party V shall also U destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify party U that MacTag could not be verified. In this case, party U shall also destroy the U KeyData portion of the DerivedKeyingMaterial. 10 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.3.3.2 C(0e, 2s) Scheme with Unilateral Key Confirmation Provided by Party V to Party U Figure_16 depicts a typical flow for a C(0e, 2s) scheme with unilateral key confirmation from party V to party U. In this situation, party V and party U assume the roles of key- confirmation provider and recipient, respectively. The successful completion of the key- confirmation process provides party U with assurance that party V has derived the same secret Z value; if Nonce is a random nonce, then party U also obtains assurance that party U V has actively participated in the process; see Section 5.4 for a discussion of the length and security strength required for the nonce. T h U V is p u b lic a U’s Static Public Key tio n is Obtain static public a V’s Static Public Key v keys a ila b le fre Nonce U e o U sends a nonce f c h MacTag V a rg V’s key confirmation e fro m : h ttp s ://d Figure 16: C(0e, 2s) scheme with unilateral key confirmation from party V to party U o i.o To provide (and receive) key confirmation (as described in Section 5.9.1), both parties set rg /1 0 EphemData = Null, and EphemData = Nonce . .6 V U U 0 N2 8 / Party V provides MacTag V to party U (as specified in 5.9.1, with P = V and R = U), where IS MacTag V is computed (as specified in Section 5.2.1) using T .S MacData = “KC_1_V” || ID || ID || Null || Nonce {|| Text }. P V V U U V .8 0 Party U (the key-confirmation recipient) uses the same format for MacData to compute its 0 V -5 own version of MacTag , and then verifies that the newly computed MacTag matches the 6 V A r3 value provided by party V. Party V shall destroy its copy of MacKey immediately after computing MacTag . Party U V shall immediately destroy its copy of MacKey after determining whether or not the received and newly computed MacTag values match. If they do not match, then party U V shall also destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify party V that MacTag could not be verified. In this case, party V shall also V destroy the KeyData portion of the DerivedKeyingMaterial. 10 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 6.3.3.3 C(0e, 2s) Scheme with Bilateral Key Confirmation Figure_17 depicts a typical flow for a C(0e, 2s) scheme with bilateral key confirmation. In this method, party U and party V assume the roles of both the provider and the recipient in order to obtain bilateral key confirmation. A nonce (Nonce ) shall be provided by party V to V party U and used (in addition to the shared secret Z and the nonce, Nonce , provided by party U U) as input to the key-derivation method employed by the scheme. Nonce is also used as V the EphemData during MacTag computations. The successful completion of the key- V confirmation process provides each party with assurance that the other party has derived the same secret Z value. If Nonce is a random nonce, then party U obtains assurance that party U V has actively participated in the process; if Nonce is a random nonce, then party V obtains V assurance that party U has actively participated in the process. See Section 5.4 for a T h discussion about the length and security strength required for the nonce. is p u b lic a tio U V n is a v a U’s Static Public Key ila b Obtain static public le fre V’s Static Public Key keys e o f c h Nonce a U U sends a nonce rg e fro Nonce ,MacTag m V V : h V sends a nonce with ttp key-confirmation s ://d MacTag o U i.o U’s key-confirmation rg /1 0 .6 0 2 8 N/ IS Figure 17: C(0e, 2s) scheme with bilateral key confirmation T .S P To provide bilateral key confirmation (as described in Section 5.9.2), party U and party V .8 0 0 exchange and verify MacTags that have been computed (as specified in Section 5.2.1) using -5 6 A EphemData = Nonce ,and EphemData = Nonce . r3 U U V V Party V provides MacTag to party U (as specified in Sections 5.9.1 and 5.9.2, with P = V V and R = U); MacTag is computed by party V (and verified by party U) using V MacData = “KC_2_V” || ID || ID || Nonce || Nonce {|| Text }. V V U V U V Party U provides MacTag to party V (as specified in Sections 5.9.1 and 5.9.2, with P = U U and R = V); MacTag is computed by party U (and verified by party V) using U MacData = “KC_2_U” || ID || ID || Nonce || Nonce {|| Text }. U U V U V U 11 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Note that in Figure 17, party V’s nonce (Nonce ) and the MacTag (MacTag ) are depicted V V as being sent in the same message (to reduce the number of passes in the combined key- agreement/key-confirmation process). They can also be sent in other orders and combinations (as long as Nonce and Nonce are available to generate and verify both MAC U V tags). Each party shall destroy its copy of MacKey immediately after 1) using it to generate a MAC tag to be sent to the other party and 2) determining whether or not the MAC tag received from the other party matches the MAC tag that it computed. However, if either party is not able to verify the received MAC tag, that party shall also destroy the KeyData portion of the DerivedKeyingMaterial (see Section 5.9.1) and notify the other party of the failure. In this case, the other party shall destroy both the MacKey (if it has not already done so) as well as T h the KeyData portion of the DerivedKeyingMaterial. is p u b lic a tio n is a v a ila b le fre e o f c h a rg e fro m : h ttp s ://d o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 11 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 7. Rationale for Selecting a Specific Scheme The subsections that follow present possible justifications for selecting schemes from each subcategory, C(ie, js). The proffered rationales are intended to provide the user and/or developer with some information that may help when deciding the key-agreement scheme to be used. The rationales include brief discussions of basic security properties, but do not constitute an in-depth analysis of all possible security properties of all schemes under all adversary models. The specific security properties that are cited will depend on such considerations as whether a static key is used, whether an ephemeral key is used, how the shared secret is calculated, and whether key confirmation can be incorporated into a scheme. In general, the security properties cited for a subcategory of schemes are exhibited by each scheme within that subcategory; when this is not the case, the exceptions are identified. T h is A scheme should not be chosen based solely on the number of security properties it may p u b possess. Rather, a scheme should be selected based on how well the scheme fulfills system lic a requirements. For instance, if messages are exchanged over a large-scale network where each tio n exchange consumes a considerable amount of time, a scheme with fewer exchanges during is a a single key-agreement transaction might be preferable to a scheme with more exchanges, v a even though the latter may possess more security benefits. It is important to keep in mind ila b that a key-agreement scheme may be a component of a larger protocol that offers additional le fre security-related assurances beyond those provided by the key-agreement scheme alone. For e example, the protocol may include specific features that limit opportunities for accidental or o f c intentional misuse of the key-agreement component of the protocol. Protocols, per se, are not h a rg specified in this Recommendation. e fro Important Note: In order to provide concise descriptions of security properties possessed m : h by the various schemes, it is necessary to make some assumptions concerning the format and ttp type of data that is used as input during key derivation. These assumptions are made solely s ://d for the purposes of Sections 7.1 through 7.5; they are not intended to preclude the options o i.o specified elsewhere in this Recommendation. When discussing the security properties of a rg /1 subcategory of schemes, it is assumed that the FixedInfo input to a key-derivation method 0 .6 employed during a particular key-agreement transaction uses either the concatenation format 0 2 or the ASN.1 format (see Sections 5.8.2.1.1 and 5.8.2.1.2). It is also assumed that FixedInfo 8 N/ includes sufficiently specific identifiers for the participants in the transaction, an identifier IS T for the key-agreement scheme being used during the transaction, and additional input (e.g., .S P a nonce, ephemeral public key, and/or session identifier) that may provide assurance to one .8 0 or both participants that the derived keying material will reflect the specific context in which 0 -5 6 the transaction occurs (see Section 5.8.2 and Appendix B for further discussion concerning A r3 context-specific information that may be appropriate for inclusion in FixedInfo). In general, FixedInfo may include pre-shared secrets, but that is not assumed to be the case in the analysis of security properties that follows. In cases where an approved extraction-then- expansion key-derivation procedure is employed (see SP 800-56C), it is assumed that this FixedInfo is used as the Context input during the key-expansion step. Finally, it is assumed that all required nonces employed during the transaction are random nonces that contain a component consisting of a random bit string formed in accordance with the recommendations of Section 5.4. 11 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 7.1 Rationale for Choosing a C(2e, 2s) Scheme These schemes require each participant to own a static key pair that is used in their key- agreement transaction. Static key pairs can provide the participants with some level of assurance that they have correctly identified the party with whom they will be establishing keying material if the transaction is successfully completed. In the case of a key-agreement transaction based on the Full Unified model or dhHybrid1 scheme, each participant has assurance that no unintended entity (i.e., no entity other than the owners of the static key pairs involved in the transaction) could employ a Diffie-Hellman primitive (see Section 5.7.1) to compute Z , the static component of the shared secret Z s without knowledge of one of the static private keys employed during the transaction. Absent T the compromise of Z s or one of those static private keys, each participant can be confident of h is correctly identifying the other participant in the key-establishment transaction. The level of p u confidence is commensurate with the specificity of the identifiers that are associated with the b lic static public keys (and are used as input during the key-derivation process), the degree of a tio trust in the association between those identifiers and static public keys, the assurance of n is validity of the domain parameters and static public keys, and the availability of evidence that a v the keying material has been correctly derived. a ila b le Similarly, in the case of a key-agreement transaction based on Full MQV or MQV2, each fre participant has assurance that no unintended entity could use a DLC primitive to compute e o the shared secret Z without knowledge of either a static private key or a private-key- f c dependent implicit signature employed during the transaction. (The term “implicit signature” h a rg refers to those quantities denoted S A and implicitsig A in the descriptions of the MQV e fro primitives in Section 5.7.2.1 and Section 5.7.2.3, respectively.) Absent the compromise of Z, m a static private key, or an implicit signature, each participant can be confident of correctly : h ttp identifying the other participant in the key-establishment transaction. As above, the level of s ://d confidence is commensurate with the specificity of the identifiers that are associated with the o static public keys (and are used as input during the key-derivation process), the degree of i.o rg trust in the association between those identifiers and static public keys, the assurance of /1 validity of the domain parameters and static public keys, and the availability of evidence that 0 .6 0 the keying material has been correctly derived. 2 8 N/ These schemes also require each participant to generate an ephemeral key pair that is used IS T in their transaction, providing each participant with assurance that the resulting shared secret .S P (and the keying material derived from it) will vary from one of their C(2e, 2s) transactions .8 0 to the next. 0 -5 6 Each participant in a C(2e, 2s) transaction has assurance that the value of the resulting shared A r3 secret Z will not be completely revealed to an adversary who is able to compromise (only) their static private keys at some time after the transaction is completed. (The adversary would, however, be able to compute Z , the static component of the shared secret, if the key- s agreement transaction was based on the Full Unified model or dhHybrid1 scheme.) This assurance is commensurate with the confidence that a participant has that neither of the ephemeral private keys employed in the transaction will be compromised. By generating their ephemeral key pairs as close to the time of use as possible and destroying the ephemeral private keys after their use, the participants reduce the risk of such a compromise. 11 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography If a particular entity’s static private key is acquired by an adversary, then the adversary could masquerade as that entity while engaging in any C(2e, 2s) key-agreement transaction that permits the use of the compromised key pair. If an MQV scheme (MQV2 or Full MQV) will be employed during a transaction with an adversary who is in possession of a compromised static private key (or a compromised implicit signature corresponding to that static private key), the adversary is limited to masquerading as the owner of the compromised key pair (or as the owner of the static key pair corresponding to the compromised implicit signature). The use of the Full Unified model or dhHybrid1 scheme, however, offers the adversary additional opportunities for masquerading: If an adversary compromises an entity’s static private key, then the adversary may be able to impersonate any other entity during a Full Unified model- or dhHybrid1-based key-agreement transaction with that entity. Also, the compromise of Z , s T the static component of a shared secret that was (or would be) formed by two parties using h is the Full Unified Model or dhHybrid1 scheme will permit an adversary to masquerade as p u either party to the other party in key-agreement transactions that rely on the same scheme b lic and the same two static key pairs. a tio n Key confirmation can be provided in either or both directions as part of a C(2e, 2s) scheme is a by using the methods specified in Section 6.1.1.5. This allows the key confirmation recipient v a ila to obtain assurance that the key-confirmation provider has possession of the MacKey derived b le from the shared secret Z and has used it with the appropriate MacData to compute the fre received MacTag. In the absence of some compromise of secret information (e.g., a static e o private key or a static component of Z), a key-confirmation recipient can obtain assurance f c that the appropriate identifier has been used to label the key-confirmation provider and that h a rg the provider is the owner of the static public key associated with that identifier. A key- e fro confirmation recipient can also receive assurance of active (and successful) participation by m the key-confirmation provider in the key-agreement transaction. : h ttp s 7.2 Rationale for Choosing a C(2e, 0s) Scheme ://d o i.o These schemes require each participant to generate an ephemeral key pair that is used in their rg key-agreement transaction. No static key pairs are employed. Because the ephemeral private /1 0 .6 keys used in the computation of their shared secret are destroyed immediately after use, these 0 2 schemes offer assurance to each party that the shared secret Z computed during a legitimate 8 N/ C(2e, 0s) transaction (i.e., one that involves two honest parties and is not influenced by an IS T adversary) is protected against any compromise of shared secrets and/or private keys .S P associated with other (prior or future) transactions. .8 0 0 Unlike a static public key, which is assumed to have a trusted association with an identifier -5 6 for its owner, there is no assumption of a trusted association between an ephemeral public A r3 key and an identifier. Thus, these schemes, by themselves, offer no assurance to either party of the accuracy of any identifier that may be used to label the entity with whom they have established a shared secret. The use of C(2e, 0s) schemes may be appropriate in applications where any trusted association desired/required between an identifier and an ephemeral public key is enforced by methods external to the scheme (e.g., in the protocol incorporating the key-agreement scheme). This Recommendation does not specify the incorporation of key confirmation in a C(2e, 0s) scheme. 11 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 7.3 Rationale for Choosing a C(1e, 2s) Scheme These schemes require each participant to own a static key pair that is used in their key- agreement transaction; in addition, the participant acting as party U is required to generate and use an ephemeral key pair. Different assurances are provided to the participants by the utilization of a C(1e, 2s) scheme, depending upon which one acts as party U and which one acts as party V. The use of static key pairs in the key-agreement transaction can provide the participants with some level of assurance that they have correctly identified the party with whom they will be establishing keying material if the transaction is successfully completed. In the case of a transaction based on the One-Pass Unified model or dhHybridOneflow T h scheme, each participant has assurance that no unintended entity (i.e., no entity other than is p the owners of the static key pairs involved in the key-establishment transaction) could u b employ a Diffie-Hellman primitive (see Section 5.7.1) to compute Z , the static component lic s a of the shared secret Z, without knowledge of one of the static private keys employed during tio n the transaction. Absent the compromise of Z or one of those static private keys, each is s a participant can be confident of correctly identifying the other participant in the key- v a ila establishment transaction. The level of confidence is commensurate with the specificity of b le the identifiers that are associated with the static public keys (and are used as input during the fre key-derivation process), the degree of trust in the association between those identifiers and e o static public keys, the assurance of validity of the domain parameters and static public keys, f c and the availability of evidence that the keying material has been correctly derived. h a rg e Similarly, in the case of a key-agreement transaction based on the One-Pass MQV or MQV1 fro scheme, each participant has assurance that no unintended entity could use a DLC primitive m : h to compute the shared secret Z without knowledge of either the static private key of one of ttp the participants in the transaction or the private-key dependent implicit signature employed s ://d by party U during the transaction. (The term “implicit signature” refers to those quantities o i.o denoted S A and implicitsig A in the descriptions of the MQV primitives in Section 5.7.2.1 and rg Section 5.7.2.3, respectively.) Absent the compromise of Z, a static private key, or party U’s /1 0 .6 implicit signature, each participant can be confident of correctly identifying the other 0 2 participant in the key-establishment transaction. As above, the level of confidence is 8 N/ commensurate with the specificity of the identifiers that are associated with the static public IS T keys (and are used as input during the key-derivation process), the degree of trust in the .S P association between those identifiers and static public keys, the assurance of validity of the .8 0 domain parameters and static public keys, and the availability of evidence that the keying 0 -5 material has been correctly derived. 6 A r3 Party U, whose ephemeral key pair is used in the computations, has assurance that the resulting shared secret will vary from one C(1e, 2s) transaction to the next such transaction with the same party V. The participant acting as party V cannot obtain such assurance, in general, since party V’s contribution to the computation of Z is static. Party V can, however, obtain assurance that the derived keying material will vary if, for example, party V contributes a nonce that is used as input to the key-derivation method employed during these transactions (as is required when party V is a recipient in a key-confirmation process performed as specified in this Recommendation). The assurance of freshness of the derived 11 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography keying material that can be obtained in this way by the participant acting as party V is commensurate with the participant’s assurance that a different nonce will be contributed during each such transaction. The compromise of the static private key used by party U does not, by itself, compromise the shared secret computed during any legitimate C(1e, 2s) transaction (i.e., a transaction involving two honest parties). Likewise, the compromise of only the ephemeral private key used by party U would not compromise the shared secret Z for that transaction. However, the compromise of an entity’s static private key may lead to the compromise of the shared secrets computed during past, current, and future C(1e, 2s) transactions in which that entity acts as party V (regardless of the static or ephemeral keys used by the entity acting as party U); to compromise those shared secrets, the adversary must also acquire the public keys contributed T h by whomever acts as party U in those transactions. is p u If an adversary learns a particular entity’s static private key, then, in addition to b lic masquerading as that particular entity, the adversary may be able to impersonate any other a tio entity while acting as party U in a C(1e, 2s) transaction in which the owner of the n is compromised static private key acts as party V. Similarly, the compromise of the static a v a component, Z s, of a shared secret formed by two entities using the One-Pass Unified Model ila or dhHybrid1OneFlow scheme will permit an adversary to masquerade as either entity (while b le acting as party U) to the other entity (acting as party V) in future key-agreement transactions fre e that rely on the same scheme and the same two static key pairs. If the MQV1 or One-Pass o f c MQV scheme will be employed during a key-agreement transaction with an adversary who h a is in possession of a compromised implicit signature corresponding to a static private key, rg e the adversary may be able to masquerade as the owner of that static key pair while acting as fro party U (provided that the static key pair is compatible with the domain parameters employed m : h during the transaction). ttp s Key confirmation can be provided in either or both directions as part of a C(1e, 2s) scheme ://d o by using the methods specified in Section 6.2.1.5. This allows the key confirmation recipient i.o to obtain assurance that the key-confirmation provider has possession of the MacKey derived rg /1 from the shared secret Z and has used it with the appropriate MacData to compute the 0 .6 received MacTag. In the absence of a compromise of secret information (e.g., a static private 0 2 8 key or a static component of Z), a key-confirmation recipient can obtain assurance that the N/ IS appropriate identifier has been used to label the key confirmation provider and that the T .S provider is the owner of the static public key associated with that identifier. A key- P .8 confirmation recipient can also receive assurance of active (and successful) participation by 0 0 the key-confirmation provider in the key-agreement transaction. -5 6 A r3 7.4 Rationale for Choosing a C(1e, 1s) Scheme In these schemes, the participant acting as party U is required to generate and use an ephemeral key pair, while the participant acting as party V is required to own a static key pair that is used in the key-agreement transaction. Different assurances are provided to the participants by the utilization of a C(1e, 1s) scheme, depending upon which one acts as party U and which one acts as party V. 11 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography The use of a static public key attributed to party V can provide the participant acting as party U with some level of assurance that he has correctly identified the party with whom he will be establishing keying material if the transaction is successfully completed. Whether the transaction is based on the One-Pass Diffie-Hellman or dhOneflow scheme, the participant acting as party U has assurance that no unintended entity (i.e., no entity other than himself and the owner of the static public key attributed to party V) could employ a Diffie- Hellman primitive (see Section 5.7.1) to compute the shared secret Z without knowledge of one of the private keys employed during the transaction. Absent the compromise of Z or one of those private keys, the participant acting as party U can be confident of correctly identifying the other participant in the key-establishment transaction as the owner of the static public key attributed to party V. The level of confidence is commensurate with the T h specificity of the identifier that is associated with the static public key attributed to party V is p (and is used as input during the key-derivation process), the degree of trust in the association u b between that identifier and the static public key, the assurance of validity of the domain lic a parameters and static public key, and the availability of evidence that the keying material has tio n been correctly derived. is a v The participant acting as party V has no such assurance, in general, since he has no assurance a ila concerning the accuracy of any identifier that may be used to label party U (unless the b le protocol using this scheme includes additional elements that establish a trusted association fre e between an identifier for party U and the ephemeral public key that party U contributes to o f c the transaction). h a rg The participant acting as party U, whose ephemeral key pair is used in the computations, has e fro assurance that the resulting shared secret will vary from one C(1e, 1s) transaction to the next. m The participant acting as party V has no such assurance, since party V’s contribution to the : h computation of Z is static. ttp s ://d There is no assurance provided to either participant that the security of the shared secret is o i.o protected against the compromise of a private key. A compromise of the ephemeral private rg key used in a C(1e, 1s) transaction only compromises the shared secret resulting from that /1 0 particular transaction (and by generating the ephemeral key pair as close to the time of use .6 0 2 as possible and destroying the ephemeral private key after its use, the participant acting as 8 N/ party U reduces the risk of such a compromise). However, the compromise of an entity’s IS T static private key may lead to the compromise of shared secrets resulting from past, current, .S and future C(1e, 1s) transactions in which that entity acts as party V (no matter what party P .8 0 plays the role of party U); to compromise those shared secrets, the adversary must also 0 -5 acquire the ephemeral public keys contributed by whomever acts as party U in those 6 A transactions. In addition, if an adversary learns a particular entity’s static private key, the r3 adversary may be able to impersonate that particular entity while acting as party V in a C(1e, 1s) transaction that employs compatible domain parameters. The participant acting as party V may provide key confirmation to party U as specified in Section 6.2.2.3. This allows the participant acting as party U (who is the key confirmation recipient) to obtain assurance that party V has possession of the MacKey derived from the shared secret Z and has used it with the appropriate MacData to compute the received MacTag. In the absence of a compromise of secret information (e.g., a private key), the 11 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography participant acting as party U can obtain assurance that the appropriate identifier has been used to label party V, and that the participant acting as party V is indeed the owner of the static public key associated with that identifier. Under such circumstances, the participant acting as party U can also receive assurance of the active (and successful) participation in the key-agreement transaction by the owner of the static public key attributed to party V. This Recommendation does not specify the incorporation of key confirmation from party U to party V in a C(1e, 1s) scheme. 7.5 Rationale for Choosing a C(0e, 2s) Scheme These schemes require each participant to own a static key pair that is used in their key- agreement transaction; in addition, the participant acting as party U is required to generate a T h is nonce, which is sent to party V and used (by both participants) as input to their chosen key- p u derivation method. b lic a The use of static key pairs in the key-agreement transaction can provide the participants with tio n some level of assurance that they have correctly identified the party with whom they will be is a establishing keying material if the transaction is successfully completed. v a ila Whether the transaction is based on the Static Unified Model or dhStatic scheme, each b le participant has assurance that no unintended entity (i.e., no entity other than the owners of fre the static key pairs employed in the transaction) could employ a Diffie-Hellman primitive e o (see Section 5.7.1) to compute the static shared secret Z without knowledge of one of the f c h static private keys employed during the transaction. Absent the compromise of Z or one of a rg those static private keys, each participant can be confident of correctly identifying the other e fro party in the key-establishment transaction. The level of confidence is commensurate with the m : h specificity of the identifiers that are associated with the static public keys (and are used as ttp input during the key-derivation process), the degree of trust in the association between those s ://d identifiers and static public keys, the assurance of validity of the domain parameters and o i.o static public keys, and the availability of evidence that the keying material has been correctly rg derived. /1 0 .6 Although the value of Z is the same in all C(0e, 2s) key-establishment transactions between 0 2 8 the same two parties (as long as the two participants employ the same static key pairs), the N/ IS participant acting as party U, whose (required) nonce is used in the key-derivation T .S computations, has assurance that the derived keying material will vary from one of their P .8 C(0e, 2s) transactions to the next. In general, the participant acting as party V has no such 0 0 assurance – unless, for example, party V also contributes a nonce that is used as input to the -5 6 key-derivation method employed during the transaction (as is required when party V is a A r3 recipient of key confirmation performed as specified in this Recommendation). The assurance of freshness of the derived keying material that can be obtained by a participant in a C(0e, 2s) transaction is commensurate with the participant’s assurance that a different nonce will be contributed during each such transaction. If the static Z value formed by the two participants is ever compromised, then all of the keying material derived in past, current, and future C(0e, 2s) key-agreement transactions between these same two entities that employ these same static key pairs may be compromised as well, since the same Z value is used to derive keying material in each instance. However, 11 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography to compromise the keying material from a particular transaction, the adversary must also acquire (at least) the nonce contributed by the participant that acted as party U in that transaction. The compromise of the static Z value may also permit an adversary to masquerade as either entity to the other entity in future C(0e, 2s) key-agreement transactions. If a particular entity’s static private key is compromised, then shared secrets resulting from current, prior and future C(0e, 2s) transactions involving that entity’s static key pair may be compromised, irrespective of the role (whether party U or party V) played by the compromised entity. Regardless of what entity acts in the other role when interacting with the compromised entity, the adversary may be able to compute the shared secret Z and proceed to compromise the derived keying material, as described above. To complete the attack against a transaction, the adversary must acquire (at least) the static public key T h contributed by the other entity participating in that transaction with the compromised entity, is p as well as the nonce contributed by whichever entity acted as party U during the transaction. u b lic Of course, if a static private key has been compromised by an adversary, then (if the a tio compromised key pair is of the type permitted by the scheme and domain parameters) the n is adversary may masquerade as the owner of the compromised static key pair in key-agreement a v transactions with any other party. In addition, the adversary may masquerade as any entity a ila (whether acting as party U or party V) while engaging in a C(0e, 2s) key-agreement b le transaction with the owner of the compromised key pair. fre e o Key confirmation can be provided in either or both directions as part of a C(0e, 2s) scheme f c by using the methods specified in Section 6.3.3.1. This allows the key confirmation recipient h a rg to obtain assurance that the key-confirmation provider has possession of the MacKey derived e fro from the shared secret Z and has used it with the appropriate MacData to compute the m received MacTag. In the absence of a compromise of private information (e.g., a static private : h key or the static shared secret, Z), a key-confirmation recipient can obtain assurance that the ttp s appropriate identifier has been used to label the key-confirmation provider, and that the ://d o provider is the owner of the static public key associated with that identifier. A key- i.o confirmation recipient can also receive assurance of active (and successful) participation by rg /1 the key-confirmation provider in the key-agreement transaction. 0 .6 0 2 8 7.6 Summary of Assurances Associated with Key-Agreement Schemes N/ IS T The security-related features discussed in the preceding subsections of Section 7 can be .S P summarized in terms of the following types of assurance that may be obtained when .8 0 participating in a key-agreement transaction. 0 -5 6 • Implicit Key Authentication (IKA): Assurance obtained by one party in a key- A r3 agreement transaction that only a specifically identified entity (the intended second party in that key-agreement transaction) could also derive the key(s) of interest. • Key Freshness (KF): Assurance obtained by one party in a key-agreement transaction that keying material derived during that transaction is statistically independent of the keying material derived during that party’s previous key- agreement transactions. 11 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography • Forward Secrecy (FS): Assurance obtained by one party in a key-agreement transaction that the keying material derived during that transaction is secure against the future compromise of the static private key-agreement keys (if any) of the participants. • Key-Compromise Impersonation Resilience (K-CI): Assurance obtained by one party in a key-agreement transaction that the compromise of that party’s static private key-agreement key would not permit an adversary to impersonate the apparent second party in the key-agreement transaction. • Key Confirmation (KC): Assurance obtained by one party in a key-agreement transaction that a specifically identified entity (the intended second party in that key- T agreement transaction) has correctly derived, and is able to use, the key(s) of interest. h is p Notes: u b lic A participant in a key-agreement transaction cannot hope to distinguish between the a tio actions of another entity and the actions of those who share knowledge of that entity’s n is private key-agreement key(s) and/or any other secret data sufficient for that entity’s a v successful participation in a particular key-agreement transaction. In what follows, a ila references to a “specifically identified entity” must be interpreted as an umbrella term b le fre e i an nc dl u ad ri en tg r ua sll t et dh o tose a w cth oo n a r the el e eg ni tt ii tm y’a st e bly eh i an l fp .o Ass ne ys s aio ssn u o raf n t ch ea t o e bn tt ai it ny e’s d p wri iv tha t re e k spe ey c(s t ) t, o e tt hc. e, o f c actions of a specifically identified entity is conditioned upon the assumption that the h a identified entity’s relevant private/secret data has not been misused by a trusted party or rg e compromised by an adversary. fro m IKA assurance, as used in this Recommendation, does not address the potential : h ttp compromise of derived keying material because of misuse, mishandling, side-channel s leakage, etc. ://d o i.o Similarly, assurance of forward secrecy (FS), as defined in this Recommendation, does rg not address problems that may arise from sources other than the compromise of static /1 0 private key-agreement keys. There can be, of course, other threats to the security of .6 0 2 derived keying material, such as the use of derived keys in cryptographic algorithms or 8 N/ devices that have been compromised. Improper storage or transport of keying material, IS T the failure to prevent the leakage of sensitive information during computations involving .S P the derived keys, and/or inadequate methods for the timely destruction of sensitive data .8 0 (including ephemeral private keys and the derived keys themselves) are just a few 0 -5 examples of problems that could lead to an eventual compromise of keying material 6 A derived during a particular transaction. r3 FS assurance is (trivially) obtained when using a C(2e, 0s) scheme in a key-agreement transaction. The derived keying material is secure against any future compromise of static private key-agreement keys because no such keys are employed by the participants. A protocol may incorporate a C(2e, 0s) scheme as a means of securing its key-establishment component against the possibility of a future compromise of various long-term secret/private keys used (e.g., for authentication purposes) by protocol participants. 12 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography The notion of key-compromise impersonation resilience (K-CI), as defined in this Recommendation, is not applicable to C(2e, 0s) schemes, because neither party employs a static private key-agreement key that an adversary might acquire and employ in a masquerade attempt. K-CI assurance is not applicable to C(1e, 1s) schemes either. Only party V has a static key pair, and whether the static private key is compromised or not, the use of (only) an ephemeral key pair by party U cannot provide party V with assurance of the accuracy of any identifier that may be associated with party U. The notion of key- compromise impersonation resilience is only applicable to schemes in which each party is expected to employ a static private key-agreement key. In the definition of KC assurance, this Recommendation’s requirement that it be a specifically identified entity who demonstrates the ability to use (some portion of) the T h derived keying material is a stricter condition than is sometimes found in the literature. is p In this Recommendation, KC assurance presupposes IKA assurance with respect to (at u b least) the MAC key used in the key-confirmation computations. lic a tio KC assurance can be obtained in accordance with this Recommendation by incorporating n is key-confirmation into a key-agreement scheme in which the KC provider is expected to a v use a static private key-agreement key, and the KC recipient is expected to contribute a ila ephemeral data that affects the values of both the derived MacKey and the MacData used b le to compute a key-confirmation MacTag. fre e o The following table shows which types of assurance can be obtained by which participants f c in a key-agreement transaction by using appropriately implemented schemes from the h a rg indicated scheme subcategories. The previous assumptions in Section 7 concerning the e fro format and content of FixedInfo, the specificity of identifiers bound to static public keys, the m randomness of nonces, etc., still hold. : h ttp Table 23: Summary of assurances s ://d o i.o Scheme Assurance that can be Obtained by the Indicated Parties rg /1 Subcategory Sections IKA KF FS K-CI KC 0 .6 0 2 C(2e, 2s) 6.1.1, 7.1 U & V U & V U & V U* & V* U & V 8 N/ IS T C(2e, 0s) 6.1.2, 7.2 – U & V U & V N/A – .S P .8 0 C(1e, 2s) 6.2.1, 7.3 U & V U & V** – U U & V 0 -5 6 A C(1e, 1s) 6.2.2, 7.4 U U – N/A U r3 C(0e, 2s) 6.3, 7.5 U & V U & V** – – U & V** * K-CI assurance can be obtained using a C(2e, 2s) scheme only when the key-agreement scheme employed is either C(2e, 2s, FFC MQV) or C(2e, 2s, ECC MQV). ** The indicated type of assurance can be obtained by party V only if party V exercises the option of contributing a random nonce that is employed in key derivation and (when desired) key confirmation, as specified in this Recommendation. 12 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 8. Key Recovery For some applications, the secret keying material used to protect data may need to be recovered (for example, if the normal reference copy of the secret keying material is lost or corrupted). In this case, either the secret keying material or sufficient information to reconstruct the secret keying material needs to be available (for example, the keys, domain parameters and other inputs to the scheme used to perform the key-establishment process). Keys used during the key-establishment process shall be handled in accordance with the following: 1. A static key pair may be saved. T 2. An ephemeral public key may be saved. h is p 3. An ephemeral private key shall be destroyed after use and, therefore, shall not be u b lic recoverable. a tio 4. A symmetric key may be saved. n is a Note: This implies that keys derived from schemes where both parties generate ephemeral v a key pairs (i.e., the C(2e, 2s) and C(2e, 0s) schemes) cannot be made recoverable by ila b reconstruction of the secret keying material by parties requiring the ephemeral private key in le fre their calculations. For those schemes where only party U generates an ephemeral key pair e o (i.e., the C(1e, 2s) and C(1e, 1s schemes), only party V can recover the secret keying material f c by reconstruction. h a rg e General guidance on key recovery and the protections required for each type of key is fro provided in SP 800-57. m : h ttp s ://d o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 12 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 9. Implementation Validation When the NIST Cryptographic Algorithm Validation Program (CAVP) and the Cryptographic Module Validation Program (CMVP) have established a validation program for this Recommendation, a vendor shall have its implementation tested and validated by the CAVP and CMVP to claim conformance to this Recommendation. Information on the CAVP is available at https://csrc.nist.gov/Projects/Cryptographic-Algorithm-Validation-Program; information on the CMVP is available at https://csrc.nist.gov/projects/cryptographic- module-validation-program. An implementation claiming conformance to this Recommendation shall include one or more of the following capabilities: T h • Domain parameter generation or selection as specified in Section 5.5.1. is p u b • Explicit domain parameter validation as specified in Section 5.5.2, item 2. lic a tio • Key pair generation as specified in Section 5.6.1; documentation shall include how n is assurance of domain parameter validity is expected to be achieved by the key pair a owner. v a ila b • Explicit public-key validation as specified in Sections 5.6.2.3.1 and 5.6.2.3.2 for FFC le fre schemes or as specified in Sections 5.6.2.3.3 or 5.6.2.3.4 for ECC schemes. e o • A key-agreement scheme from Section 6, together with an approved key-derivation f c h method from SP 800-56C. If key confirmation is also claimed, the appropriate key- a rg confirmation technique from Section 5.9 shall be used. Documentation shall include e fro how assurance of private-key possession and assurance of domain-parameter and m : h public-key validity are expected to be achieved by both the owner and the recipient. sttp An implementer shall also identify the appropriate specifics of the implementation, ://d including: o i.o rg • The security strength(s) of supported cryptographic algorithms; /1 0 .6 • The domain parameter generation method or the selected domain parameters (see 0 2 8 Section 5.5.1); N/ IS • The hash function(s) used, if applicable (see Section 5.1); T .S P • The MAC algorithm(s) used, if applicable (see Section 5.2), including .8 0 -50 - The MAC key length(s) (see Section 5.9.3), and 6 A r3 - The MAC tag length(s) (see Section 5.9.3); • The type of cryptography supported: FFC and/or ECC; • The key-establishment schemes supported (see Section 6); • The key-derivation method(s), including the format of FixedInfo (see Section 5.8 and SP 800-56C); • The type(s) of nonces supported (see Section 5.4); 12 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography • The supported approved FFC domain parameters (if FFC schemes are supported) (see Section 5.5.1.1); • The supported approved ECC domain parameters (if ECC schemes are supported) (see Section 5.5.1.2); and • The key-confirmation technique(s) supported, if applicable (see Section 5.9). T h is p u b lic a tio n is a v a ila b le fre e o f c h a rg e fro m : h ttp s ://d o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 12 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Appendix A: References A.1 Normative References [ANS X9.42] American National Standard X9.42-2003 (R2013), Public Key Cryptography for the Financial Services Industry: Agreement of Symmetric Keys Using Discrete Logarithm Cryptography. [ANS X9.63] American National Standard X9.63-2011 (R2017), Key Cryptography for the Financial Services Industry: Public Key Cryptography for the Financial Services Industry: Key Agreement and Key Transport Using Elliptic Curve Cryptography. T h [FIPS 140] Federal Information Processing Standard 140-2, Security Requirements for is p Cryptographic Modules, May 25, 2001. u b lic https://doi.org/10.6028/NIST.FIPS.140-2 a tio [FIPS 140 Annex A] n is a Approved Security Functions. v a ila [FIPS 140 Annex D] b le fre Approved Key Establishment Techniques. e o [FIPS 140 IG] f c h a National Institute of Standards and Technology, Communicationes Security rg e Establishment, Implementation Guidance for FIPS 140-2 and the fro m Cryptographic Module Validation Program, March 27, 2018, : h https://csrc.nist.gov/CSRC/media/Projects/Cryptographic-Module- sttp Validation-Program/documents/fips140-2/FIPS1402IG.pdf. ://d o [FIPS 180] Federal Information Processing Standard 180-4, Secure Hash Standard, i.o rg August 2015. https://doi.org/10.6028/NIST.FIPS.180-4 /1 0 .6 [FIPS 186] Federal Information Processing Standard 186-4, Digital Signature Standard, 0 2 July 2013. https://doi.org/10.6028/NIST.FIPS.186-4 8 N/ IS [FIPS 197] Federal Information Processing Standard 197, Advanced Encryption T .S Standard, November 2001. https://doi.org/10.6028/NIST.FIPS.197 P .8 0 [FIPS 198] Federal Information Processing Standard 198-1, The Keyed-Hash Message 0 -5 Authentication Code (HMAC), July 2008. 6 A r3 https://doi.org/10.6028/NIST.FIPS.198-1 [FIPS 202] Federal Information Processing Standard 202, SHA-3 Standard: Permutation- Based Hash and Extendable-Output Functions, August 2015. https://doi.org/10.6028/NIST.FIPS.202 [RFC 3526] More Modular Exponential (MODP) Diffie-Hellman groups for Internet Key Exchange (IKE), May 2003, see https://tools.ietf.org/html/rfc3526. 12 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography [RFC 4492] Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS), May 2006, see https://tools.ietf.org/html/rfc4492. [RFC 5903] Elliptic Curve Groups Modulo a Prime (ECP Groups) for IKE and IKEv2, June 2010, see https://tools.ietf.org/html/rfc5903. [RFC 7919] Negotiated Finite Field Diffie-Hellman Ephemeral Parameters, August 2016, see https://tools.ietf.org/html/rfc7919. [SECG] Standards for Efficient Cryptography Group, see http://www.secg.org/. [SEC2] Standards for Efficient Cryptography, SEC 2: Recommended Elliptic Curve Domain Parameters, September 2000, see http://www.secg.org/SEC2-Ver- 1.0.pdf. T h is [SP 800-38B] Special Publication 800-38B, Recommendation for Block Cipher Modes of p Operation: The CMAC Mode for Authentication, May 2005, with updates u b lic dated October 2016. https://doi.org/10.6028/NIST.SP.800-38B a tio n [SP 800-38C] Special Publication 800-38C, Recommendation for Block Cipher Modes of is a Operation: the CCM Mode for Authentication and Confidentiality, May 2004, v a with updates dated July 2007. https://doi.org/10.6028/NIST.SP.800-38C ila b le [SP 800-38F] Special Publication 800-38F, Recommendation for Block Cipher Modes of fre Operation: Methods for Key Wrapping, December 2012. e o https://doi.org/10.6028/NIST.SP.800-38F f c h a [SP 800-52] Special Publication 800-52 Revision 2 (DRAFT), Guidelines for the rg e Selection, Configuration and Use of Transport Layer Security (TLS) fro Implementations, November 15, 2017. m : h https://csrc.nist.gov/publications/detail/sp/800-52/rev-2/draft ttp s ://d [SP 800-56B] Special Publication 800-56B Revision 1, Recommendation for Pair-Wise o Key-Establishment Schemes Using Integer Factorization Cryptography, i.o rg September 2014. https://doi.org/10.6028/NIST.SP.800-56Br1 /1 0 .6 [SP 800-56C] Special Publication 800-56C Revision 1, Recommendation for Key 0 2 Derivation Methods in Key Establishment Schemes, April 2018. 8 N/ https://doi.org/10.6028/NIST.SP.800-56Cr1 IS T .S [SP 800-57] Special Publication 800-57 Part 1 Revision 4, Recommendation for Key P .8 Management, January 2016. https://doi.org/10.6028/NIST.SP.800-57pt1r4 0 0 -5 [SP 800-89] Special Publication (SP) 800-89, Recommendation for Obtaining 6 A Assurances for Digital Signature Applications, November 2006. r3 https://doi.org/10.6028/NIST.SP.800-89 [SP 800-90] Special Publication 800-90 series: Special Publication 800-90A Revision 1, Recommendation for Random Number Generation Using Deterministic Random Bit Generators, June 2015. https://doi.org/10.6028/NIST.SP.800-90Ar1 12 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Special Publication 800-90B, Recommendation for the Entropy Sources Used for Random Bit Generation, January 2018. https://doi.org/10.6028/NIST.SP.800-90B Special Publication 800-90C (DRAFT), Recommendation for Random Bit Generator (RBG) Constructions, April 2016. https://csrc.nist.gov/publications/detail/sp/800-90c/draft [SP 800-108] Special Publication 800-108, Recommendation for Key Derivation Using Pseudorandom Functions, October 2009. https://doi.org/10.6028/NIST.SP.800-108 [SP 800-131A] Special Publication 800-131A Revision 1, Transitions: Recommendation T for Transitioning the Use of Cryptographic Algorithms and Key Lengths, h is p November 2015. https://doi.org/10.6028/NIST.SP.800-131Ar1 u b lic [SP 800-133] Special Publication 800-133, Recommendation for Cryptogrsphic Key a tio Generation, December 2012. https://doi.org/10.6028/NIST.SP.800-133 n is a [SP 800-135] Special Publication 800-135 Revision 1, Recommendation for Existing v a Application-Specific Key Derivation Functions, December 2011. ila b https://doi.org/10.6028/NIST.SP.800-135r1 le fre [SP 800-185] Special Publication 800-185, SHA-3 Derived Functions: cSHAKE, KMAC, e o TupleHash, and ParallelHash, December 2016. f c h https://doi.org/10.6028/NIST.SP.800-185 a rg e [SP 800-186] Special Publication 800-186 (DRAFT), Recommendations for Discrete fro Logarithm-Based Cryptography Elliptic Curve Domain Parameters, [future m : h release]. ttp s ://d A.2 Informative References o i.o rg [BM 1998] S. Blake-Wilson, A. Menezes, Unknown Key-Share Attacks on the Station- /1 0 to-Station (STS) Protocol, Technical Report CORR 98-42, University of .6 0 Waterloo, 1998. Available at: http://cacr.math.uwaterloo.ca. 2 8 N/ [CMU 2009] S. Chatterjee, A. Menezes, and B. Ustaoglu, Reusing Static Keys in Key IS T Agreement Protocols, INDOCRYPT 2009, LNCS Vol. 5922, pp. 39–56, .S P Springer-Verlag, 2009. Available at: .8 0 http://www.cacr.math.uwaterloo.ca/techreports/2009/cacr2009-36.pdf . 0 -5 6 [CBH 2005] K. R. Choo, C. Boyd, and Y. Hitchcock, On Session Key Construction in A r3 Provably-Secure Key Establishment Protocols, LNCS, Vol. 3715, pp. 116- 131, Springer-Verlag, 2005. Extended version available at: http://eprint.iacr.org/2005/206.pdf. [ISO/IEC 8825-1] Information technology -- ASN.1 encoding rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER) and Distinguished Encoding Rules (DER), 2008. 12 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography [Menezes 2007] A. Menezes, Another look at HMQV. Journal of Mathematical Cryptology, Vol.1(1), pp. 47-64, 2007 [RBB 2001] P. Rogaway, M. Bellare, D. Boneh, Evaluation of Security Level of Cryptography: ECMQVS (from SEC 1), Jan. 2001. Available at: http://www.ipa.go.jp/security/enc/CRYPTREC/fy15/doc/1069_ks- ecmqv.pdf. T h is p u b lic a tio n is a v a ila b le fre e o f c h a rg e fro m : h ttp s ://d o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 12 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Appendix B: Rationale for Including Identifiers and other Context- specific Information in the KDM Input (Informative) It is strongly recommended that identifiers for both parties to a key-agreement transaction be included among the data input to the key-derivation method – as a simple and efficient means of binding those identifiers to the derived keying material (see Sections 5.8). The inclusion of sufficiently-specific identifiers for party U and party V provides assurance that the keying material derived by those parties will be different from the keying material that is derived by other parties (or by the same parties acting in opposite roles). As a result, key-agreement schemes gain resilience against unknown-key-share attacks and/or other exploitation techniques that depend on some type of confusion over the role played by each T party (e.g., party U versus party V). See, for example, references [CBH 2005], [Menezes h is p 2007], [RBB 2001], [BM 1998], and [CMU 2009], which all recommend the inclusion of u b identifiers in the key-derivation method as a means of eliminating certain vulnerabilities. lic a tio In addition to identifiers, the inclusion of other context-specific information in the key- n is derivation input data can be used to draw finer distinctions between key-agreement a v transactions, providing assurance that parties will not derive the same keying material unless a ila they agree on all of the included information. This can protect against attacks that rely on b le confusion concerning the context in which key-establishment takes place and/or how the fre derived keying material is to be used, see [CMU 2009]. Examples of additional context- e o f c specific information include (but are not limited to) the protocol employing the key- h derivation method, protocol-defined session numbers, the key-agreement scheme that was a rg e employed to produce the shared secret Z, any ephemeral public keys and/or nonces fro exchanged during the key-agreement transaction, the bit length of the derived keying m : h material, and its intended use (see Section 5.8.2). ttp s Protocols employing an approved key-agreement scheme may employ alternative methods ://d to bind participant identifiers (and/or other context-specific data) to the derived keying o i.o material or otherwise provide assurance that the participants in a key-agreement transaction rg /1 share the same view of the context in which the keying material was established (including 0 .6 their respective roles and identifiers). However, this Recommendation makes no statement 0 2 8 as to the adequacy of these other methods. N/ IS T .S P .8 0 0 -5 6 A r3 12 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Appendix C: Data Conversions (Normative) C.1 Integer-to-Byte String Conversion Input: A non-negative integer C and the intended length n of the byte string satisfying 28n > C. When called from an FFC Scheme, n = t / 8 bytes, where t = log p and p 2 is the large prime field order. Output: A byte string S of length n bytes. 1. J = C. T n+1 h is p u 2. For i = n to 1 by -1 b lic a tio 2.1 J i = (J i+1)/256. n is a 2.2 A = J − (J • 256). v i i+1 i a ila b le 2.3 S i = (a i1, a i2, a i3, a i4, a i5, a i6, a i7, a i8), fre The 8-bit binary representation of the non-negative integer e o f c A i = a i1 27+a i2 26+a i3 25+a i4 24+a i5 23+a i6 22+a i7 2+a i8. h a rg 3. Let S , S , …, S be the bytes of S from leftmost to rightmost. e 1 2 n fro m 4. Output S. : h ttp s ://d C.2 Field-Element-to-Byte String Conversion o i.o Input: An element  in the field F q. rg /1 0 Output: A byte string S of length n = t / 8 bytes, where t = log q. .6 2 0 2 8 1. If q is an odd prime, then  must be an integer in the interval [0, q − 1];  shall be N/ IS converted to a byte string of length n bytes using the technique specified in Appendix T .S C.1 above. P .8 2. If q = 2m, then it is assumed that  is (already) represented as a bit string of length m, 0 0 -5 with each bit indicating the coefficient (0 or 1) of a specific element of a particular 6 A basis for GF(2m) viewed as a vector space over GF(2). r3 Let s , s , …, s be the bits of  from leftmost to rightmost. Let S , S , …, S be the 1 2 m 1 2 n bytes of S from leftmost to rightmost. The rightmost bit s shall become the rightmost bit of the last byte S , and so on m n through the leftmost bit s , which shall become the (8n − m + 1)th bit of the first byte 1 S . The leftmost (8n − m) bits of the first byte S shall be zero. 1 1 13 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography C.3 Field-Element-to-Integer Conversion Input: An element  in the field F . q Output: An integer x. 1. If q is an odd prime, then x =  (no conversion is required). 2. If q = 2m, then  must be a bit string of length m bits. Let s , s , …, s be the bits of 1 2 m  from leftmost to rightmost.  shall be converted to an integer x satisfying:  x = 2(m−i) s i for i = 1 to m. T C.4 Conversion of a Bit String to an Integer h is p u  b lic An n-long sequence of bits { x 1, , xn } is converted to an integer by the rule a tio n is { x 1,  , x n } → (x 1  2n–1 ) + (x 2  2n–2 ) +  + (n 1  2) + x n . a v a Note that the first bit of a sequence corresponds to the most significant bit of the ila b corresponding integer, and the last bit corresponds to the least significant bit. le fre Input: e o f c h 1. b 1, b 2,  , b n The bit string to be converted. a rg e Output: fro m 1. C The requested integer representation of the bit string. : h ttp Process: s ://d o  i.o 1. Let (b 1, b 2, , b n) be the bits of b from leftmost to rightmost. rg /1 2. 𝐶 = ∑𝑛 2(𝑛−𝑖)𝑏 . 0 .6 𝑖=1 𝑖 0 2 3. Return C. 8 N/ IS The binary length of an integer C is defined as the smallest integer n satisfying C < 2n. T .S P .8 0 0 -5 6 A r3 13 1NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Appendix D: Approved ECC Curves and FFC Safe-prime Groups This appendix contains lists of approved elliptic curves and safe-prime groups for key establishment. Warning: Additions to these lists may appear in the FIPS 140 Implementation Guidance document, Section D.13 (IG D.13) before the next revision of this document (i.e., SP 8900-56A). Note: entries in the same row refer to the same elliptic curve under different names. Absence of equivalent entries is indicated by “-”. Table 24: Appoved elliptic curves for ECC key-agreement. T h Targeted is p Referenced Security u FIPS 186-4 TLS (RFC 4492) IPsec w/ IKE v2 b lic in: SP 800-56A (SP 800-52) (RFC 5903) Strengths a tio that can be n is Supported a Specified in: SP 800-18629 SEC 2 RFC 5903 v a ila P-224 secp224r1 - s = 112 b le P-256 secp256r1 secp256r1 112  s  128 fre P-384 secp384r1 secp384r1 112  s  192 e o f c P-521 secp521r1 secp521r1 112  s  256 h a K-233 sect233k1 - 112  s  128 rg e K-283 sect283k1 - 112  s  128 fro m K-409 sect409k1 - 112  s  192 : h K-571 sect571k1 - 112  s  256 ttp s ://d B-233 sect233r1 - 112  s 128 o B-283 sect283r1 - 112  s  128 i.o rg B-409 sect409r1 - 112  s  192 /1 0 B-571 sect571r1 - 112  s  256 .6 0 2 8 N/ IS T .S Finite Field Cryptography Groups for Key Establishment: The following safe-prime P .8 groups are defined in RFC 3526 and RFC 7919 for use with key-agreement schemes that 0 0 employ either the FFC DH or FFC MQV primitives. -5 6 A The domain parameters for these groups have the form ( p, q = (p − 1)/2, g = 2 ); the explicit r3 values for p are provided in the RFCs. 29 Specified in FIPS 186-4 until SP 800-186 is available. 13 2NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Table 25: Approved IKE groups for FFC key agreement. Targeted Security IKE v2 Strengths that can be (RFC 3526) Supported MODP-2048 (ID=14) s = 112 MODP-3072 (ID=15) 112  s  128 MODP-4096 (ID=16) 112  s  152* MODP-6144 (ID=17) 112  s  176* MODP-8192 (ID=18) 112  s  200* T h is Table 26: Approved TLS groups for FFC key agreement. p u b Targeted Security lic a TLS (RFC 7919) Strengths that can be tio n Supported is a ffdhe2048 (ID = 256) s = 112 v a ila ffdhe3072 (ID = 257) 112  s  128 b le ffdhe4096 (ID = 258) 112  s  152* fre ffdhe6144 (ID = 259) 112  s  176* e o f c ffdhe8192 (ID = 260) 112  s  200* h a rg * The maximum security strength estimates were calculated using formula in Section 7.5 e fro of the FIPS 140 IG and rounded to the nearest multiple of eight bits. m : h ttp s ://d o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 13 3NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography Appendix E: Revisions (Informative) The original version of this document was published in March, 2006. In March, 2007, the following revision was made to allow the dual use of keys during certificate requests: In Section 5.6.4.2, the second item was originally as follows: “A static key pair may be used in more than one key-establishment scheme. However, one static public/private key pair shall not be used for different purposes (for example, a digital signature key pair is not to be used for key establishment or vice versa).” The item was changed to the following, where the changed text is indicated in italics: “A static key pair may be used in more than one key-establishment scheme. However, T one static public/private key pair shall not be used for different purposes (for h is example, a digital signature key pair is not to be used for key establishment or vice p u versa) with the following possible exception: when requesting the (initial) certificate b lic for a public static key-establishment key, the key establishment private key associated a tio with the public key may be used to sign the certificate request. See SP 800-57, Part 1 n is on Key Usage for further information.” a v a ila b le fre In May 2013, the following revisions were made; e o f c • Abstract – The March 2007 version cites ANS X9.42 and X9.63; this version directly h a provides information on the key establishment schemes (DH, MQV) and the rg e underlying mathematics structure (discrete logs on finite field, elliptic curve). fro m • Section 3.1 – Added definitions of assumption, binding, bit string, byte, byte string, : h ttp destroy, key-establishment pair, key-wrapping key, trusted association; removed s definitions on assurance of identifier, initiator, responder, (instead initiator and ://d o responder, all the schemes are defined in terms of party U and party V, see revision i.o in Section 4), extended keying material to derived keying material (derived from the rg /1 shared secret) and transported keying material (generated by the sender in a key- 0 .6 transport scheme.) 0 2 8 N/ • Section 3.2 – The notations, C(ie), C(ie, js), MAC(MacKey, MacData), MacTag, IS T T_bitlen(X), were introduced; the notation |x | is removed. .S P .8 • Section 3.2 – Notations Z, Z e, Z s are used for both FFC and ECC and therefore moved 0 0 up as general notations. -5 6 A r3 • Section 3.2 – The terms GF(p), GF(p)* were introduced for FFC. • Section 4 – Used party U and party V to name the parties, rather than user the initiator and responder as the parties. Discussions about identifiers vs. identity and binding have been moved to Section 4.1. • Section 4.1 – Added discussions on the concept of a trusted association; • Section 5 – Table 1 in March 2007 version has been removed; the information is now provided in Tables 6 and 7 in Section 5.8.1, and Tables 8 and 9 in Section 5.9.3. 13 4NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography • Section 5.2 – Provided more details on MAC inputs (MacKey and MacData). Added text that MACs can be used for key derivation, as well as key confirmation. Added SP 800-38B (CMAC) as an approved MAC. Refers to the new Tables 6 and 7. • Section 5.2.1 - MacLen now is a parameter, rather than an input variable. Refers to new Tables 8 and 9, instead of old Tables 1 and 2. Discusses the truncation of the MAC output. • Section 5.4 – More discussion has been added about the use of nonces, including new requirements and recommendations. • Section 5.5.1.1 – Added the requirement that the leftmost bit of p and q be a 1. Table 1 has been shortened to address just the values of p and q; information about the hash T h function is now provided in Tables 6 and 7 of Section 5.8.1, and in Tables 8 and 9 of is p Section 5.9.3. u b lic • Section 5.5.1.2 – More information is provided about elliptic curves. More details a tio are provided on parameter values. Table 2 has been shorted to just address n and h; n is information about the hash function is now provided in Tables 6 and 7 of Section a v a 5.8.1, and in Tables 8 and 9 of Section 5.9.3. ila b le • Section 5.5.2 – A note about parameters generated by using SHA-1has been removed. fre The validation methods are referred to other documents (FIPS 186 and ANS X9.62). e o It is not a right place for such statement. f c h a • Section 5.6 has been reorganized to make it clearer to understand key generation and rg e obtaining the required assurances. fro m • Section 5.6.1.1 – FFC key-pair generation has been revised to require a randomly : h ttp selected integer in the interval [2, q−2], rather than requiring a private key for FFC s ://d key pair generation to be unpredictable and generated by an approved RNG. o Generation in accordance with FIPS 186-3 (as referenced therein) fulfills these i.o rg requirements. /1 0 .6 • Section 5.6.1.2 – ECC key-pair generation has been revised to require a randomly 0 2 8 selected integer in the interval [2, n−2], rather than requiring a private key for ECC N/ IS key pair generation to be unpredictable and generated by an approved RNG. T .S Generation in accordance with FIPS 186-3 (as referenced therein) fulfills these P requirements. .8 0 0 -5 • New Section 5.6.2 – Discusses assurances and why they are required. Added Tables 6 A 3, 4, and 5 which summarize types of assurance. r3 • New Section 5.6.2.1 – Discusses the assurances required by a key-pair owner about its own key pair, including owner assurance of correct generation, static and ephemeral public-key validity, pair-wise consistency and private-key possession. • New Section 5.6.2.2 – Discusses the assurances required by a public-key recipient, including static and ephemeral public-key validity, and static and ephemeral private- key possession. 13 5NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography • New Sections 5.6.3.2 and 5.6.3.3 – Different requirements are included for static and ephemeral key pairs. Included a case that an agent may act on behalf of a system user. • Section 5.7 – Added requirements to destroy all values if there is an error and to destroy intermediate calculations have been added for each FFC and ECC primitive. Conversion calls have been added to convert to a string. Note that this removed such statements for the action steps for each scheme in Section 6. • Section 5.8 – Key derivation has been divided into one-step key-derivation methods (Section 5.8.1), an extract-then-expand key-derivation procedure (Section 5.8.2) and application-specific key-derivation methods (Section 5.8.3). T h • Section 5.8.1 – Instead of using a hash function, the one-step method is now defined is p with a function H, which can be a hash function or an HMAC with an approved hash u b lic function. Added tables defining minimum length for the hash functions with regard a tio to each parameter set; and added more complete discussions about OtherInfo, n is including the concatenation and ASN.1 formats included in the previous version. a HMAC with an approved hash function is now approved for key derivation, in v a ila addition to the hash function specified in the previous version. b le fre • Section 5.8.1 – Split Table 1 (for FFC) to Table 1 (Section 5.5.1.1), Table 6 (Section e 5.8.1) and Table 8 (Section 5.9.3), where Table 1 is for FFC parameter-size sets, o f c Table 6 is for the function H used for key derivation and Table 8 is about the MAC h a key length and MAC tag length. In the new tables, added row on “Maximum security rg e strength supported”. fro m • Section 5.8.1 – In Table 6, changed the minimum output length for function H from : h ttp 128 to 112 for FFC parameter set. s ://d • Section 5.8.1 - Split Table 2 (for ECC) to Table 2 (Section 5.5.1.2), Table 7 (Section o i.o 5.8.1) and Table 9 (Section 5.9.3), where Table 2 is for ECC parameter-size sets, rg /1 Table 7 is for the function H used for key derivation, and Table 9 is about the MAC 0 .6 key length and MAC tag length. In the new tables, added row on “Maximum security 0 2 strength supported”. 8 N/ IS • Section 5.8.2 – Added reference to an approved two-step method – an extraction- T .S then-expansion method – that is specified in SP 800-56C. P .8 0 • Section 5.8.3 – Added reference to the application-specific key-derivation methods 0 -5 6 provided in SP 800-135. A r3 • Moved general introduction of key confirmation to Section 5.9 – Incorporates the material from Section 8 (with additional introductory material). • New Section 5.9.1.1 – Emphasizes more clearly that a nonce is required if there is no ephemeral key; added guidance on what to do if key confirmation fails. • New Section 5.9.2 – Emphasizes that if no ephemeral key is used, then a nonce is required. 13 6NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography • New Section 5.9.3 – Discussions about the security strength of the MacTag are provided, along with tables on the minimum MacKey length and MacLen values. • New Section 5.9.3 – Table 8, changed the minimum MacLen, that is, MacTag length to 64 bits for all the parameter sets of FFC. • New Section 5.9.3 – Table 9, changed the minimum MacLen, that is, MacTag length to 64 bits for all the parameter sets of ECC. • Section 6 – The notation C(ie) replaces C(i), and C(ie, js) replaces C(i, j). If party U does not contribute a static key, then the requirement for a non-null identifier is now transaction dependent, rather than required. Rationale for choosing the C(ie, js) schemes has been moved to a new Section 8, instead of after each class of schemes. T h Assumptions are specified for each type of scheme, rather than prerequisites. is p u • Section 6.1.1 (and similarly for Sections 6.2.1, 6.2.2 and 6.3) –Added a new b lic assumption that if an identifier is used as a label, then the identifier must have a a tio trusted association to that party’s static key. The discussion on the need for a trusted n is association has been added. a v a ila • Section 6.1.1.1 (dhHybrid1) – More guidance is provided about error handling. b le Specifically allows the reuse of an ephemeral key pair in a broadcast scenario. This fre is also provided in Sections 6.1.1.2, 6.1.1.3 and 6.1.1.4. e o f c • New Section 6.1.1.5 (and similarly in new Sections 6.1.2.3, 6.2.1.5, 6.2.2.3 and 6.3.3) h a – Key confirmation is incorporated to each applied subcategory of schemes. This rg e material was previously provided in Section 8.4 of the previous version. fro m • Section 6.2.1 (C(1e,2s) schemes) – Added additional assumptions which were : h ttp included in the previous prerequisites. This includes obtaining assurance of static s ://d public key validity and private keys possession of the key-pair owner. o i.o • Section 7 – Has been revised to specify DLC-based key-agreement and key transport rg /1 in the same key-establishment transaction, with party U acting as the key-transport 0 .6 sender. In addition, optional key confirmation from party V to party U following the 0 2 key-transport process has been specified. 8 N/ IS • Section 8 – The rationale for choosing each scheme type has been moved from T .S Section 6 of the previous version. A new section on the rationale associated with key P .8 transport has been included. 0 0 -5 6 • All figures are replaced to reflect the content, text, and terminology changes. A r3 • Old Appendix A, Summary of Differences between this Recommendation and ANS X9 Standards, was removed. Note that X9.42 was withdrawn, while X9.63 has modified to be consistent with this Recommendation. • Appendix B – The requirement of including identifiers as part of the OtherInfo is replaced with text that. it is strongly recommended that identifiers for both parties to a key-agreement transaction be included among the data input to a key-derivation method. A paragraph has been added stating that there may be other ways to bind 13 7NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography identifiers to derived keying material, but the recommendation makes no statement on the adequacy of this. • The new Appendix A includes all the informative references, which was in Appendix D in March 2007 version. • The old Appendix E becomes Appendix D and the changes on March 2007 version are added as listed here. In 2018, the following revisions were made: 1. Inserted hyperlinks for sections, references and definitions. 2. Text about key transport and broadcasting has been removed, except for a short T discussion of key transport in Section 4.3. h is p 3. Tables 1, 2 6 and 7: Changed column 1, row 1 to "Targeted security strength" instead u b lic of "Maximum security strength supported" a tio n 4. Section 3.1: Added definitions for critical security parameter, cryptographic module is a and MacOutputBits. Updated the definition of destroy, integrity, key-derivation v a procedure, key-establishment transaction, key-wrapping algorithm, key-wrapping ila b key, MacTagBits, message authentication code, shared secret, symmetric key le fre algorithm, store-and-forward and targeted security strength. Modified the definition e for fresh, and key confirmation, Mac tag. o f c h 5. Section 3.2: Inserted CSP, len(x), MacOutputBits and RBG. Removed H and HMAC- a rg hash. Modified MacTag. MacTagLen was changed to MacTagBits. (Uses of e fro MacOutputLen in the document were changed to MacOutputBits). m : h 6. Section 4: Inserted additional paragraphs the security of a key-establishment scheme ttp and explicit instructions for the destruction of certain potentially sensitive values. s ://d Inserted a requirement that values explicitly required to be destroyed when leaving a o i.o routine (i.e., potentially sensitive locally stored data) shall not be used or reused for rg /1 any additional purpose. 0 .6 0 7. Section 4.1, paragraph 2, mentioned that domain parameters may be from an 2 N8 / approved list. Paragraph 3: Explained what is meant by transporting in a "protected IS manner." T .S P 8. Section 5.1: Inserted a reference to FIPS 202. .8 0 0 9. Section 5.2: Paragraph 3 − added KMAC to the list of approved MACs. Paragraph 5 -5 6 A − referred to SP 800-56C for the case where a MAC is used for key derivation. r3 10. Section 5.2.1, item 2: Changed “is required to” to “shall”. MacLen has been renamed to be MacTagBits for clarity. 11. Section 5.5: Revised wording. 12. Section 5.5.1.1: Certain FFC groups defined in other standards are now approved for use, which are encouraged for use. The old parameter-size sets in Table 1 are now addressed as FIPS 186-type sets and recommended for use only in legacy applications. Parameter-size set FA was removed. Table 1 has been shortened to 13 8NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography address just the values of p and q; information about the hash function is now provided in Section 5.8.1 and Section 5.9.3. For the FIPS 186-type parameter-size sets, a requirement was added that the leftmost bit of p and q be a 1. 13. Section 5.5.1.2: Removed the table of parameter-size sets. Elliptic curves will be specified in SP 800-186 (when available; will continue to be available in FIPS 186 until then). References to ASC X9.62 have been removed. 14. Section 5.5.2: Inserted an assurance method that allows approved safe-prime groups of domain parameters. 15. Section 5.6.1.1: Added discussions about the generation of key pairs for both the approved safe-prime groups and the FIPS 186-type parameter-size sets. The FFC key- T pair generation routines from FIPS 186-4 were added (with some modifications). A h is p reference to SP 800-133 is included for generating the keys. u b lic 16. Section 5.6.1.2: The ECC key-pair generation routines from FIPS 186-4 were added a tio (with some modifications). n is a 17. Section 5.6.2.1.2: Revised to accommodate the safe-prime groups. v a ila 18. Sections 5.6.2.1.3, 5.6.2.1.4 and 5.6.2.1.5: Revised for further clarity. b le fre 19. Section 5.6.2.1.4: The alternative test in method b was removed. e o 20. Section 5.6.2.2.2: Revised to accommodate the safe-prime groups. f c h a 21. Section 5.6.2.3: Introductory text added. rg e fro 22. Section 5.6.2.3.1: Now specified as a method for FFC full public-key validation. The m comment on process step 1 has been revised for clarity. : h ttp 23. Section 5.6.2.3.2: New section added on FFC partial public-key validation. s ://d 24. Sections 5.6.2.3.1, 5.6.2.3.2 and 5.6.2.3.3: Added text to say that when an error is o i.o found, the routine should be exited immediately without further processing. rg /1 0 25. Section 5.6.2.2.2: Changed “The recipient of another party’s ephemeral public key is .6 0 required to obtain assurance…” to “The recipient of another party’s ephemeral public 2 8 N/ key shall obtain assurance…”. IS T 26. Section 5.6.2.2.4, items 2 and 3: Added further clarifications. .S P .8 27. Section 5.6.3.2: Public keys generated using the approved safe primes shall not be 0 0 -5 used for digital signatures. 6 A r3 28. Section 5.6.3.3: Added further clarification to item 1 to state that the private key needs to be protected until destroyed and is not to be backed up, archived or escrowed. 29. Section 5.7.1.1: Clarified error handling in step 2, and added checks for z = p − 1 and z = 0. 30. Section 5.7.1.2: Clarified error handling in step 2. 31. Section 5.7.2.1: Clarified error handling in step 6. 32. Section 5.7.2.3: Clarified error handling in step 3. 13 9NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 33. Section 5.8: Inserted a requirement that the shared secret shall be used only by an approved key-derivation method and shall not for any other purpose. Inserted an explicit statement that SP800-56A approves the key-derivation methods only for the derivation of keys from a shared secret. 34. Moved all key-derivation methods to SP 800-56C. Inserted a new section (Section 5.8.1) to describe how to call a key-derivation method and reorganized Section 5.8. 35. To avoid confusion between the use of OtherInput and OtherInfo in the previous version of this document, OtherInfo was changed to FixedInfo; this information is used as fixed input to the key-derivation method. keydatalen was changed to L for (eventual) consistency between SP 800-56A/B/C and SP 800-108. 36. In the new Section 5.8.2.1, inserted text in SuppPubInfo and SuppPrivInfo that states T h that, while an implementation may be capable of including these subfields, the is p subfields may be null for a given transaction. u b lic 37. Section 5.8.2.2 clarifies the interaction with the two-step key-derivation procedure in a tio SP 800-56C. n is a 38. Section 5.9.1: Changed “Each party is required to have an identifier…” to “Each v a party shall have an identifier…”. Also, inserted text that discusses the EphemPubKey ila i b string and conversions to FFC and ECC schemes. le fre 39. Section 5.9.1.1: Appended to Section 5.9.1, since there was no Section 5.9.1.2. Text e o was added to clarify the use of an ephemeral public key in the MacData. f c h a rg 40. Section 5.9.1.1 (step 1) and 5.9.2: The requirement for a "random nonce" was e fro changed to a requirement for a "nonce" to be consistent with Section 5.4 and the key m confirmation subsections of Section 6. : h ttp 41. Section 5.9.3: Modified text to approve the use of KMAC as a MAC algorithm. s ://d Removed the domain parameter-size sets, referring to Section 5.5.1 for the domain o parameter information. Provided text specifying that the MacKey length needs to be i.o rg at least the supported security strength of the domain parameters and the Mac tag /1 0 length needs to be at least 64 bits. Also, added text and a table that identifies the .6 0 approved MAC algorithms, values for MacOutputBits and the security strengths 2 8 N/ that they can support. IS T 42. Section 6.1.1: Modified the first assumption to refer to Section 5.5.1 for the domain .S P parameter information. Now refer to Section 5.9.3 for the minimum MacKey and Mac .8 0 tag lengths. 0 -5 6 A 43. Section 6.1.1.1-6.1.1.4: Clarified error handling. r3 44. Section 6.1.2: Modified the first assumption to refer to Section 5.5.1 for the domain parameter information. Now refer to Section 5.9.3 for the minimum MacKey and Mac tag lengths. 45. Section 6.1.2.1-6.1.2.2: Clarified error handling. 46. Section 6.2.1: Modified the first assumption to refer to Section 5.5.1 for the domain parameter information. Now refer to Section 5.9.3 for the minimum MacKey and Mac tag lengths. 14 0NIST SP 800-56A Rev. 3 Recommendation for Pair-Wise Key Establishment Using Discrete Logarithm Cryptography 47. Section 6.2.1.1-6.2.1.4: Clarified error handling. 48. Section 6.2.2: Modified the first assumption to refer to Section 5.5.1 for the domain parameter information. Now refer to Section 5.9.3 for the minimum MacKey and Mac tag lengths. 49. Section 6.2.2.1-6.2.2.2: Clarified error handling. 50. Section 6.3: Modified the first assumption to refer to Section 5.5.1 for the domain parameter information. Now refer to Section 5.9.3 for the minimum MacKey and Mac tag lengths. 51. Section 6.31-6.3.2: Clarified error handling. T 52. Old Section 7: Removed. h is p 53. Section 7.6 (old Section 8.6): Changed to be a summary of the properties discussed u b lic in Sections 7.1 - 7.5 for the schemes in this Recommendation. a tio 54. Section 9 (old Section 10): Modified to refer to SP 800-56C for key-derivation n is methods. a v a ila 55. Appendix A: Updated the FIPS and SP references. b le fre 56. Appendix B: Changed the title. e o 57. Appendix C.1: Changed the routine to specify the technique used in SP 800-56B; f c the same results should be obtained. h a rg e 58. Appendix C.4: Added a bit string to integer conversion routine. fro m 59. Appendix D: Inserted an appendix listing the approved safe-prime groups and a table : h providing various names for the NIST-recommended elliptic curves currently ttp s specified in FIPS 186-4. The curves will be moved to SP 800-186. The supported ://d security strengths for the curves and the safe-prime groups is included in the tables. o i.o rg /1 0 .6 0 2 8 N/ IS T .S P .8 0 0 -5 6 A r3 14 1