NIST Special Publication 500-304 Conformance Testing Methodology Framework for ANSI/NIST-ITL 1- 2011 Update: 2013, Data Format for the Interchange of Fingerprint, Facial & Other Biometric Information Christofer J. McGinnis Dylan J. Yaga Fernando L. Podio This publication is available free of charge from: http://dx.doi.org/10.6028/NIST.SP.500 304 -NIST Special Publication 500-304 Conformance Testing Methodology Framework for ANSI/NIST-ITL 1- 2011 Update: 2013, Data Format for the Interchange of Fingerprint, Facial & Other Biometric Information Christofer J. McGinnis Dylan J. Yaga Fernando L. Podio Computer Security Division Information Technology Laboratory This publication is available free of charge from: http://dx.doi.org/10.6028/NIST.SP.500 304 - June 2015 U.S. Department of Commerce Penny Pritzker, Secretary National Institute of Standards and Technology Willie May, Under Secretary of Commerce for Standards and Technology and DirectorCertain commercial entities, equipment, or materials may be identified in this document in order to describe an experimental procedure or concept adequately. Such identification is not intended to imply recommendation or endorsement by the National Institute of Standards and Technology, nor is it intended to imply that the entities, materials, or equipment are necessarily the best available for the purpose. National Institute of Standards and Technology Special Publication 500-304 Natl. Inst. Stand. Technol. Spec. Publ. 500-304, 75 pages (June 2015) CODEN: NSPUE2 This publication is available free of charge from: http://dx.doi.org/10.6028/NIST.SP.500.304 iiReports on Information Technology The Information Technology Laboratory (ITL) at the National Institute of Standards and Technology (NIST) stimulates U.S. economic growth and industrial competitiveness through technical leadership and collaborative research in critical infrastructure technology, including tests, test methods, reference data, and forward-looking standards, to advance the development and productive use of information technology. To overcome barriers to usability, scalability, interoperability, and security in information systems and networks, ITL programs focus on a broad range of networking, security, and advanced information technologies, as well as the mathematical, statistical, and computational sciences. Special Publication 500-series reports on ITL's research in tests and test methods for information technology, and its collaborative activities with industry, government and academic organizations. This publication is a contribution of the National Institute of Standards and Technology and is not subject to copyright. Any organization interested in reproducing “Conformance Testing Framework for ANSI/NIST-ITL 1-2011 Update 2013, Data Format for the Interchange of Fingerprint, Facial & Other Biometric Information” is free to do so. However, there shall be no alteration to any of the material information contained in the publication. NIST retains the sole right to submit this publication to any other forum for any purpose. Certain commercial entities, equipment, or materials may be identified in this document in order to describe an experimental procedure or concept adequately. Such identification is not intended to imply recommendation or endorsement by the National Institute of Standards and Technology, nor is it intended to imply that the entities, materials, or equipment are necessarily the best available for the purpose. National Institute of Standards and Technology Special Publication 500-304 Natl. Inst. Stand. Technol. 75 pages iiiForeword The existence of biometric standards alone is not enough to demonstrate that products meet the technical requirements specified in the standards. Conformance testing captures the technical description of a specification and measures whether an implementation faithfully implements the specification. Conformance testing provides developers, users, and purchasers with increased levels of confidence in product quality and increases the probability of successful interoperability. Lack of conformance to the required standard(s) can, in many cases, jeopardize the expected biometric recognition performance or prevent access to the data (as well as impact the overall operational performance) since implementers may handle non-conformant records in different ways during processing. Although no conformance test can be comprehensive enough to test all the different combinations of mandatory requirements of a standard and all possible combinations of conditional and optional characteristics that could be included in American National Standards Institute (ANSI)/NIST-ITL 2011 Update: 2013 (AN-2013) transactions, a well-designed conformance test tool that faithfully implements a standard conformance testing methodology could raise the level of confidence on the test results. Therefore, transactions tested with such a tool (and reported to be conformant to the standard), are more likely to conform to the standard. The Computer Security Division (CSD) of NIST/ITL supports the development of biometric conformance testing methodology standards and other conformity assessment efforts through active technical participation in the development of biometric standards and associated conformance test architectures and test suites and develops these test tools to support users who require conformance to selected biometric standards and product developers interested in conforming to biometric standards by using the same testing tools available to users. Testing laboratories can also benefit from the use of these test tools. Under the conformance test software called “BioCTS”, NIST/ITL CSD develops Conformance Test Architectures (CTAs) and Conformance Test Suites (CTSs) to test implementations of national and international biometric data interchange formats. The initial version of a CTA/CTS designed to test implementations of the ANSI/NIST-ITL 1-2011 Update: 2013 was recently released. These testing tools and related documentation can be found and downloaded at: http://www.nist.gov/itl/csd/biometrics/biocta_download.cfm. ivTable of Contents Foreword ............................................................................................................................ iv 1 Introduction .................................................................................................................. 1 2 Conformance Test Tool Characteristics .................................................................... 2 3 References ................................................................................................................... 2 4 Terms and definitions .................................................................................................. 2 5 Conformance testing methodology ............................................................................ 4 5.1 AN-2013 Requirements and Conformance Test Assertions .................................... 4 5.2 Limitations and exceptions ...................................................................................... 5 5.3 Hierarchy of conformance tests ............................................................................... 5 5.4 Functional Documentation of Requirements and Test Assertions ........................... 6 5.5 Claim of Supported Test Assertions ...................................................................... 27 Annex A: Minimum Support for AN-2013 Record Types and Interrelated Fields ........ 29 A.1 Minimum Conformance ............................................................................................. 29 A.2 Interrelated Field Support.......................................................................................... 29 Annex B: Sample Requirement and Assertion Table Format ....................................... 31 Annex C: Tables of Requirements and Assertions ........................................................ 32 Annex D: Test Notes and Test Exceptions ..................................................................... 68 Acknowledgements .......................................................................................................... 68 vList of Tables and Figures Table 5.1 - Assertion Syntax: Value-Type Definitions...................................................... 7 Table 5.2 - Assertion Syntax: Defined Values .................................................................. 9 Table 5.3 - Assertion Syntax: Value-based Image Metadata Tags ................................ 10 Table 5.4 - Assertion Syntax: Marker-based Image Metadata Tags .............................. 12 Table 5.5 - Assertion Syntax: Expression Definitions ................................................... 13 Table 5.6 - Assertion Syntax: Complex Expression Definitions ................................... 22 Table 5.7 - Assertion Syntax: Complex Value-Type Definitions.................................... 23 Table 5.8 - Assertion Syntax: Complex Procedure Definitions ..................................... 23 Figure 5.9 - Generic AN-2013 Field Structure ................................................................. 24 Table A.1 - AN-2013 Interrelated Field Support .............................................................. 29 Figure B.1 – Sample Requirements and Assertions Table ............................................ 31 Table C.1 - Assertions for Transaction-related Requirements ...................................... 33 Table C.2 - Assertions for Record Type 1: Transaction information record ................ 40 vi1 Introduction This publication defines a conformance testing methodology framework (CTMF) which includes elements of a conformance testing methodology (CTM), conformance test assertions, and conformance test procedures applicable to ANSI/NIST-ITL 2011 Update: 2013 (AN-2013). It discusses three levels of conformance testing (Level 1, Level 2, and Level 3) and provides a detailed Test Assertion Syntax for describing conformance test procedures. The Conformance Test Assertion Syntax formalizes a method for representing these conformance tests using Expressions, Value- Types, Operators, and Operands. A table-based format for documenting AN-2013 requirements and conformance test assertions is included. The table-based format indicates the association between requirements in AN-2013 and the test assertions and test procedures required to test each assertion. It includes information on the applicability of each test assertion indicating whether it only applies to the Traditional encoding as described in Annex B of AN-2013 (“T”), to the National Information Exchange Model (NIEM)- conformant Extensible Markup Language (XML) encoding as described in Annex C of AN-2013 (“X”), or to both Traditional and NIEM (XML) encoding (“B”). AN-2013 specifies a data-interchange transaction format comprised of Record Types (collections of biometric and/or forensic modality data and related metadata). The test assertion tables included in Annex C identify requirements and assertions that are required for every transaction (regardless of its containing Record Types) according to the terms specified in AN-2013. These types of requirements are referred to as transaction-related requirements and are defined as requirements that are not related to a specific Record Type. Examples of transaction-related requirements include:  The transaction adheres to its specified encoding (Traditional or NIEM-XML) requirements.  The transaction includes one and only one Record Type-1.  Record Type-1 is encoded exclusively in 7-bit ASCII (for Traditional Encoding).  Record Type-1 is conformant to the requirements specified for its fields, subfields, and information items: o All mandatory fields, subfields, and information items in Record Type-1 must be present (with data), and the requirements for those entities must be met. o Optional and dependent fields, subfields, and information items that are present in Record Type-1 must be conformant to the requirements specified for those entities.  the transaction includes at least one other record of a type other than Record Type-1  the transaction does not include deprecated or reserved record types or fields. The test assertions for Record Type-1 are also documented. The requirements in Annex C are silent regarding requirements for any specific Record Type included in the transaction other than Record Type-1. Tables of AN-2013 requirements and test assertions pertaining to specific Record Types (other than Record Type-1) are not documented in this CTMF document, but plans exist to document them in separate publications (National Institute of Standards and Technology Interagency Reports/NISTIRs). Annex D includes test notes and test exceptions that apply to requirements and assertions documented in Annex C as well as test notes and exceptions for those requirements which may be released in separate publications. 1Definitions of Type A and B testing are included in Section 4. Level 1, 2, and 3 testing are discussed in Section 5.3. The tables of requirements and test assertions in this publication address only Level 1 and 2 testing and Type-A testing. Assertions for Type-B testing are not included. The CTMF does not establish tests of characteristics (i.e., performance, acceptance, security, robustness) of products that generate the AN-2013 transactions. 2 Conformance Test Tool Characteristics AN-2013 conformance test tools that fully implement the CTMF for testing the AN-2013 requirements are expected to implement all the requirements of Section 5, the Conformance Testing Methodology section, including the procedures defined by Level 1 and Level 2 test assertions. Such tools are also expected to be capable of testing AN-2013 implementations against the assertions specified in Annex A for the mandatory requirements in AN-2013 and any requirements associated with Optional entities that are included in the transaction. Although many constructs (such as fields and subfields) specified in the AN-2013 standard are optional, their presence in a specific transaction indicates that the requirements specified for those constructs are mandatory (see “Implementation Required” in the table headers of the Tables of requirements and assertions format in Annex A). 3 References NIST Special Publication 500-290 Version 2 (2013), ANSI/NIST-ITL 1-2011 Update:2013, December 2013, Information Technology: American National Standard for Information Systems - Data Format for the Interchange of Fingerprint, Facial & Other Biometric Information, Incorporating ANSI/NIST 1-2011 Sup:Dental & ANSI/NIST-ITL 1-2011 Sup:Voice with additional new material Available at http://biometrics.nist.gov/cs_links/standard/ansi_2012/Update- Final_Approved_Version.pdf JPEG (Joint Photographic Experts Group), JPEG File Interchange Format, Version 1.02. Available at http://www.jpeg.org/public/jfif.pdf ISO/IEC 15444-1, JPEG 2000, Information Technology - Digital Compression and Coding of Continuous-Tone Still Images Part 1: Requirements and Guidelines. ISO/IEC 15444-2, Information technology — JPEG 2000 image coding system: Extension, available at: http://www.jpeg.org/metadata/15444-2.PDF ISO/IEC 15948:2004 Information Technology -- Computer graphics and image processing -- Portable Network Graphics (PNG): Functional specification. IAFIS-IC-0110 (V3.1) WSQ Gray-scale Fingerprint Image Compression Specification, October 4, 2010. 4 Terms and definitions AN-2013 ANSI/NIST-ITL 2011 Update: 2013 2assertion A test procedure that represents a specific aspect of a requirement found in the base standard. The assertion is expressed using the test assertion syntax defined by the CTMF. base standard ANSI/NIST-ITL 1-2011 Update: 2013, Data Format for the Interchange of Fingerprint, Facial & Other Biometric Information, NIST Special Publication 500-290 Version 2 - Incorporating ANSI/NIST 1-2011 Sup:Dental & ANSI/NIST-ITL 1-2011 Sup:Voice with additional new material. conformance The adherence of an implementation to all specified requirements as defined in the base standard. CTA Conformance Testing Architecture. CTM Conformance Testing Methodology. A description of the procedures necessary to test an implementation for conformance to the requirements specified in the base standard. CTMF Conformance Testing Methodology Framework. The foundational specification of the format and procedures that must be utilized to properly document and test requirements according to the base standard, and therefore establish a Conformance Testing Methodology. CTS Conformance Testing Suite. implementation A specific AN-2013 transaction. IUT Implementation under test. The implementation supplied by a vendor to a laboratory for conformance testing. test Also known as a conformance test or assertion test, it is the execution of the testing procedure defined by an assertion or set of assertions in order to obtain a statement of conformance. The result of the test is a Boolean value that determines the implementation’s conformity for the assertion. For a 3given requirement, if all tests pass for the associated assertions, then the implementation is considered to be conformant for that requirement. Type-A testing Type-A conformance testing checks the conformance of AN-2013 transactions to the requirements in the base standard. Type-B testing Type-B testing checks the ability to use an AN-2013 transaction, for example in a software application. 5 Conformance testing methodology The CTMF addresses only Level 1 and 2 testing and Type-A testing. Annex A lists test assertions for Level-1 and Level-2 requirements. While Level-3 requirements may be identified in Annex A, no related test assertions are documented (see “Hierarchy of conformance tests” for information regarding the three levels of conformance testing). Type-B testing is not addressed. 5.1 AN-2013 Requirements and Conformance Test Assertions Tables of AN-2013 requirements and conformance test assertions are documented in this publication and included in Annex A. AN-2103 transaction-related requirements (defined as requirements that are not related to a specific Record Type) as well as AN-2013 requirements and test assertions for Record Type 1 are included. The tables provide the information necessary to facilitate the development of conformance test assertions and testing tools. Each AN-2013 requirement identified in this publication is associated with one or more specified test assertions which collectively expect to form the complete set of procedures required to test an implementation for conformance to that requirement. More details on these types of test assertions are included below:  Transaction-related Requirements and Associated Test Assertions Table Includes AN-2013 requirements and associated test assertions related to all AN-2013 transactions, their data conventions, encodings, content, and other information not related to a specific Record. Examples include requirements and associated test assertions that describe (and document how to test) the structure and ordering of constructs that make up all AN-2013 transactions; nonexistence checks for deprecated Record Types 3, 5, and 6 as well as reserved Record Types 22 through 97; and requirements defined in Annex B, C, and G of AN-2013 related to AN-2013 transactions.  Record Type-1: Transaction Information Record Requirements and Associated Test Assertions Includes AN-2013 requirements and test assertions related to mandatory fields, subfields, information items, and XML Elements in Record Type-1 that must be met for every AN-2013 transaction; optional constructs for Record Type-1 (if any optional construct is present in a transaction, the defined requirements for those constructs become mandatory); and those related 4to testing that one and only one instance of Record Type-1 is present in every AN-2013 transaction. 5.2 Limitations and exceptions Section 1 describes the AN-2013 requirements that are documented with the associated required test assertions. Complementary publications are planned to be released which will document AN-2013 requirements and test assertions for specific AN-2013 Record Types in a format that complies with the CTMF described in this publication. A comprehensive AN-2013 CTMF (for testing all Record Types specified in the AN-2013 standard) would consist of the methodology documented in this publication as well as the set of requirements and assertions for each Record Type in AN-2013. While conformance of an implementation to all relevant requirements can be determined, no test tool is guaranteed to be comprehensive and prove that a given system generating or using AN‐2013 transactions is conformant under all possible circumstances. Well‐designed conformance tests can, however, test the most likely sources of problems and demonstrate non‐conformity (i.e., if errors are found, non‐conformance of the transaction is likely), but the absence of detected errors does not necessarily imply full conformance to the standard. 5.3 Hierarchy of conformance tests Three levels of conformance testing are briefly described. For each assertion included in the tables of requirements and assertions, a level of conformance testing is indicated. Level 1 conformance testing Level 1 conformance testing deals with the form and structure of the internal content and verifies that data structures exist and have allowable values. Specifically, it checks for the presence, structure, and value of each field, subfield, and information item in a transaction for conformance with the specification of the standard, both in terms of ranges and cardinality. Since Level 1 testing can be performed by a simple field-by-field reading of the standard and comparison to known values and their encoding, only the AN-2013 transactions are required for conformance testing, and no hardware or software components are used to create those transactions. Level 2 conformance testing Level 2 conformance testing deals with explicit requirements that check for internal consistency. Specifically, morphological conformance checks the relationships between fields, subfields, or information items within a transaction, including comparisons of values, as specified in the AN-2013 standard. Level 2 tests involve interactions between multiple values from different parts of the standard and sometimes from implicit observations that are not explicitly stated in the base standard. Thus, Level 2 tests require more complex validation than Level 1. Similar to Level 1 testing, Level 2 conformance testing only requires an AN-2013 transaction(s). Level 3 conformance testing 5Level 3 conformance testing checks if the biometric transaction is a faithful representation of the parent biometric data and ensures requirements are satisfied that are not merely Level 1 and Level 2 tests. Individual fields may have explicit semantic requirements for which conformance testing is significantly difficult or even impossible to test. Unlike Level 1 and Level 2 testing, Level 3 testing may require software and hardware components used to create the AN-2013 transactions, and may also require the subject and samples from which the biometric information stored in the transaction was collected. The requirements and assertion tables indicate whether Level 1 or Level 2 conformance testing is required to address the assertion identified in the test assertion. Required Level 3 conformance tests are not performed but they may be identified in the tables to indicate that the requirement is not addressed or that it is not currently testable. XML Schemas and Conformance Testing This CTMF, where possible, leverages the conformance-related information contained in the XML Schemas specified within the AN-2013 standard; however, the XML Schemas are only part of the overall testing. Section C.5.1 in the ANSI/NIST-ITL 1-2011 Update: 2013 standard specifies: To the extent possible, the schema defines data types and constraints that enforce the allowable content rules of the base standard. Nevertheless, the XML schema may not strictly enforce the allowable content. The base standard defines allowable content, and its requirements shall be met by implementers regardless of encoding method. Careful analysis of the XML Schemas, distributed on the ANSI/NIST-ITL Homepage Website, reveal discrepancies between the XML Schema requirements and the AN-2013 standard requirements:  Level 1 conformance testing – Not all allowable values have been specified within the XML Schema files.  Level 2 conformance testing – Many interrelationship, internal consistency, and interaction tests between multiple values from different sections of a transaction are incapable of being specified within the XML Schemas. The XML Schema files may not strictly enforce the allowable content in two ways:  By Being Overly Broad – Which allows for the testing of more values than the allowable values as specified in the AN-2013 standard requirements. If this is the case, there are additional Assertions specified in this CTMF to test for the actual range of values.  By Preventing Requirements – This case is when the XML Schema explicitly prevents base requirements specified in the AN-2013 standard from being tested. If this is the case the only option is to modify the XML Schema files. This modified Schema file is not included in this CTMF, but will be documented separately and made available at: http://www.nist.gov/itl/csd/biometrics/biocta_download.cfm. 5.4 Functional Documentation of Requirements and Test Assertions This section defines the syntax and format required to explicitly identify and document AN-2013 requirements and conformance test assertions in a concise manner that conveys the necessary information for conformance testing. Test Assertion Syntax 6Test Assertions represent the set of tests performed to determine conformance for a specific Requirement specified in AN-2013. The Test Assertion Syntax described in this section formalizes a method for representing these conformance tests using Expressions, Value-Types, Operators, and Operands to describe Test Assertions. In some instances, a Test Assertion cannot be clearly or easily represented using this syntax. These cases are referred to as Complex Assertions and English is used to express the assertion in the following format: Complex (Description), where Description is a summary of the Test Assertion. Additional syntax is described for use in complex Test Assertions only to help clarify their meaning. Test Assertions Test Assertions are evaluated to obtain a Test Result, which may be Pass, Fail, or Warning. Pass indicates the likelihood that the implementation conforms to that specific requirement, while Fail indicates again the likelihood that the implementation does not meet that specific requirement in the standard. Warning indicates that no errors were detected but provides additional information useful for the implementer. Test Assertions are made up of one or more Expressions as defined in the Expression Definitions table. The outermost Expression in any Test Assertion must return a Boolean or Test Result value as defined in the Value-Type Definitions table. If the outermost Expression returns a Boolean, it is converted to a Test Result in the following manner: True becomes Pass, and False becomes Fail. Value Types The following table lists the Value Types that may be used in the Expressions that make up the Assertion Syntax. The actual value, represented by VALUE in the table, is contained in parentheses just after the Value Type identifier. Value Types differ from Expressions, because Value Types cannot accept any operands; they accept only the defined values specified in the Valid Values column. For example, Int(-1) is the Integer value negative one. Due to the nature of AN-2013 transactions which may include multiple instances of each record type other than Type-1, any specified entity Value Type is not necessarily unique. For example, Fld(10.001) represents every occurrence of Field 1 in any Record Type-10. Table 5.1 - Assertion Syntax: Value-Type Definitions Value-Type Definitions Value Type Valid Values Syntax Boolean True, False. Bool(VALUE) TestResult Pass, Fail, Warning. Result(VALUE) Any of the values may be followed by a description in the form: Pass(description), Fail(description), Warning(description). The description is a message that should be displayed with the result. A description is optional. Numeric Any rational numeric value, for example: …-2,-1,0,1,2…, 1.1, -10.01, Num(VALUE) 0x32... Note that NumericInteger and NumericByte can be used in place of Numeric in any instance, since they are of type Numeric. However, the reverse is not true. Numeric values do not have leading zeros. For example, Num(02) is invalid, and should instead be Num(2). 7NumericInteger Any Integer Value: …-2,-1,0,1,2…, Int(VALUE) NumericByte One byte of binary data, represented in Hex. The value is represented Byte(VALUE) using “0x”. For example: 0x30 String Any sequence of valid Unicode characters represented by text. If the Str(VALUE) string contains characters that cannot be represented visually, the Unicode expression may be used to return a string given a set of Unicode codepoint values. If a string should be verbatim (for example there is a need to represent U+0030 as a string and not the Unicode equivalent) quotes should surround the value. To represent quotes in a string, “” is used. Examples: Str(123) is equal to Unicode(Set-Str([U+0031, U+0032, U+0033])). Both represent the string “123” Str(“”U+0030””) is “U+0030” Str(“U+0300”) is U+0300 Str(U+0030) is 0 StringList A list of valid String Value-Types separated by the | character in the StrList(VALUE) form: firstValue|secondValue|... Examples: StrList(This is|a|List) StrList(Unicode(U+001C)|1|2|Unicode(Set-Str([U+001E,U+001F]))) Set Any set of values included in the [] characters. The comma is used to Set-TYPE(VALUE), separate values. The “to” term is used to represent a range for where TYPE is any of Integer Numeric types. For example, the Value-Type Set-Num([0,2, 5 to 100]), Set-Str([A, B, C, Alfa, Bravo, Charlie]), Set- Syntax Fld([1.001, 1.002 to 1.005]), Set-Byte([0x00, 0xFF]) representations. Note that for sets of Strings, the comma is reserved as a separator between values. To represent a comma in a Set-Str, use U+002C. EntityTransaction The transaction that contains all other entities in the file. Transaction EntityRecord A Record represented by the numeric value of the Record Type. Rec(VALUE) Ex: Rec(10) is Record Type-10. EntityField The Field represented by the string in the form: RT.FN Fld(VALUE) RT is Record Type, FN is Field Number Ex: 10.998 is Field 998 in Record Type-10 EntitySubField The Subfield represented by the string operand in the form: RT.FN.SI SubF(VALUE) RT is Record Type, FN is Field Number, SI is the Subfield Index. If no SI is specified, then this refers to any Subfield in the Field. 1.003.1 is Subfield 1 in Field 1.003, 1.003 is each Subfield in Field 1.003; this is useful when subfields are unbounded, so that an assertion may address each subfield without knowing the number of subfields that will be present. EntityInfoItem The Information Item represented by the string in the form: RT.FN.IM InfoI(VALUE) RT is Record Type, FN is Field Number, IM is InfoItem Mnemonic Ex: 1.003.IDC is Info Item IDC in Field 1.003 EntityElement XML Element with name indicated by the string in the form: RT.FN.XN XElm(VALUE) RT is Record Type, FN is Field Number, XN is the Xml element name Ex:1.002.biom:TransactionMajorVersionValue EntityContainerElement XML Container Element (has no Field Number, and is only used to XCont(VALUE) organize other Xml Elements) indicated by the string in the form: RT.XN RT is Record Type, FN is Field Number, XN is the Xml element name Ex: XElmC(10.biom:FaceImage) 8In order to decrease redundancy, predefined values are listed here and used multiple times throughout the tables of requirements and assertions. Table 5.2 - Assertion Syntax: Defined Values Defined Values Defined Value Containing Values Notation Integer Set Set of all Integers (positive and negative integral values, including zero) Integers represented as a Set-Int. Numeric The string value is a Regular Expression in the form: LeadingZer Leading Zero Str(^(\+|-){0,1}0([0-9]+|[0-9]+\.[0-9]+)$) oNum The expression represents any numeric value (with or without a + or – sign) that has a leading zero followed by one or more numeric digits (which optionally may be followed by a decimal point and one or more numeric digits after the decimal). Time Index The string value is a Regular Expression in the form: ValidTimeI Str(^([0,1][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9].[0-9]{3}$) dx The expression represents time in the form hh:mm:ss.nnn, where hh is the two- digit hour,mm is the two-digit minute, ss is the two-digit seconds, and nnn is the three-digit milliseconds. (See section 7.7.2.5 of the standard). Date Range The string expression is a Regular Expression in the form: DateRange Estimate ^((Y[0-9]{1,2}){0,1}(M[0-9]{1,2}){0,1}(D[0-9]{1,2}){0,1})$ Estimate The expression represents the amount of time used as an offset (plus or minus), in the form YyyMmmDdd . Any of Yyy, Mmm, or Ddd may be omitted. Bold letters are constants; yy is the 2-digit year offset, mm is the 2-digit month offset, and dd is the 2-digit day offset. The bold letters are constants. Date Time The string expression is a Regular Expression in the form: DateTimeR Range Estimate ^((Y[0-9]{1,2}){0,1}(M[0-9]{1,2}){0,1}(D[0-9]{1,2}){0,1}(h[0-9]{1,2}){0,1}(m[0- angeEstima 9]{1,2}){0,1})$ te The expression represents the amount of time used as an offset (plus or minus), in the form YyyMmmDddhhhmmm . Any of Yyy, Mmm, Ddd, hhh, or mmm may be omitted. The bold letters are constants. Numeric Set-Str([0,1,2,3,4,5,6,7,8,9]) CharNum Characters Alphabetic Set-Str CharAlpha Characters ([A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,I,j,k,l,m,n,o,p, q,r,s,t,u,v,w,x,y,z]) Alphanumeric Set-Str ([0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z, CharAlpha Characters a,b,c,d,e,f,g,h,I,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]) Num Hexadecimal Set-Str([0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F]) CharHex Characters Unicode Set of all Unicode characters excluding the Special Reserved Characters CharU Characters (CharReserved) defined in this table. (Represented as a Set-Str of single- character strings). Base64 Set-Str([0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z, CharBase6 Characters a,b,c,d,e,f,g,h,I,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,/,+,=]) 4 7-bit ASCII All characters starting with Unicode(U+0000) and ending with Unicode(U+007F) CharAscii Characters excluding the Special Reserved Characters defined in this table. (Represented as a Set-Str of single-character strings). ASCII-Printable All characters starting with Unicode(U+0020) and ending with Unicode(U+007E). CharAsciiPr 9Characters intable Special Set-Str([Unicode(U+0002), Unicode(U+0003), Unicode(U+001C), CharReserv Reserved Unicode(U+001D), Unicode(U+001E), Unicode(U+001F)]) ed Characters (Special characters “STX”, “ETX”, “FS”, “GS”, “RS”, and “US”) Control Set-Str([Unicode(U+0000), Unicode(U+0001), Unicode(U+0004), CharCtrl Characters Unicode(U+0005), Unicode(U+0006), Unicode(U+0007), Unicode(U+0008), Unicode(U+0009) , Unicode(U+000A), Unicode(U+000B), Unicode(U+000C), Unicode(U+000D), Unicode(U+000E), Unicode(U+000F), Unicode(U+0010), Unicode(U+0011), Unicode(U+0012), Unicode(U+0013), Unicode(U+0014), Unicode(U+0015), Unicode(U+0016), Unicode(U+0017), Unicode(U+0018), Unicode(U+0019), Unicode(U+001A), Unicode(U+001B), Unicode(U+007F)]) (Control characters “NUL”, “SOH”, “EOT”, “ENQ”, “ACK”, “BEL”, “BS”, “HT”, “LF”, “VT”, “FF”, “CR”, “SO”, “SI”, “DLE”, “DC1”, “DC2”, “DC3”, “DC4”, “NAK”, “SYN”, “ETB”, “CAN”, “EM”, “SUB”, “ESC” and “DEL”) Resolution Set-Int([500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]) (This represents 500 Resolution Migration Path ppi minimum with 100% increase and a 5-digit maximum set by the field width Path-ppi (ppi) for THPS/TVPS) Resolution Set-Int([197, 394, 787, 1575, 3150, 6299, 12598, 25197, 50394]) (This represents Resolution Migration Path 197 ppcm minimum with 100 % increase and a 5-digit maximum set by the field Path-ppcm (ppcm) width for THPS/TVPS) ISO-3166-1 Set-Str representing all values in the ISO Country Code Standard ISO-3166-1. ISO-3166-1 Codes ISO-3166-1 Set-Str of all 2-character alphabetic codes in the ISO Country Code Standard ISO- ISO-3166- Alpha 2 Codes 3166-1. 1-Alpha2 ISO-3166-1 Set-Str of all 3-character alphabetic codes in the ISO Country Code Standard ISO- ISO-3166- Alpha 3 Codes 3166-1. 1-Alpha3 ISO-3166-1 Set-Str of all numeric codes in the ISO Country Code Standard ISO-3166-1. ISO-3166- Numeric Codes 1-Numeric GENC Codes Set-Str representing all values in the GENC Country Code Standard, Edition 2.0 GENC (NGA.STND.0033_2.0). GENC Alpha 2 Set-Str of all 2-character alphabetic codes in the GENC Country Code Standard, GENC- Codes Edition 2.0 (NGA.STND.0033_2.0). Alpha2 GENC Alpha 3 Set-Str of all 3-character alphabetic codes in the GENC Country Code Standard, GENC- Codes Edition 2.0 (NGA.STND.0033_2.0). Alpha3 GENC Numeric Set-Str of all numeric codes in the GENC Country Code Standard, Edition 2.0 GENC- Codes (NGA.STND.0033_2.0). Numeric The following String values represent image metadata tags that are defined for use in the syntax. Their positions within an image are based upon the compression algorithm of the image, indicated by the Image Type(s) column. Table 5.3 indicates tags that contain data, while Table 5.4 indicates tags that are used as positioning or identification markers in the image. For both tables, the Image Types may also be represented by the associated numeric code from Table 15 in AN-2013. Note: for PNG values in this table, values are converted from ppm to ppi or ppcm as indicated. This syntax follows the recommendation for rounding indicated in 7.7.8.5 of AN-2013 (round up). Table 5.3 - Assertion Syntax: Value-based Image Metadata Tags 10Image Metadata Term Image Implementation Type(s) JPEG 4th parameter of the Frame Header not counting the SOF marker JP2 2nd parameter of Image Header box Width PNG 1st parameter of IHDR chunk WSQ 5th parameter of SOF not counting the SOF marker JPEG 3rd parameter of the Frame Header not counting the SOF marker JP2 1st parameter of Image Header box Height PNG 2nd parameter of IHDR chunk WSQ 4th parameter of SOF not counting the SOF marker JPEG 4th parameter in JFIF Header not counting the APP0 Marker SamplingUnits JP2 Undefined PNG 3rd parameter of PHYS chunk (optional) WSQ Undefined JPEG 5th parameter in JFIF Header not counting the APP0 Marker HorzDensity-ppi JP2 Undefined PNG 0.0254 (meters/inch) x 1st parameter in PHYS Chunk (optional) WSQ Undefined JPEG 5th parameter in JFIF Header not counting the APP0 Marker HorzDensity-ppcm JP2 Undefined PNG 0.01 (meters/cm) x 1st parameter in PHYS Chunk (optional) WSQ Undefined VertDensity-ppi JPEG 6th parameter in JFIF Header not counting the APP0 Marker JP2 Undefined PNG 0.0254 (meters/inch) x 2nd parameter in PHYS Chunk (optional) WSQ Undefined JPEG 6th parameter in JFIF Header not counting the APP0 Marker VertDensity-ppcm JP2 Undefined PNG 0.01 (meters/cm) x 2nd parameter in PHYS Chunk (optional) WSQ Undefined JPEG 5th parameter in JFIF Header / 6th parameter in JFIF Header (not counting the APP0 Marker) JP2 Undefined AspectRatio PNG 1st parameter in PHYS Chunk / 2nd parameter in PHYS Chunk (optional) WSQ Undefined BPX JPEG 2nd parameter of the Frame Header not counting the SOF marker JP2 7 LSB of 4th parameter of ImgBox + 1 if 4th parameter of ImgBox is not 255 PNG 3rd parameter of IHDR chunk WSQ Undefined JPEG Undefined JP2 4th parameter of Colour Specification box CSP PNG 4th parameter of IHDR chunk WSQ Undefined 11Table 5.4 - Assertion Syntax: Marker-based Image Metadata Tags Image Metadata Image Type Valid Image Implementation Markers JPEG SOI Start of JPEG type image. SOF Start of frame in a JPEG type image. EOI End of a JPEG image. JFIF Header Frame for specifying JPEG type image metadata. Its inclusion is required by the standard. JP2 SigBox Signature Box that marks the start of a JP2 type image. HeadBox Header Box in a JP2 type image. ImgBox Image Header Box in a JP2 type image. EOI End of JP2 image. PNG PNGSig Signature of a PNG image. IHDR Image Header Chunk in a PNG image. IDAT Image Data Chunk in a PNG image. IEND Image End Chunk in a PNG image. WSQ SOI Start of WSQ type image. SOF Start of frame in a WSQ type image. EOI End of a WSQ image. Expressions Test Assertions are composed of one or more Expressions, which are statements that return a Value Type as defined in the Value-Type Definitions table. Each Expression has a single Operator, a set of valid Operands, and Return Type. Expressions may serve as Operands of other Expressions as long as their Return Type is a valid Operand for that Expression. The tables below include a complete description of the Expressions and their required Operators and Operands used throughout the requirements and assertion tables. The Operators are categorized according to the type of Expression in which they are used and the Return Type they produce. Return Types must be a valid Value Type. The tables indicate the following information for each Expression:  Expression Name: the name of the Expression  Description: an explanation of how the Expression is used to return the specified Value Type  Return Type: the Return Type that is returned from the Expression. The Return Type must be a valid Value Type.  Operands Types: the number and type of operands accepted by the Expression. In addition to the Value Type indicated, any Expression that returns that type can be used as an Operand. Underlined Operands are optional. If operands are not formatted properly, the test assertion that contains the expression has a failing TestResult.  Operator Syntax: the Operator used to represent the Expression in the assertion tables 12Boolean Expressions- These Expressions return Boolean Values. There are several types of Boolean Expressions including Relational (comparison between values), Logical (Boolean logic statements), and Conditional (if/then) Boolean expressions. Result Expressions- These Expressions return a Test Result, meaning that the value may be Pass, Fail, or Warning. This is the only expression type capable of generating a Warning. Numeric Expressions- These Expressions return a Numeric value or any of its sub-types: NumericInteger or NumericByte. String Expressions- These Expressions return a String value. Generic Expressions- These Expressions return values that depend upon the Operand Type used with the expression. Each Generic Expression is intended to be used with various Value-Types. Table 5.5 - Assertion Syntax: Expression Definitions Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax Equal To Relational Test for equality between Boolean Op1: Numeric or EQ(Op1, Op2) two operands Op1 and Op2. For String comparisons between String and Op2: Numeric or Numeric types, the String value is String converted to Numeric first (if it cannot be converted, the result is FALSE). Ex. EQ(Str(4.0), Num(4)) is TRUE Ex. EQ(Str(4.0), Str(4)) is FALSE Not Equal To Relational Test for non-equality Boolean Op1: Numeric or NEQ(Op1, Op2) between two operands Op1 and Op2. String For comparisons between String and Op2: Numeric or Numeric types, the String value is String n converted to Numeric first (if it cannot a be converted, the result is TRUE). e lo Greater Than Relational Test for if Op1 is greater Boolean Op1: Numeric GT(Op1, Op2) o B than Op2. Op2: Numeric Greater Than or Relational Test for if Op1 is greater Boolean Op1: Numeric GTE(Op1, Op2) Equal To than or equal to Op2. Op2: Numeric Less Than Relational Test for if Op1 is less than Boolean Op1: Numeric LT(Op1, Op2) Op2. Op2: Numeric Less Than or Equal To Relational Test for if Op1 is less than or Boolean Op1: Numeric LTE(Op1, Op2) equal to Op2. Op2: Numeric Range (Inclusive) Relational Test for if Op1 is in the range Boolean Op1: Numeric InRange(Op1, Op2, of values specified Op2 and Op3, where Op2: Numeric Op3) Op2 is the minimum numeric value and Op3: Numeric Op3 is the maximum numeric value. Ex: InRange(Num(10.1), Num(10.0), Num(10.3)) returns TRUE. 13Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax Member Of Relational Test for if the value Op1 is a Boolean Op1: Numeric or MO(Op1, Op2) contained within the set Op2. String Op2: Set-Numeric or Set or Set-String Op2 Set Type must match Op1 Value Type. Any Member Of Relational Test for if any values in the Boolean Op1: Set (any type) AnyMO(Op1, Op2) Set Op1 are a member of the Set Op2. Op2: Set (any type) The Set type of Op1 and Op2 must be the same. Is Subset Of Relational Test for if the Set Op1 is a Boolean Op1: Set (any type) SubSet(Op1, Op2) subset of the Set Op2, represented Op2: Set (any type) mathematically as Op1 ⊆ Op2. This The Set type of Op1 means that every value in Set Op1 must and Op2 must be the exist in Set Op2. If a value repeats in same. set Op1, only one instance is required in Set Op2. Note that this does not have to be a proper subset. One use of this Expression is to test for character types, for example: SubSet(Chars({Fld(1.002)}), CharNum) Logical And Logical Test returns the result of the Boolean Op1: Boolean AND(Op1, Op2) logical AND of two Boolean operands, Op2: Boolean Op1 and Op2. Returns TRUE only if both Op1 and Op2 are TRUE. Logical Or Logical Test returns the result of the Boolean Op1: Boolean OR(Op1, Op2) logical OR of two Boolean operands, Op2: Boolean Op1 and Op2. Returns TRUE if either Op1 or Op2 is TRUE. Logical Exclusive Or Logical Test returns the result of the Boolean Op1: Boolean XOR(Op1, Op2) logical XOR of two Boolean operands, Op2: Boolean Op1 and Op2. Returns TRUE if only one of the operands is TRUE and the other operand is FALSE. Logical Negate Logical Test returns a value that is the Boolean Op1: Boolean NOT(Op1) logical opposite of the operand, Op1. Returns TRUE only if Op1 is FALSE. Conditional If/Then Conditional Test evaluates the Boolean Op1: Boolean IfThen(Op1, Op2) conditional statement of IF Op1, THEN Op2: Boolean Op2, where Op1 and Op2 are of Boolean Value-Type. The expression returns Op2 if Op1 is TRUE and TRUE otherwise. Conditional Conditinal Test evaluates the Boolean Op1: Boolean IfThenElse(Op1, Op2, If/Then/Else conditional statement of IF Op1, THEN Op2: Boolean Op3) Op2, ELSE Op3, where Op1, Op2, and Op3: Boolean Op3 are of Boolean Value-Type. The 14Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax expression returns Op2 if Op1 is TRUE and Op3 otherwise. Conditional If and Conditional Test evaluates the Boolean Op1: Boolean Iff(Op1, Op2) Only If conditional statement of Op1 IF AND Op2: Boolean ONLY IF Op2. The expression is equivalent to IF Op1, THEN Op2 AND IF Op2, THEN Op1. Entity Present General Boolean Test returns a result Boolean Op1: Entity or Set- Present(Op1) indicating whether the entity or set of Entity Or entities represented by the operand Op2: Set-Entity AnyPresent(Op2) Op1 is present. AnyPresent indicates if Or any of the entities in the set Op2 are AllPresent(Op2) present. AllPresent indicates if all of the entities are present. Note: presence of Information Items is indicated by both the information separator tag and data being present. Ex: Present(Fld(1.001)) checks if Field 1.001 is present. Present(Set-Rec([10 to 15])) checks if Record Types 10 to 15 are present. Information Item General Boolean Test that returns a Boolean Op1: EntityField or Structure result indicating whether or not the EntitySubField Information Items indicated by the 1- Op2: Set-Integer based indexes in Op2 are present (with data) in the Field or Subfield represented by Op1. If Op2 is not specified, then all Information Items must have data. Note that Op1 is permitted to be more than one subfield, for example: InfoItemsHaveData(SubFld(1.003), Set- Int([1,2])) indicates that the first and second information item in every subfield of Field 1.003 must have data. Image Tags Match A General Boolean Test that returns a Boolean Op1: EntityField or Compression result indicating whether the Image in EntityElement Algorithm the field Op2 contains the valid Op2: EntityField or metadata tags (indicated in Table 5.4) EntityElement for the compression type specified in the field Op1. For uncompressed images, this test always returns TRUE. Image Tags Valid A General Boolean Test that returns a Boolean Op1: EntityField or result indicating whether the Image in EntityElement field Op1 contains valid image metadata tags for any of the Image Types specified in Table 5.4. For uncompressed images, this test always 15Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax returns TRUE. Image Tag Value A General Boolean Test that returns a Boolean Op1: EntityField or Compare result indicating whether the Image Tag EntityElement Op2 in the Image in field Op3 matches Op2: String the value in field Op1. For Op3: EntityField or uncompressed images, this test always EntityElement returns TRUE (with a message indicating that these tests are not performed on uncompressed images). Op2 is a Term value from Table 5.3. Image Tag Value A General Boolean Test that returns a Boolean Op1: EntityField or Compare Aspect result indicating whether the Aspect EntityElement Ratio Ratio (Table 5.3) in the Image in field Op2: EntityField or Op3 matches the ratio of the values in EntityElement Op1 to Op2. For uncompressed images, Op3: EntityField or this test always returns TRUE (with a EntityElement message indicating that these tests are not performed on uncompressed images). For divide by zero, this test returns FALSE. If/Then Result Conditional Test evaluates the Test Result Op1: Boolean IfThenResult(Op1, Op2) conditional statement of IF Op1, THEN Op2: TestResult Op2. The expression returns Op2 if Op1 is TRUE and PASS otherwise. If/Then/Else Result Conditional Test evaluates the Test Result Op1: Boolean IfThenElseResult(Op1, conditional statement of IF Op1, THEN Op2: TestResult or Op2, Op3) Op2, ELSE Op3. The expression returns Boolean t Op2 if Op1 is TRUE and Op3 otherwise. Op3: TestResult or lu s If Op2 or Op3 is of type Boolean, the Boolean e R Expression returns PASS for TRUE and FAIL for FALSE values. At least one of Op2 and Op3 must be a Test Result Generate Test Result Returns a TestResult that is provided as Test Result Op1: Boolean or ReturnResult(Op1) the operand Op1. If Op1 is Boolean, TestResult then True is converted to Pass and False is Converted to Fail. Numeric Value Returns the Numeric Value Numeric Op1: String or Byte NV(Op1) represented by the operand Op1. If Set Op1 is a String, it must be a properly formatted number with no leading c zeros. If Op1 is a Byte Set, the entire ir e set of bytes is interpreted as a value. m u Ex: NV(Set-Byte([0x01, 0x00])) is 256 N Count Returns the number of values found in NumericIntege Op1: Set (Any Type) Count(Op1) the Set operand Op1. r This is frequently used with Entity Sets to find the occurrence of an entity, for 16Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax example: Count(Recs(Rec(10)) provides the number of Record Type-10. Also used to count the number of characters or bytes: Count(Chars({Fld(1.001)})) provides the number of characters in the field. Count(B{Rec(1)}) provides the number of raw bytes in the record. Record Type Returns the Record Type of the Numeric Op1: EntityRecord, RecType(Op1) operand Op1. EntityField, EntitySubField, EntityInfoItem, or EntityElement Field Number Returns the field number of the Numeric Op1: EntityField, FieldNum(Op1) operand Op1. EntitySubField, EntityInfoItem, or EntityElement Modulo Returns the remainder of the Op1 Numeric Op1: NumericInteger Mod(Op1, Op2) divided by Op2. Op2: NumericInteger Add Returns the sum of the two operands Numeric Op1: Numeric Add(Op1, Op2) Op1 and Op2. Op2: Numeric Subtract Returns the difference of the two Numeric Op1: Numeric Sub(Op1, Op2) operands Op1 and Op2. Op2: Numeric Multiply Returns the product of the two Numeric Op1: Numeric Mult(Op1, Op2) operands Op1 and Op2. Op2: Numeric Divide Returns the quotient of the two Numeric Op1: Numeric Div(Op1, Op2) operands Op1 and Op2. Op2: Numeric Minimum Returns the minimum numeric value in Numeric Op1: Set-Numeric Min(Op1) the set Op1. Maximum Returns the maximum numeric value in Numeric Op1: Set-Numeric Max(Op1) the set Op2. 17Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax String Value Returns the String Value generated by String Op1: EntityField, {Op1} decoding the binary data of the Entity EntityInfoItem, or Operand Op1 according to the EntityElement specified character encoding for that Entity. For EntityElements, leading and trailing whitespace is ignored. Use WS{Op1} to force leading and trailing whitespace to be included for EntityElements. This is important because XML Elements frequently contain leading and trailing whitespace e that is not part of the data, but rather for formatting. String Value (With Returns the String Value (including String Op1: EntityElement WS{Op1} Leading and Trailing leading and trailing whitespace) Whitespace) generated by decoding the binary data of the EntityElement Operand Op1 according to the specified character encoding for that Entity. g Element Name Returns the String Value that String Op1: EntityElement or ElmName(Op1) n ir represents the XML Element name. EntityContainerEleme t S nt String from ASCII Returns the String Value of the ASCII String Op1: Numeric or Set- ASCII(Op1) code operand Op1. If any value in the Numeric operand is outside the range of 7-bit ASCII values, this expression returns an empty String. For Set-Numeric operands, each number in the set represents one ASCII character. Ex. ASCII(Set-Num([0x30, 0x31])) is 01 and ASCII(Num(33)) is ! String from Unicode Returns the String Value of the Unicode String Op1: String or String Unicode(Op1) Codepoint operand Op1. If any Set codepoint in the operand is invalid, it returns an empty String. For String sets, each string represents one Unicode codepoint (and thus one character) Ex. Unicode(Set-Str([U+0030, U+0033])) is 03 Byte Values Returns a Set of Byte Values Set- Op1: EntityField, Bytes(Op1) representing the exact binary data NumericByte EntityInfoItem, contained in the Entity Operand Op1 in EntitySubField, Big-Endian format. Note: this includes EntityRecord t e any separator characters. S If Op1 is an EntityField, the field number FN (e.g. “1.001:”) is not part of the byte data. However, if Op1 is an EntityRecord, all data in the record, 18Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax including field numbers, is part of the data. Character Values Returns a Set of String Values, with Set-String Op1: String Chars(Op1) each string representing one character in the operand Op1. Ex: Chars(Str(value)) is Set- Str([v,a,l,u,e]) List Values Returns the Set of String Values found Set-String Op1: StringList ListValues(Op1) in the StringList Op1. Ex: ListValues(StrList(A|B|C)) is Set- Str([A,B,C]) String Values Returns the set of String Values Set-String Op1: Set-Entity Set-{Op1} generated by decoding the binary data of each of the Entities in the Entity-Set Operand Op1 according to the specified character encoding for that Entity. For EntityElements, leading and trailing whitespace is ignored. Use WS{Op1} to force leading and trailing whitespace to be included for EntityElements. This is important because XML Elements frequently contain leading and trailing whitespace e that is not part of the data, but rather for formatting. Numeric Values Returns the set of Numeric Values Set-Numeric Op1: Set-String Set-NV(Op1) represented by the set of Strings in Op1, which must be properly formatted numbers with no leading zeros. Binary from Base64 Returns a set of bytes that represents Set- Op1: String B64toBytes(Op1) the decoded Base-64 value found in NumericByte Op1. If Op1 is not a valid Base-64 Op1 must be a valid encoded string, this expression returns Base-64 string an empty set. Record Set Returns the Set of Records present in Set- Op1: NumericInteger, Recs(Op1) the transaction. If Op1 is specified, it EntityRecord Set-NumericInteger, represents the record type desired. An or String Integer value represents the Record Type. A Set-NumericInteger represents any number of Record Types, and a string represents the XML Element name of the record types desired. For example: Recs(Int(10)) returns the Set of Type-10 Records present in the transaction. Recs(Set-Int([13,14])) is the Set of Type-13 and Type-14 Records. 19Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax Recs represents all records in the transaction. Field Set In Returns the Set of Fields in the Set-EntityField Op1: NumericInteger, FldsInTx(Op1) Transaction Transaction with the specified Field EntityField, or Number, that match the EntityField, or EntityRecord that exist in the EntityRecord indicated by operand Op1. For example: FldsInTx(Int(999)) is the Set of Fields 999 in any Record Type in the Transaction. FldsInTx(Fld(13.002)) is the set of Field 002 in any Type-13 Record. FldsInTx(Rec(10)) is the set of Fields in every Record Type-10. FldsInTx is the Set of all Fields in the Transaction. Note: This is the set of Fields among separate Records in the Transaction. For Fields in a single Record instance use FldsInRec. Field Set In Record Returns the Set of Fields in a given Set-EntityField Op1: EntityRecord FldsInRec(Op1, Op2) Record operand Op1. If Op2 is specified Op2: NumericInteger it is the Field Number desired. For example: FldsInRec(Rec(1)) is the Set of Fields in Record Type-1. FldsInRec(Rec(10),Int(1)) is the set of Fields 001 in a single Record Type-10. Note: This is the set of Fields in one instance of a record. For Fields among several separate Records, use FldsInTx. Subfield Set Returns the Set of SubFields found in Set- Op1: EntityField SubFldsIn(Op1) the Field operand Op1. EntitySubfield Information Item Set Returns the Set of Information Items in Set- Op1: EntityField or InfoItemsInTx(Op1) In Transaction the Transaction. If Op1 is specified, it EntityInfoItem EntitySubField represents the Information Item mnemonic desired. For example: InfoItemsInTx(Str(IDC)) is the Set of Information Items with mnemonic “IDC”. InfoItemsInTx is the Set of all information items in the transaction. This expression identifies information items using their information separator tags, so even empty information items are returned by this expression. Note: This is the set of Information Items among separate Records in the Transaction. For Information Items in 20Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax a single Record instance use InfoItemsIn. Information Item Set Returns the Set of Information Items Set- Op1: EntityField or InfoItemsIn(Op1, Op2) In Record found in the Field or Subfield operand EntityInfoItem EntitySubField Op1. If Op2 is specified, it represents Op2: String the Information Item mnemonic desired. For example: InfoItemsIn(Fld(1.003), Str(IDC)) is the Set of Information Items with mnemonic “IDC” in field 1.003. This expression identifies information items using their information separator tags, so even empty information items are returned by this expression. Note: This is the set of Information Items in one instance of a record. For Information Items among several separate Records, use InfoItemsInTx. Element Set in Returns the Set of XML elements in Set- Op1: EntityElement or ElmsInTx(Op1, Op2) Transaction every Op1 in the transaction. If Op2 is EntityElement EntityContainerEleme Or used, it provides the name of the or nt ChElmsInTx(Op1,Op2) desired elements. If ChElmsInTx is SetEntityConta Op2: EntityElement or used, only direct child elements are inerElement EntityContainerEleme considered. ElmsInTx with no operands nt returns the set of all elements in the transaction. Note: This is the set of elements among all Op1 instances in the Transaction. For elements in a single Op1 instance use ElmsIn. Element Set Returns the Set of XML elements in a Set- Op1: EntityElement or ElmsIn(Op1, Op2) specific Op1. If Op2 is used, it provides EntityElement EntityContainerEleme Or the name of the desired elements. If or nt ChElmsIn(Op1,Op2)Op1 ChElmsIn is used, only direct child SetEntityConta Op2: EntityElement or ,Op2) elements are considered. Note: This is inerElement EntityContainerEleme the set of elements in one instance of nt an Op1. For elements among several instances of Op1, use ElmsInTx. Select From Set Returns the Value found at the Any Op1: NumericInteger Select(Op1, Op2) specified 1-based index in the Set Op1. Op2: Set (Any Type) Example: Select(Int(2),Set- Str([A,B,C,D])) will return Str(B), the c ir second String in the set. e n e Select SubSet Returns the subset of Set Op2 indicated Set-Any Op1: Set-Int SelectSubSet(Op1, Op2) G by the 1-based index values Op2: Set (Any Type) represented by Set-Int Op1. Invalid indices are ingored. Example: 21Expression Definitions Expression Name Description Return Type Operand Types Operator Syntax SelectSubSet(Set-Int[1,3,4], Set- Str([A,B,C])) will return Set-Str([A,C]) (index 4 is ignored) First Occurrence Returns the First Value in the Set Op1. Any Op1: Set (Any Type) FirstIn(Op1) Last Occurrence Returns the Last Value in the SetOp2. Any Op1: Set (Any Type) LastIn(Op1) Set Union Returns the Set Union of the two Set Set (Any Type) Op1: Set (Any Type) Union(Op1, Op2) operands Op1 and Op2 that contains all Op2: Set (Any Type) of the members of both. Op1 and Op2 must be Ex: Union(Set-Num([1.0,2.2]),Set- of same set type. Num([2.2, 10, 200.1])) is Set-Num([1.0, 2.2, 10, 200.1]) Complex Test Assertions Some Test Assertions cannot be represented using the well-defined Test Assertion Syntax, or require specific instances of entities to be identified rather than every occurrence as defined by the Entity Value-Types. Such Assertions require a textual description of the test that must be performed. To assist in streamlining most of these textual descriptions, a Complex Assertion Syntax is included in this section. This Complex Assertion Syntax does not represent a complete syntax, nor is it necessarily well-defined; its purpose is only to provide a toolset to assist in explaining Complex Test Assertions. The Complex Assertion Syntax is composed of Complex Expressions, Complex Value- Types, and Complex Procedures. Complex Procedures are operations that are repeated for several Assertions, but do not return a value. The format is: Complex(Description), where Description is composed of Complex Expressions, Complex Value-Types, Complex Procedures, and plain English. Description may also be a message such as “See Note” when the test assertion is too large to be contained in the table, and must be explained in a note or other location. Complex Expressions and Value-Types The Expressions found in this section are used to help clarify Complex Assertions that cannot easily be represented in the Assertion Syntax. Table 5.6 - Assertion Syntax: Complex Expression Definitions Complex Expression Definitions Expression Description Return Type Operand Types Operator Syntax Name Parent Returns the Parent of the Entity (the GenericEntity Op1: GenericEntity Parent(Op1) Entity that contains the specified Entity). 22Pair Returns a set of Entity Pairs that Set Op1: EntityQuery Pair(Op1) satisfy the Entity Query. The pair is (GenericEntity) represented in the rest of the Assertion by A,B. Table 5.7 - Assertion Syntax: Complex Value-Type Definitions Complex Value-Type Definitions Value Type Valid Values Syntax GenericEntity Any generic entity defined for either encoding: Transaction, GenEntity(VALUE) Record, Field, Subfield, InfoItem, or Element. This is a generic representation that does not indicate a specific entity. EntityQuery A search query for a specific instance of an Entity. The general Query(VALUE) structure of the query is: P:N in Q ST(condition) For example, InfoItem:2 in Subfield ST(EQ({InfoItem}, Str(1)) Note that any of the elements of the query are optional, for example: P:N or P in Q or P ST(condition) or simply P Complex Procedures The procedures described in this section list common tasks that are repeated for several Complex Assertions. They are not Expressions because they do not return a value. Table 5.8 - Assertion Syntax: Complex Procedure Definitions Complex Procedure Definitions Name Description Return Type Operand Types Operator Syntax Variable Uses the String value as a variable to None Op1: String Var(Op1)(Expression) represent the containing expression for the remainder of the Assertion Text. This is used to avoid repetitions in the assertion text. For Loop Evaluates the containing expressions None Op1: NumericInteger ForX(Op1, Op2) for each value in the specified range Op2: NumericInteger (Expressions) of the operator values (Op1 to Op2). X represents the current value in the loop. For Each Loop The For Each Loop evaluates the None Op1: Set (Any Type) ForEachX(Op1) containing expressions for each value (Expressions) in the set Operator. X represents the current value in the loop. For nested loops, XN represents the current value of the loop, where N is the level of nesting. Next Iteration Only for use in For Each Loop: None None Next(X) references the next occurrence of X. Previous Iteration Only for use in For Each Loop: None None Previous(X) references the previous occurrence of X. 23Field Definitions and Structures (Traditional Encoding) The test assertion syntax represents all field types as a field that contains a list of one or more subfields, each of which contains a list of one or more information items. Fig. 5.9 is a representation of how each field type is represented by the test assertion syntax:  Single Information Item: Field with one subfield containing one information item.  Multiple Information Items: Field with one subfield containing multiple information items.  Subfields Repeating Sets of Information Items: Field with one or more subfields, each containing sets of one or more information items.  Subfields Repeating Values: Field with one or more subfields, each containing one information item. Figure 5.9 - Generic AN-2013 Field Structure Field Record Field : Subfield(s) G . Type Number Information Item(s) S Unless otherwise stated, the Test Assertion Syntax expresses all field structures using the Traditional notation of record type and field number (e.g., 1.001) as well as subfield and information item indices when appropriate. However, the NIEM-XML encoding has no concept of subfields or information items. Instead, the XML encoding uses sub elements. Annex G of the AN-2013 standard - NIEM-conformant Encoding Rules - can be used to translate the listed values for Traditional structures to the XML equivalent. In some cases the tables of requirements and assertions list the XML element names when necessary for clarifying an assertion. Tables of requirements and assertions format Table Layout A Requirement is related to one or more Test Assertions. Therefore, a single Requirement may require more than one test assertion row of a table. To represent this association (from left to right), a Requirement is listed first, followed by the related assertion(s). Test notes may be included for any specific assertion to help clarify its meaning when necessary. Information contained in the table is described by the table column headers later in this section. The AN-2013 contains requirements for several biometric record types, data conventions, and data encodings contained in various clauses, tables, figures, and annexes throughout the standard. The complex and detailed nature of the AN-2013 standard, including the variety of ways that requirements are specified, increases the chance that certain requirements may be stated in more than one section of the standard. In such cases, the table of requirements and assertions would indicate that the requirement is a duplicate requirement. The AN-2013 section numbers where the requirement is specified would be indicated. If there are too many to list, the requirement would be labeled a generic requirement, where other sections define it with more clarity and detail. For all duplicate or generic requirements, no assertions would be defined. The columns of the table 24dedicated to assertion information may be merged and filled with a notification of the duplicate requirement. The format would be as follows, where Optional Message is any text that helps describe why the requirement is a duplicate or generic:  Duplicate Requirement. Optional Message. See AN-2013 Section:  Generic Requirement. Optional Message. Specific instances are defined more precisely in several sections of AN-2013. For an example of the table layout specified by the CTMF, see Annex B. Table Headers The following describe the headings for the tables of requirements and assertions format:  Requirement # and ID: Includes a unique AN-2013 requirement number and a unique identifier for the requirement and associated assertion or set of assertions. For Record Type requirements, the Requirement # is in the form RTN.M, where N is the Record Type and M is the sequential number of the requirement (for requirements in the annexes the form is AN followed the Annex letter). For sections not associated with a record type and annexes, the prefix is SEC followed by the section number. If additional requirements must be entered in the future, the number M may change. The Requirement ID provides reference to the type of requirement (e.g., transaction, record, or field), and is in the form of “Type: Description” where type may be “Transaction”, “Record”, or “Field”. For requirements found in Annex B of the AN-2013 standard, the Requirement ID is preceded by “Traditional-”. For requirements found in Annexes C and G of the AN-2013 standard, the Requirement ID is preceded by “NIEM-”.  Ref. in Base Std. (Reference in Base Standard): Identifies the clause (or section) where the requirement is included in the AN-2013 standard. In some cases the reference includes additional information such as a Table number.  Requirement Summary: Provides a summary of the requirement detailed as textual information or an interpretation of the requirement in the standard. It provides the essentials of the requirement but may not provide all the text necessary to understand it.  Level: Indicates whether Level 1 or Level 2 conformance testing is required to address the assertion identified in the Assertion ID column of the same row. Level 3 conformance tests are indicated only when necessary to show that the requirement is not currently testable or addressed.  Assertion ID: Provides an identifier of a specific test assertion within the set of test assertions associated with a requirement.  Test Assertion: Provides, whenever possible, a mathematical equation or a procedure using the language specified by the Assertion Syntax.  Notes: Contains the ID of the test note, in the form t##. Test notes provide additional information related to the assertion and are included below the tables.  Imp. Required (Implementation Required): The Imp. Required column indicates whether or not the assertion must be supported in the Imp. Support column. The format is CondCode- Entity, where: Entity: 25This indicates the entity (Field, Subfield, etc.) that is the primary subject of the assertion. The assertion must be tested for every instance of this entity in the transaction. This is particularly useful for assertions that contain more than one entity (generally Level-2 assertions). The syntax is any Entity type in Table 5.1 (Assertion Syntax: Value-Type Definitions Value-Types) defined in the Assertion Syntax. Cond Code: This indicates the Cond Code (as specified in AN-2013) of the Entity that is the subject of the assertion. The Cond Code indicates whether or not the entity must be present. For XML Elements that do not relate exactly one-to-one with Traditional constructs, the Cond Code is M (Mandatory) if the Cardinality is greater than 0 and O (Optional) otherwise. All assertions associated with entities that have Mandatory Cond Codes must be claimed under Implementation Support. Note that the Cond Code of an entity is dependent upon the inclusion of the parent record or field in the IUT. For example, Field 10.001 with Cond Code M is required to be present (and therefore its related assertions are required to be claimed) only if a Type-10 Record is included. As another example, 1.013-DNM is mandatory only if the optional field 1.013 is included. It should also be noted that the Cond Code only applies if the assertion is related to the transaction’s encoding as indicated by the Enc. (Encoding) column. The Cond Code values are: o M: Mandatory – entity must be present, assertion must be claimed o O: Optional – entity not required to be present, assertion not required to be claimed o D: Dependent – presence of entity is dependent upon certain conditions specified in the AN-2013 standard. If the entity is required to be present, the assertion must be claimed. o M⇑: Mandatory within the optional field/subfield – entity must be present if the containing field/subfield is present, and the assertion must then be claimed. o O⇑: Optional within the optional field/subfield – entity is not required to be present, even if the containing field/subfield is present. The assertion is not required to be claimed. Note: For Optional or Dependent Cond Codes, if the entity is present in the IUT (although it is not required to be), the related assertion must be claimed. Example: M-Fld(10.001). The subject of the assertion is Field 10.001 with Cond Code M, meaning that the assertion must be tested for every instance of Field 10.001. This is a Mandatory field (M), indicating that this assertion must be claimed given that Record Type-10 is present in the IUT.  Imp. Support (Implementation Support): Denotes a supplier’s implementation support of a particular assertion (“Y”/”N”). A note can follow the table when providing more details of implementation support (or the lack of it) is required. For assertions with Mandatory Imp. Required values, the Imp. Support should be Y given that the parent Record or Field is also supported.  Supported Range: Indicates a range of values supported, especially when it is different than the full range of values specified in the standard. When an information item is specified as a single value, or does not address a range of values, a N/A should be used.  Test Result: This column is used to denote the test results. The result is one of “Pass”, “Fail”, or “Warning”. Explanatory notes can be added below the table, for example when a 26Warning is given. The result is the value provided by evaluating the test described in the Test Assertion column.  Enc. – (Encoding): This table header indicates which assertions differ (in values required or conditions) between Traditional and NIEM encoding. This table header does not indicate which assertions are addressed by the XML Schema and which will need to be addressed in code. Valid values are: o T: The assertion only applies to the Traditional encoding as described in Annex B of AN-2013. o X: The assertion only applies to the NIEM-conformant (XML) encoding as described in Annex C of AN-2013. o B: The assertion is applicable to both Traditional and NIEM (XML) encoding.  Following the conventions in the AN-2013 standard, test Assertions are expressed using constructs (fields, records, etc.) found in Traditional encoding (such as 1.002). The same assertion applies for the XML elements that correspond to the Traditional constructs. For example, 10.006 in Traditional Encoding corresponds to XML Element <biom:ImageHorizontalLineLengthPixelQuantity>. Annex G of the AN-2013 provides a mapping between Traditional and XML encodings. 5.5 Claim of Supported Test Assertions The table format for requirements and assertions provides the means for the developers of implementations under test (IUT) to claim in the tables the list of all the assertions supported. This information is useful to the IUT supplier as a checklist on the content of their implementations and also useful to testing laboratories that would evaluate conformance of these IUTs against the supplier’s claims. Two columns in the tables are included to provide this information: Implementation Support column (YES/NO/Partial) and Supported Range column (if Implementation Support is “Partial”, the supported range should be provided). The minimum implementation requirements are documented in Annex A. The Implementation Required (Imp. Required) column indicates the entity related to each assertion, and the Cond Code for that entity. A Mandatory Cond Code indicates that the entity must be present, and therefore the assertion must be claimed. Such Cond Codes only apply if the containing Record or Field is also present—for example, 10.001 is Mandatory, but only if the IUT contains a Record Type-10. Regardless of the supplier claims, if an entity (Field, Subfield, etc.) is included in the IUT, the test assertions related to that entity will be tested and should be reported by a conformance test tool. It is recommended that if the IUTs are sent to a testing laboratory, the IUT provider submit the information below to the laboratory:  Provider name  Provider address  Transaction identifier  Transaction version number  Additional implementation information (optional)  Submission date 27 For each claimed Record Type, provide the Record Type number and whether or not (Yes or No) there are any known deviations from (or exceptions to) the requirements found in the base standard and identified in the Conformance Testing Methodology for the associated Record Types in the IUT. For specific exceptions, the Implementation Support column of the tables of requirements and assertions can be used to indicate the difference on a per-assertion basis. In addition, if the deviation is general and applies to the entire Record Type, a description should be provided. This option is useful for cases where there have been modifications to the base standard that are not reflected in the conformance testing methodology, where the IUT provider believes there is a defect in the base standard or conformance testing methodology, and other instances where the implementation does not fully conform to the AN-2013 standard requirements. The testing laboratory may use testing tools that implement this CTMF and any the test assertions included in any derivative conformant publications (such as those which document additional requirements) to provide a determination of the level of conformance of the IUT to the AN-2013 standard. 28Annex A: Minimum Support for AN-2013 Record Types and Interrelated Fields A.1 Minimum Conformance This document includes conformance test assertions for all the transaction-related requirements specified in AN-2013. This document does not include test assertions for Record Types other than Record Type 1. This section identifies the AN-2013 requirements and the conformance test assertions that are required for every transaction according to the terms specified in the AN-2013 standard. At a minimum, AN-2013 requires that:  the transaction adheres to its specified encoding (Traditional or NIEM-XML) requirements  the transaction includes one and only one Record Type-1  Record Type-1 is encoded exclusively in 7-bit ASCII (for Traditional Encoding)  Record Type-1 is conformant to the requirements specified for its fields, subfields, and information items. o All mandatory fields, subfields, and information items in Record Type-1 must be present (with data), and the requirements for those entities must be met. o Optional and dependent fields, subfields, and information items that are present in Record Type-1 must be conformant to the requirements specified for those entities.  the transaction includes at least one other record of a type other than Record Type-1  the transaction does not include deprecated or reserved record types or fields The AN-2013 requirements listed above constitute what is indicated in this document as the minimal conformance for any AN-2013 transaction, according to the requirements specified by AN-2013. Note, however, that minimal conformance is silent regarding the requirements for individual Records other than Record Type-1. For example, a minimally conformant AN-2013 transaction may include a non-conformant Record Type-10. A.2 Interrelated Field Support Section 7: Information Common to Several Record Types in the AN-2013 standard includes requirements for fields that are common among various record types. These requirements are contained in Annex C, in the table of requirements and assertions associated with Section 7 of the AN-2013 standard. Below is a list of the common fields with requirements specified in Annex C of this CTMF. Table A.1 - AN-2013 Interrelated Field Support 29Support for AN-2013 Interrelated Fields Number Field Contents Support xx.001 Record header All Record Types. See Field: xx.001-Record Header xx.002 Information designation character / IDC All Record Types except Record Type-1. See Field: xx.002-IDC xx.995 Associated Context / ASC Record Types 10 and above, not including 21 and 98. See Field: xx.995-ASC through Field: xx.995-ASC-ASP xx.997 Source Representation / SOR Record Types 10 and above, not including 18, 21, and 98. See Field: xx.997-SOR through Field: xx.997-SOR-RSP xx.016 Segments / SEG Record Types 20 and 21. See Field: xx.997-SOR-RSP and Field: xx.995-ASC-ASP xx.021 SRN, ACN Record Types 20 and 21. See Field: xx.997-SOR-SRN and Field: xx.995-ASC-ACN 30Annex B: Sample Requirement and Assertion Table Format This section describes the layout of the table-based requirements and assertions format required by the CTMF. Figure B.1 – Sample Requirements and Assertions Table Req. # - ID Red. In Requirement L Assertion Test N Imp. Imp. Supported Test E Base Summary e ID Assertion o Required Support Range Result n Std. v t c e e . l s RTX.1 – N.N, Requirement text: verbatim from the base 1 Assertion ID Assertion summary written using the Test M-Fld(1.001) Warning T Requirement Table Z standard or a summary. 1 Assertion Syntax – this one is for Traditional ID encoding 1 Assertion ID Assertion summary written using the Test t## O- X 2 Assertion Syntax – this one is for XML encoding 2 Assertion ID Assertion summary written using the Test B N Assertion Syntax – one or more assertions are listed per Requirement RTX.2– M.M Requirement text: verbatim from the base 1 Assertion ID Assertion summary written using the Test B Requirement standard or a summary. 1 Assertion Syntax – this one is for both encodings ID2 31Annex C: Tables of Requirements and Assertions The CTMF allows for all requirements and assertions to be documented for AN-2013. The full range of requirements and assertions are not included in this publication. The requirements necessary for minimum conformance as indicated in Annex A are included as are requirements for data formats, encodings, and those related to several record types. This Annex lists the tables of requirements and assertions common to most AN-2013 transactions; the AN-2013 requirement types and the reason for their inclusion are provided below: AN-2013 Section 5: Data Conventions Requirements for data conventions describe the structure and ordering of constructs that make up all AN-2013 transactions. Requirements for deprecated Record Types 3, 5, and 6 are also included to check for nonexistence of these Record Types. Additionally an assertion is specified that checks for the nonexistence of reserved Record Types 22 through 97. AN-2013 Section 7: Information Common to Several Record Types Information common to several record types refers to fields and other constructs that are defined once in the AN-2013 standard, and repeated for several record types. While these requirements may not be relevant to every transaction, a portion of these requirements are relevant to a large number of transactions. AN-2013 Section 8.1 Record Type-1: Transaction information record One and only one instance of Record Type-1 is required to be included in every AN-2013 transaction. The requirements associated with mandatory fields, subfields, information items, and XML Elements in Record Type-1 must be met for every AN-2013 transaction. Note that if any optional construct is present in any transaction, the defined requirements for those constructs are mandatory for conformance. An optional construct does not indicate an optional requirement. AN-2013 Annex B: Traditional Encoding Traditional encoding specifies requirements that describe the general makeup of any traditionally-encoded AN-2013 transaction. AN-2013 Annex C: NIEM Conformant encoding NIEM conformant encoding specifies requirements that describe the general makeup of any XML-encoded AN-2013 transaction. AN-2013 Annex G: Mapping to the NIEM IEPD Mapping to the NIEM IEPD provides the information necessary to interpret requirements represented in Traditional Encoding notation for XML-encoded transactions. The mapping indicates instances where the relationship between Traditional constructs (fields, subfields, etc.) is not one-to-one with XML elements. 32Table C.1 - Assertions for Transaction-related Requirements Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements TX.1 - Tran 5.1, There may be multiple records in a 1 Transaction EQ M- T saction: 5.3.1, transaction of each record type other than -Type-1- ( Transaction Required Annex G Type-1. The only required record Type is Required Count(Recs(Int(1))), Record Type-1, which is used to describe the Int(1) Types transaction. There shall be at least one ) other record type from Table 3 1 NIEM- EQ M- X accompanying a Record Type-1. Transaction ( Transaction - Count(Recs(Str(itl:PackageInformationRecord))), Transmissions to be exchanged are PackageInf Int(1) required to contain one and only one Type- ormationRe ) 1 record per transaction. cord- Required Itl:PackageInformationRecord Cardinality 1 Transaction GT M- B 1..1 -Required- ( Transaction Additional- Count(Recs), Record Int(1) ) TX.2 - Tran 5.1 All records in a transaction shall pertain to 3 Transaction ReturnResult M- B saction: a single subject. Biometric data used to -Single ( Transaction Single identify another individual requires a Subject Result Subject separate transaction. ( Warning(Unchecked Level 3 – All records shall pertain to a single subject.) ) ) TX.3 - Tran 5.1 All of the records belonging to a single 3 Transaction ReturnResult M- B saction: transaction shall be transmitted together. -Records ( Transaction Records Together Result Transmitted ( Together Warning(Unchecked Level 3 – All records belonging to a single transaction shall be transmitted together.) ) ) TX.4 - Tran 5.2 The upper limit of 1000 records is 1 Transaction LTE M- B saction: Size maintained in this version of the standard -Size ( Transaction to ensure backward compatibility with the Count(Recs), 33Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements 2007 version. Int(1000) ) TX.5 - Tran 5.3 22-97 reserved for future use. 1 Transaction EQ M- T saction: Table 3 -Records ( Transaction Reserved Reserved Count(Recs(Set-Int(22 to 97))), Records Int(0) ) 1 NIEM- ReturnResult M- X Transaction ( Transaction -Records Result Reserved ( Pass(Element names are not defined for reserved records. Invalid records will fail schema validation.) ) ) TX.6 - Tran 5.3.1 The Type-1 record shall always be the first 1 Transaction EQ M- T saction: record within the transaction. -Type1- ( Transaction Type1- First RecType(FirstIn(Recs)), Record_Firs Int(1) t ) 1 NIEM- EQ M- X Transaction ( Transaction -Type1- ElmName(FirstIn(Recs)), First Str(itl:PackageInformationRecord) ) TX.7 - Tran 5.3.3, Record Type-3 shall not be contained in 1 Transaction EQ(Count(Recs(Int(3)), Int(0)) M- T saction: 5.4, transactions conforming to this version of -Type3- Transaction Type3- Table 3., the standard. Zero Deprecated 8.3 Occurrence No instances of Record Type-3 shall be s included in a transaction conformant with 1 NIEM- ReturnResult M- X this version of the standard. Transaction ( Transaction -Type3- Result Deprecated records for this version are Zero ( Record Types 3, 5 and 6. Occurrence Pass(Deprecated Records are not defined for s NIEM-XML; invalid Records will fail Schema validation) ) ) 34Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements TX.8 - Tran 5.3.5, Record Type-5 shall not be contained in 1 Transaction EQ M- T saction: 5.4, transactions conforming to this version of -Type5- ( Transaction Type5- Table 3, the standard. Zero Count(Recs(Int(5))), Deprecated 8.5 Occurrence Int(0) No instances of Record Type-5 shall be s ) included in a transaction conformant with this version of the standard. 1 NIEM- ReturnResult M- X Transaction ( Transaction Deprecated records for this version are -Type5- Result Record Types 3, 5 and 6. Zero ( Occurrence Pass (Deprecated Records are not defined for s NIEM-XML, but invalid Records will fail Schema validation) ) ) TX.9 - Tran 5.3.6, Record Type-6 shall not be contained in 1 Transaction EQ M- T saction: 5.4, transactions conforming to this version of -Type6- ( Transaction Type6- Table 3, the standard. Zero Count(Recs(Int(6)), Deprecated 8.6 Occurrence Int(0) No instances of Record Type-6 shall be s ) included in a transaction conformant with this version of the standard. 1 NIEM- ReturnResult M- X Transaction ( Transaction Deprecated records for this version are -Type6- Result Record Types 3, 5 and 6. Zero ( Occurrence Pass (Deprecated Records are not defined for s NIEM-XML, but invalid Records will fail Schema validation) ) ) TX.10 - Tra 5.5 The special characters “STX”, “ETX”, 1 Transaction ReturnResult M- T nsaction: “FS”, “GS”, “RS”, and “US” are reserved -Reserved ( Transaction Reserved and shall not be included in any data Character Result Character (except data marked as character type B). Types ( Types Pass(Character Type assertions are performed on all data. These assertions test for the presence of reserved characters. Refer to the individual tests on data to determine the results.) ) 35Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements ) TX.11 - Tra 7.3.1 The value of the IDC shall be a 2 Transaction Complex t9 M- T nsaction: sequentially assigned positive integer - ( Transaction IDC starting from zero and incremented by one IDCSequen When arranged in numeric order, the set of all Sequential up to a maximum of 99. IDC references are tialValues IDC values in the transaction must begin with 0, stated in Type-1 Field 1.003 Transaction increment by 1, and the greatest value in the set content / CNT and shall be used to relate must be equal to or less than 99 information items in the CNT field of the ) Type-1 record to the other records in the transaction. TX.12 - Tra 7.3.1 Two or more records may share a single 2 Transaction Complex(See Note) t2 M- B nsaction: IDC solely to identify and link together - Transaction IDC records that pertain to different MatchingID Matching representations of the same biometric trait. CValues- Values Comparable Two or more image records may share a BiometricT single IDC only when they are ypes enhancements of a single image; such 2 Transaction Complex M- B transformations shall have identical - ( Transaction dimensions. MatchingID ForEach(Pair(A,B) of Records with matching IDC CSameImag fields) eDimension { {A.006} EQ {B.006} AND {A.007} EQ {B.007} } ) 3 Transaction ReturnResult M- B - ( Transaction IDCsFromS Result ameImage ( Pass(Not feasible to test if the samples are from the same image, only that the samples come from the same type of biometric trait) ) ) TX.13 - Fiel 8.1.3, IDC references are stated in Type-1 Field 2 Transaction Complex M- T d: 1.003- Table 22, 1.003 Transaction content / CNT and shall -CNT- ( Transaction 36Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements Transaction 7.3.1 be used to relate information items in the REC-IDC- ForEach (Record in Recs) Content CNT field of the Type-1 record to the other Matches ( Subfield 2 records in the transaction. It also specifies Records Present(Subfield in 1.003 ST IDC the order in which the remaining records AND Matches shall appear in the file. ( EQ({InfoI(1.003.REC) in Subfield}, RecType(Record)), EQ({InfoI(1.003.IDC) in Subfield}, {Record.002}) ) ) Note: The record types must appear in the same order that they are listed in Fld(1.003) ) 2 NIEM- Complex M- B Transaction ( Transaction REC-CNT- ForEach (Record in Recs) IDC- ( Matches Present(XElm(1.003.biom:ContentRecordSummar Records y) ST AND ( EQ({XElm(1.003.biomRecordCategoryCode) in XElm(1.003.biom:ContentRecordSummary)}, RecType(Record)), EQ({XElm(1.003.ImageReferenceIdentification) in XElm(1.003.biom:ContentRecordSummary)}, {Record.002}) ) ) Note: The record types must appear in the same order that they are listed in Fld(1.003) ) TX.14 - Tra 7.3.2.1 The value of the 2 Transaction Complex t9 M- B nsaction: SRN shall be a sequentially assigned -SRN- ( Transaction SRN positive integer starting from one and SequentialV When arranged in numeric order, the set of all Sequential incremented by alues SRN values in the transaction must begin with 1, one, not to exceed 255. increment by 1, and the greatest value in the set must be equal to or less than 255 ) 37Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements TX.15 - Tra 7.3, The value of the ACN shall be a 2 Transaction Complex t9 M- B nsaction: 7.3.3.1 sequentially assigned a positive integer -ACN- ( Transaction ACN starting from one and incremented by one, SequentialV When arranged in numeric order, the set of all Sequential not to exceed 255. alues ACN values in the transaction must begin with 1, increment by 1, and the greatest value in the set must be equal to or less than 255 ) TX.16 - Tra 7.3, There may be several Type-10 images of a 2 Transaction Complex M- T nsaction: 7.3.4 particular part of the body. For instance, a -SameT10- ( Transaction T10 photograph of a tattoo may cover the entire DiffIDC ForEach(Pair (A,B) of Records ST Matching tattoo. Another may be a zoom-in shot of a RecType(Records) EQ 10) portion of the tattoo. In order to link these { two images, the same index number is IF {A.039} EQ {B.039} assigned to Field 10.039: Type-10 THEN reference number / T10, which is new to {A.002} NEQ {B.002} this version of the standard. Note that these } images would have different IDC values. ) 2 NIEM- Complex M- X Transaction ( Transaction -SameT10- ForEach(Pair (A,B) of DiffIDC XElm(itl:PackageFacialAndSMTImageRecord) { IF {XElm(nc:IdentificationID) in XElm(biom:PhysicalFeatureReferenceIdentificati on) in A} EQ { XElm(nc:IdentificationID) in XElm(biom:PhysicalFeatureReferenceIdentificati on) in B} THEN {XElm(nc:IdentificationID) in XElm(biom:ImageReferenceIdentification) in A} NEQ { XElm(nc:IdentificationID) in XElm(biom:ImageReferenceIdentification) in B} } ) TX.17 - Tra C.2, C.4, The ordering of elements is strict. The 2 NIEM- Complex t10 M- X nsaction: C.5.1 schemas referenced by this annex define Schema ( Transaction Schema the order and nesting structure of elements. Validation Perform and report Schema validation. Provide Validation The schemas also provide a W3C warning that the schema does not strictly enforce representation of the order and hierarchical the standard, so the conformance of a 38Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements structure of the XML content. transaction cannot be claimed from the result of schema validation. However, the Schema The XML schema referenced for this validation does indicate that structural encoding define the structure and order of requirements have been met, including the elements in the information exchange appropriate ordering of the elements. package. To the extent possible, the ) schema define data types and constraints that enforce the allowable content rules of the base standard. Nevertheless, the XML schema may not strictly enforce the allowable content. The base standard defines allowable content, and its requirements shall be met by implementers regardless of encoding method. All of this standard’s required elements shall be present in a conforming instance document even if the schema referenced by this annex do not strictly enforce the requirement. The base standard defines allowable content, and its requirements shall be met by implementers regardless of encoding method. TX.18 - Tra C.4.1 Each XML information element, tags and 1 NIEM- MO M- X nsaction data content, shall be represented by a XML ( Transaction Valid character set that is a subset of Unicode Encoding {FirstIn(ElmsInTx)}, Encoding and that is allowable by W3C XML. Set-Str( [UTF-8, UTF-16, UTF-32]) Characters shall be transmitted using a ) Unicode encoding. TX.19 - Tra C.4.1 XML packages shall include an XML 1 NIEM- EQ M- X nsaction declaration that specifies the encoding. XML ( Transaction Encoding Declaration ElmName(FirstIn(ElmsInTx)), Declaration Str(?xml) ) TX.20 - NIE C.5.2, All separators are defined by the W3C 1 NIEM- Complex M- X M- C.5.3 XML recommendations. The characters Well- ( Transaction Transaction “<” and “>” are reserved exclusively for Formed Test that the XML is well-formed according to Well- enclosing XML element names. Every XML W3C XML recommendations. Formed element with a start tag <Name> shall have 39Req. # - ID Ref.in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Transaction-related Requirements XML an end tag of format </Name>. For all ) logical records – including Types 4, 7, and 8 that do not have field tags in the Traditional encoding -- data elements are tagged according to XML rules. The format for each element shall consist of a start tag enclosed in angle brackets followed by data followed by an end tag. Table C.2 - Assertions for Record Type 1: Transaction information record Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record RT1.1 - Rec 7.1 The record header appears as the first field 1 Type1- EQ M-Rec(1) T ord: (xx.001) in each Record Type. Field001Firs ( RecordHead The record header exists only in t FieldNum(FirstIn(FldsInRec(Rec(1)))), erFirst Traditional Encoding. Int(1) ) 1 NIEM- EQ M-Rec(1) X Type1- ( Field001Firs ElmName(FirstIn(ElmsIn(itl:PackageInformation t Record))), Str(biom:RecordCategoryCode) ) RT1.2 - Rec 8.1, Note that since the alternate character 1 Type1- ReturnResult M-Rec(1) T ord: Type1- 5.6, encoding is specified in this record, there ASCII ( 7-bitASCII Table 93 must be specified characters agreed upon Result in order to read this Record Type, ( particularly with Traditional encoding, and Pass(Character Type assertions are performed on the characters that can be represented by all data in Record Type-1. These assertions are the 7-bit ASCII code are those characters more restrictive because they test for character (see Table 93 for these characters). ranges that are a subset of 7-bit ASCII. Refer to the individual tests on data to determine the 40Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record Record Type-1 shall always be recorded in results.) all encodings using the characters that ) can be represented by the 7-bit ) American National Standard Code for Information Interchange (ASCII) found in table 93 with the exception of the reserved values. RT1.3 - Rec Table 22 Table 22 specifies which fields are 1 Type1- Not M-Rec(1) T ord: Type1- permitted to be present in a Type-1 Record. ReservedFie ( Reserved All others are reserved for future use. lds AnyPresent(Set-Fld([1.019 to 1.999]) ) 1 NIEM- ReturnResult t10 M-Rec(1) X Type1- ( ReservedFie Result lds ( Pass(Reserved Fields are not defined for NIEM- XML. The presence of any undefined elements will fail Schema validation) ) ) RT1.4 - Rec Table 22, Table 22 specifies the Field Occurrence for 1 Type1- EQ M-Rec(1) T ord: Type1- Annex G each field. 1.001- ( FieldOccurr Annex G specifies the cardinality for the Occurrences Count(FldsInRec(Rec(1), Int(1))), ence XML elements. Int(1) ) 1 Type1- EQ M-Rec(1) T 1.002- ( Occurrences Count(FldsInRec(Rec(1), Int(2))), Int(1) ) 1 Type1- EQ M-Rec(1) T 1.003- ( Occurrences Count(FldsInRec(Rec(1), Int(3))), Int(1) ) 1 Type1- EQ M-Rec(1) T 1.004- ( Occurrences Count(FldsInRec(Rec(1), Int(4))), Int(1) ) 41Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record 1 Type1- EQ M-Rec(1) T 1.005- ( Occurrences Count(FldsInRec(Rec(1), Int(5))), Int(1) ) 1 Type1- MO M-Rec(1) T 1.006- ( Occurrences Count(FldsInRec(Rec(1), Int(6))), Set-Int([0,1]) ) 1 Type1- EQ M-Rec(1) T 1.007- ( Occurrences Count(FldsInRec(Rec(1), Int(7))), Int(1) ) 1 Type1- EQ M-Rec(1) T 1.008- ( Occurrences Count(FldsInRec(Rec(1), Int(8))), Int(1) ) 1 Type1- EQ M-Rec(1) T 1.009- ( Occurrences Count(FldsInRec(Rec(1), Int(9))), Int(1) ) 1 Type1- MO M-Rec(1) T 1.010- ( Occurrences Count(FldsInRec(Rec(1), Int(10))), Set-Int([0,1]) ) 1 Type1- EQ M-Rec(1) T 1.011- ( Occurrences Count(FldsInRec(Rec(1), Int(11))), Int(1) ) 1 Type1- EQ M-Rec(1) T 1.012- ( Occurrences Count(FldsInRec(Rec(1), Int(12))), Int(1) ) 1 Type1- MO M-Rec(1) T 1.013- ( 42Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record Occurrences Count(FldsInRec(Rec(1), Int(13))), Set-Int([0,1]) ) 1 Type1- MO M-Rec(1) T 1.014- ( Occurrences Count(FldsInRec(Rec(1), Int(14))), Set-Int([0,1]) ) 1 Type1- MO M-Rec(1) T 1.015- ( Occurrences Count(FldsInRec(Rec(1), Int(15))), Set-Int([0,1]) ) 1 Type1- MO M-Rec(1) T 1.016- ( Occurrences Count(FldsInRec(Rec(1), Int(16))), Set-Int([0,1]) ) 1 Type1- MO M-Rec(1) T 1.017- ( Occurrences Count(FldsInRec(Rec(1), Int(17))), Set-Int([0,1]) ) 1 Type1- MO M-Rec(1) T 1.018- ( Occurrences Count(FldsInRec(Rec(1), Int(18))), Set-Int([0,1]) ) 2 NIEM- Complex(Check that all elements are in allowable t10 M-Rec(1) X Type1- cardinality ranges according to Annex G of the Cardinality base standard. This may be achieved using Schema validation.) RT1.5 - Fiel Table 22, Table 22 specifies which fields contain 1 1.001- EQ M-Fld(1.001) T d: 1.001- Annex B, subfields and information items as well as SubfieldCou ( FieldStructu Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.001))), re Int(1) A field contains a minimum of one ) subfield which contains a minimum of one 1 1.001- EQ M-Fld(1.001) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.001.1))), Int(1) 43Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ) RT1.6 - Fiel 8.1.1, Field 1.001 Record header. In Traditional 1 1.001-Value GTE M-Fld(1.001) T d: 1.001- Table 22, encoding, this field contains the record ( Value 7.1, length in bytes (including all information {Fld(1.001)}, C.10.1 separators). The value is unrestricted in Int(2) Traditional Encoding, but must be at least ) 2 to accommodate the size of required 2 1.001- EQ M-Fld(1.001) T fields. Value- ( Dependent {Fld(1.001)}, The XML name for the Type-1 record is Count(Bytes(Rec(1))) <itl:PackageInformationRecord>, and its ) <biom:RecordCategoryCode> element 1 NIEM- EQ M-Fld(1.001) X shall have a value of “1”. 1.001-Value ( {XElm(1.001.biom:RecordCategoryCode)}, Str(1) ) RT1.7 - Fiel 8.1 Section 8.1 and Table 22 specify the 1 1.001- SubSet M-Fld(1.001) B d: 1.001- Table 22, Character Type for each field. CharType ( CharType 8 Chars({Fld(1.001)}), Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 1.001- NOT M-Fld(1.001) B 1.012, 99.100, and 99.101. Any dates may NoLeadingZ ( also contain leading zeros. eros RegEx ( {Fld(1.001)}, LeadingZeroNum ) ) RT1.8 - Fiel Table 22, Table 22 specifies the character count for 1 1.001- GTE M-Fld(1.001) T d: 1.001- 7.1 each field. CharCount ( CharCount …a minimum of 2 characters for the Count(Chars({Fld(1.001)}), logical record length in Record Type-1… Int(2) ) 1 NIEM- EQ M-Fld(1.001) X 1.001- ( CharCount Count(Chars({Fld(1.001)}), Int(1) ) RT1.9 - Fiel Table 22, Table 22 specifies which fields contain 1 1.002-VER- EQ M-Fld(1.002) T d: 1.002- Annex B, subfields and information items as well as SubfieldCou ( 44Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record VER- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.002))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.002-VER- EQ M-Fld(1.002) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.002.1))), Int(1) ) RT1.10 - Fie 8.1.2 This mandatory four-character ASCII 1 1.002-VER- EQ M-Fld(1.002) T ld: 1.002- value shall be used to specify the current Value ( VER-Value version number of the standard {Fld(1.002)}, implemented by the software or system Str(0501) creating the transaction. ) The format of this field shall consist of 1 NIEM- AND M-Fld(1.002) X four numeric characters. The first two 1.002-VER- ( characters shall specify the major version Value OR number. The last two characters shall be ( used to specify the minor revision number. EQ({XElm(1.002.biom:TransactionMajorVersio In XML, nValue)}, Str(05)), biom:TransactionMajorVersionValue EQ({XElm(1.002.biom:TransactionMajorVersio is 5 and nValue)}, Str(5)), biom:TransactionMinorVersionValue is 1 ) EQ(XElm(1.002.biom:TransactionMinorVersion Value), Str(01)), ) RT1.11 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.002-VER- SubSet M-Fld(1.002) B ld: 1.002- Table 22, Character Type for each field. CharType ( VER- 8 Chars({Fld(1.002)}), CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.12 - Fie Table 22 specifies the character count for 1 1.002-VER- EQ M-Fld(1.002) T ld: 1.002- Table 22 each field. CharCount ( VER- Count(Chars({Fld(1.002)}), CharCount Int(4) ) 1 NIEM- AND M-Fld(1.002) X 1.002-VER- ( CharCount MO ( 45Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record Count(Chars({XElm(1.002.biom:TransactionMaj orVersionValue)})), Set-Int([1,2]) ), EQ ( Count(Chars({XElm(1.002.biom:TransactionMin orVersionValue)})), Int(2) ) ) RT1.13 - Fie Table 22, Table 22 specifies which fields contain 1 1.003-NT- GTE M-Fld(1.003) T ld: 1.003- Annex B, subfields and information items as well as SubfieldCou ( CNT- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.003))), FieldStructu Int(2) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.003-CNT- EQ M-Fld(1.003) T information item. InfoItemCou ( nt Count(InfoItemsIn(Fld(1.003))), Mult ( Int(2), Count(SubFldsIn(Fld(1.003))) ) ) 1 1.003-CNT- InfoItemsHaveData M-Fld(1.003) T InfoItemStru ( cture SubFld(1.003), Set-Int([1,2]) ) RT1.14 - Fie 8.1.3 The first information item (first record 1 1.003-FRC- EQ M- B ld: 1.003- category code / FRC) within this subfield Value ( InfoI(1.003.F FRC-Value shall be “1”. This indicates that the first {InfoI(1.003.FRC)}, RC) record in the transaction is a Type-1 record Int(1) consisting of header information ) RT1.15 - Fie 8.1, Section 8.1 and Table 22 specify the 1 1.003-FRC- SubSet M- B ld: 1.003- Table 22, Character Type for each field. CharType ( InfoI(1.003.F FRC- 8 Chars({InfoI(1.003.FRC)}), RC) CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 1.003-FRC- NOT M- B 46Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record 1.012, 99.100, and 99.101. Any dates may NoLeadingZ ( InfoI(1.003.F also contain leading zeros. eros RegEx RC) ( {InfoI(1.003.FRC)} LeadingZeroNum ) ) RT1.16 - Fie Table 22 Table 22 specifies the character count for 1 1.003-FRC- EQ M- B ld: 1.003- each field. CharCount ( InfoI(1.003.F FRC- Count(Chars({InfoI(1.003.FRC)}), RC) CharCount Int(1) ) RT1.17 - Fie 8.1.3, The second information item of this 1 1.003-CRC- MO M- B ld: 1.003- Table 22 subfield (content record count / CRC) shall Value ( InfoI(1.003.C CRC-Value be the sum of the Type-2 through Type-99 {InfoI(1.003.CRC)}, RC) records contained in this transaction. This Set-Int([1 to 999]) number is also equal to the count of the ) remaining subfields of Field 1.003 Transaction content / CNT. The maximum 2 1.003-CRC- EQ M- B value for CRC is 999. Value- ( InfoI(1.003.C Dependent- {InfoI(1.003.CRC)}, RC) RecordCoun Count(Recs(Set-Int([2 to 99]))) t ) 2 1.003-CRC- EQ M- T Value- ( InfoI(1.003.C Dependent- {InfoI(1.003.CRC)}, RC) SubfieldCou Minus(Count(SubFldsIn(Fld(1.003))), Int(1)) nt ) 2 NIEM- EQ M- X 1.003-CRC- ( InfoI(1.003.C Value- {XElm(1.003.biom:ContentRecordQuantity)}, RC) Dependent Minus ( Count(ElmsIn( XElm(1.003.biom:TransactionContentSummary), XElm(1.003.biom:ContentRecordSummary))), Int(1) ) ) 47Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record RT1.18 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.003-CRC- SubSet M- B ld: 1.003- Table 22, Character Type for each field. CharType ( InfoI(1.003.C CRC- 8 Chars({InfoI(1.003.CRC)}), RC) CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 1.003-CRC- NOT M- B 1.012, 99.100, and 99.101. Any dates may NoLeadingZ ( InfoI(1.003.C also contain leading zeros. eros RegEx RC) ( {InfoI(1.003.CRC)}, LeadingZeroNum ) ) RT1.19 - Fie Table 22 Table 22 specifies the character count for 1 1.003-CRC- MO M- B ld: 1.003- each field. CharCount ( InfoI(1.003.C CRC- Count(Chars({InfoI(1.003.CRC)}), RC) CharCount Set-Int([1 to 2]) ) RT1.20 - Fie 8.1.3, The first information item (record category 1 1.003-REC- MO M- B ld: 1.003- Table 22, code / REC), shall contain a number Value ( InfoI(1.003.R REC-Value Table 3 chosen from the “record identifier” column {InfoI(1.003.REC)}, EC) of Table 3. Set-Int([2,4,7 to 22, 98,99]) ) RT1.21 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.003-REC- SubSet M- B ld: 1.003- Table 22, Character Type for each field. CharType ( InfoI(1.003.R REC- 8 Chars({InfoI(1.003.REC)}), EC) CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 1.003-REC- NOT M- B 1.012, 99.100, and 99.101. Any dates may NoLeadingZ ( InfoI(1.003.R also contain leading zeros. eros RegEx EC) ( {InfoI(1.003.REC)}, LeadingZeroNum ) ) RT1.22 - Fie Table 22 Table 22 specifies the character count for 1 1.003-REC- MO M- B ld: 1.003- each field. CharCount ( InfoI(1.003.R REC- Count(Chars({InfoI(1.003.REC)}), EC) 48Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record CharCount Set-Int([1, 2]) ) RT1.23 - Fie 8.1.3, The second information item (information 1 1.003-IDC- MO M- B ld: 1.003- Table 22 designation character / IDC) shall be an Value ( InfoI(1.003.I IDC-Value integer equal to or greater than zero and {InfoI(1.003.IDC)}, DC) less than or equal to 99. See Set-Int([0 to 99]) Section 7.3.1. ) RT1.24 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.003-IDC- SubSet M- B ld: 1.003- Table 22, Character Type for each field. CharType ( InfoI(1.003.I IDC- Chars({InfoI(1.003.IDC)}), DC) CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 1.003-IDC- NOT M- B 1.012, 99.100, and 99.101. Any dates may NoLeadingZ ( InfoI(1.003.I also contain leading zeros. eros RegEx DC) ( {InfoI(1.003.IDC)}, LeadingZeroNum ) ) RT1.25 - Fie Table 22 Table 22 specifies the character count for 1 1.003-IDC- MO M- B ld: 1.003- each field. CharCount ( InfoI(1.003.I IDC- Count(Chars({InfoI(1.003.IDC)}), DC) CharCount Set-Int([1, 2]) ) RT1.26 - Fie Table 22, Table 22 specifies which fields contain 1 1.004-TOT- EQ M-Fld(1.004) T ld: 1.004- Annex B, subfields and information items as well as SubfieldCou ( TOT- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.004))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.004-TOT- EQ M-Fld(1.004) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.004.1))), Int(1) ) RT1.27 - Fie 8.1.4, This mandatory field shall contain an 1 1.004-TOT- ReturnResult M-Fld(1.004) B ld: 1.004- Table 22 identifier, which designates the type of Value ( TOT-Value transaction and subsequent processing that Result(Pass) this transaction should be given. This shall ) be a maximum of 16 alphabetic characters. The TOT shall be in accordance with 49Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record definitions provided by the receiving agency.) Earlier versions of this standard specifically restricted the character length of TOT to 4 characters. RT1.28 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.004-TOT- SubSet M-Fld(1.004) B ld: 1.004- Table 22, Character Type for each field. CharType ( TOT- Chars({Fld(1.004)}), CharType CharAlpha ) RT1.29 - Fie Table 22 Table 22 specifies the character count for 1 1.004-TOT- MO M-Fld(1.004) B ld: 1.004- each field. CharCount ( TOT- Count(Chars({Fld(1.004)}), CharCount Set-Int([1 to 16]) ) RT1.30 - Fie Table 22, Table 22 specifies which fields contain 1 1.005-DAT- EQ M-Fld(1.005) T ld: 1.005- Annex B, subfields and information items as well as SubfieldCou ( DAT- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.005))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.005-DAT- EQ M-Fld(1.005) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.005.1))), Int(1) ) RT1.31 - Fie 8.1.5, This mandatory field shall contain the local 1 1.005-DAT- Complex t3 M-Fld(1.005) T ld: 1.005- Table 22, date that the transaction was submitted. Value ( DAT-Value 7.7.2.3 The local date is recorded as EQ YYYYMMDD. Note that this may be a ( different date than the corresponding {Fld(1.005)}, GMT, due to time zone differences. ValidLocalDate )) 1 NIEM- Complex t3 M-Fld(1.005) X 1.005-DAT- ( Value IfThenElse ( Present(XElm(1.005.nc:Date)), EQ({XElm(1.005.nc:Date)}, NIEM- ValidLocalDate), IfThenElse ( Present(XElm(1.005.nc:YearMonth)), EQ({XElm(1.005.nc:YearMonth)}, NIEM- 50Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ValidLocalYearMonth), IfThenElse ( Present(XElm(1.005.nc:Year)), EQ({XElm(1.005.nc:Year)}, NIEM- ValidLocalYear), ReturnResult ( Result(Fail(No valid local date element is present.)) )))) ) RT1.32 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.005-DAT- SubSet M-Fld(1.005) T ld: 1.005- Table 22, Character Type for each field. CharType ( DAT- Chars({Fld(1.005)}), CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 NIEM- IfThenElse M-Fld(1.005) X 1.012, 99.100, and 99.101. Any dates may 1.005-DAT- ( also contain leading zeros. CharType Present(XElm(1.005.nc:Date)), SubSet ( Chars({XElm(1.005.nc:Date)}) Union(CharNum, Set-Str([-])) ), IfThenElse ( Present(XElm(1.005.nc:YearMonth)), SubSet ( Chars({XElm(1.005.nc:YearMonth)}) Union(CharNum, Set-Str([-])) ), IfThenElse ( Present(XElm(1.005.nc:Year)), SubSet ( Chars({XElm(1.005.nc:Year)}) CharNum ), ReturnResult ( 51Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record Result(Fail(No valid local date element is present.)) )))) RT1.33 - Fie Table 22 Table 22 specifies the character count for 1 1.005-DAT- EQ M-Fld(1.005) T ld: 1.005- each field. CharCount ( DAT- Count(Chars({Fld(1.005)}), CharCount Int(8) ) 1 NIEM- IfThenElse M-Fld(1.005) X 1.005-DAT- ( CharCount Present(XElm(1.005.nc:Date)), EQ ( Count(Chars({XElm(1.005.nc:Date)})) Int(10) ), IfThenElse ( Present(XElm(1.005.nc:YearMonth)), EQ ( Count(Chars({XElm(1.005.nc:YearMonth)})) Int(7) ), IfThenElse ( Present(XElm(1.005.nc:Year)), EQ ( Count(Chars({XElm(1.005.nc:Year)})) Int(4) ), ReturnResult ( Result(Fail(No valid local date element is present.)) )))) RT1.34 - Fie Table 22, Table 22 specifies which fields contain 1 1.006-PRY- EQ O-Fld(1.006) T ld: 1.006- Annex B, subfields and information items as well as SubfieldCou ( PRY- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.006))), FieldStructu Int(1) re A field contains a minimum of one ) 52Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record subfield which contains a minimum of one 1 1.006-PRY- EQ O-Fld(1.006) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.006.1))), Int(1) ) RT1.35 - Fie 8.1.6, This optional field shall contain a single 1 1.006-PRY- {1.006} MO [1 to 9] AND MO [Integers] O-Fld(1.006) B ld: 1.006- Table 22 information character to designate the Value PRY-Value urgency with which a response is desired. The values shall range from 1 to 9, with 1 denoting the highest priority. The default value shall be defined by the agency receiving the transaction. RT1.36 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.006-PRY- SubSet O-Fld(1.006) B ld: 1.006- Table 22, Character Type for each field. CharType ( PRY- Chars({Fld(1.006)}), CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 1.006-PRY- NOT O-Fld(1.006) B 1.012, 99.100, and 99.101. Any dates may NoLeadingZ ( also contain leading zeros. eros RegEx ( {Fld(1.006)}, LeadingZeroNum ) ) RT1.37 - Fie Table 22 Table 22 specifies the character count for 1 1.006-PRY- EQ O-Fld(1.006) B ld: 1.006- each field. CharCount ( PRY- Count(Chars({Fld(1.006)}), CharCount Int(1) ) RT1.38 - Fie Table 22, Table 22 specifies which fields contain 1 1.007-DAI- EQ M-Fld(1.007) T ld: 1.007- Annex B, subfields and information items as well as SubfieldCou ( DAI- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.007))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.007-DAI- EQ M-Fld(1.007) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.007.1))), Int(1) ) RT1.39 - Fie 8.1.7, This mandatory field shall contain the 1 1.007-DAI- ReturnResult M-Fld(1.007) B 53Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ld: 1.007- Table 22 identifier of the administration or Value ( DAI-Value organization designated to receive the Result(Pass) transmission. The size and data content of ) this field shall be user-defined and in accordance with the application profile. RT1.40 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.007-DAI- SubSet M-Fld(1.007) B ld: 1.007- Table 22, Character Type for each field. CharType ( DAI- Chars({Fld(1.007)}), CharType CharsAsciiPrintable ) RT1.41 - Fie Table 22 Table 22 specifies the character count for 1 1.007-DAI- GTE M-Fld(1.007) B ld: 1.007- each field. CharCount ( DAI- Count(Chars({Fld(1.007)}), CharCount Int(1) ) RT1.42 - Fie Table 22, Table 22 specifies which fields contain 1 1.008-ORI- EQ M-Fld(1.008) T ld: 1.008- Annex B, subfields and information items as well as SubfieldCou ( ORI- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.008))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.008-ORI- EQ M-Fld(1.008) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.008.1))), Int(1) ) RT1.43 - Fie 8.1.8, This mandatory field shall contain the 1 1.008-ORI- ReturnResult M-Fld(1.008) B ld: 1.008- Table 22, identifier of the administration or Value ( ORI-Value 5.3.1 organization originating the transaction. Result(Pass) The size and data content of this field shall ) be user-defined and in accordance with the application profile. The Type-1 record shall provide information describing …the originator or source of the physical record RT1.44 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.008-ORI- SubSet M-Fld(1.008) B ld: 1.008- Table 22, Character Type for each field. CharType ( ORI- Chars({Fld(1.008)}), CharType CharsAsciiPrintable ) RT1.45 - Fie Table 22 Table 22 specifies the character count for 1 1.008-ORI- GTE M-Fld(1.008) B ld: 1.008- each field. CharCount ( 54Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ORI- Count(Chars({Fld(1.008)}), CharCount Int(1) ) RT1.46 - Fie Table 22, Table 22 specifies which fields contain 1 1.009-TCN- EQ M-Fld(1.009) T ld: 1.009- Annex B, subfields and information items as well as SubfieldCou ( TCN- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.009))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.009-TCN- EQ M-Fld(1.009) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.009.1))), Int(1) ) RT1.47 - Fie 8.1.9, This mandatory field shall contain the 1 1.009-TCN- ReturnResult M-Fld(1.009) B ld: 1.009- Table 22 transaction control number as assigned by Value ( TCN-Value the originating agency. A unique (for the Result(Pass) originating agency) alphanumeric control ) number shall be assigned to each transaction. For any transaction that requires a response, the respondent shall refer to this number in communicating with the originating agency. RT1.48 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.009-TCN- SubSet M-Fld(1.009) B ld: 1.009- Table 22, Character Type for each field. CharType ( TCN- Chars({Fld(1.009)}), CharType CharsAsciiPrintable ) RT1.49 - Fie Table 22 Table 22 specifies the character count for 1 1.009-TCN- GTE M-Fld(1.009) B ld: 1.009- each field. CharCount ( TCN- Count(Chars({Fld(1.009)}), CharCount Int(1) ) RT1.50 - Fie Table 22, Table 22 specifies which fields contain 1 1.010-TCR- EQ O-Fld(1.010) T ld: 1.010- Annex B, subfields and information items as well as SubfieldCou ( TCR- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.010))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.010-TCR- EQ O-Fld(1.010) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.010.1))), Int(1) ) 55Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record RT1.51 - Fie 8.1.10, This optional field shall be used for 1 1.010-TCR- ReturnResult O-Fld(1.010) B ld: 1.010- Table 22 responses that refer to the TCN of a Value ( TCR-Value previous transaction involving an inquiry Result(Pass) or other action that required a response. ) RT1.52 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.010-TCR- SubSet O-Fld(1.010) B ld: 1.010- Table 22, Character Type for each field. CharType ( TCR- Chars({Fld(1.010)}), CharType CharsAsciiPrintable ) RT1.53 - Fie Table 22 Table 22 specifies the character count for 1 1.010-TCR- GTE O-Fld(1.010) B ld: 1.010- each field. CharCount ( TCR- Count(Chars({Fld(1.010)}), CharCount Int(1) ) RT1.54 - Fie Table 22, Table 22 specifies which fields contain 1 1.011-NSR- EQ M-Fld(1.011) T ld: 1.011- Annex B, subfields and information items as well as SubfieldCou ( NSR- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.011))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.011-NSR- EQ M-Fld(1.011) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.011.1))), Int(1) ) RT1.55 - Fie 8.1.11, This mandatory field shall be set to 1 1.011-NSR- RegEx M-Fld(1.011) T ld: 1.011- Table 22, “00.00” if there are no Type-4 records in Value ( NSR-Value 7.7.6, the transaction. {Fld(1.011)}, 7.7.6.1, When there are Type-4 records present, Str(^[0-9]{2}\.[0-9]{2}$) 7.7.6.2.1, this field is used to specify the native ) Table 14 scanning resolution of the friction ridge 1 NIEM- RegEx M-Fld(1.011) X image capture device. This field shall 1.011-NSR- ( specify the resolution in pixels per Value {Fld(1.011)}, millimeter. The resolution shall be Str(^[0-9]{1,2}\.[0-9]{2}$) expressed as two numeric characters ) followed by a decimal point and two more 2 1.011-NSR- IfThenElseResult t11 M-Fld(1.011) REMOVE B numeric characters. Value- ( NIEM Dependent Not(Present(Rec(4))), ASSERTIO Images with scanning resolution greater EQ({Fld(1.011)}, Num(00.00)), N BELOW than or equal to the 1000 ppi class should IfThenElseResult not be transmitted using Record Type-4 ( unless being transmitted at 500 ppi class to GTE(NV({Fld(1.011)}), Num(38.58)), a system incapable of receiving Type-14 ReturnResult 56Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record records at 1000 ppi class or greater. ( Result(Warning(Images with scanning resolution NSR contains five characters specifying equal to or greater than the 1000ppi class should the native scanning resolution in pixels per not be transmitted using Record Type-4 unless millimeter. It is expressed as two numeric they are scaled-down to produce a transmitting characters followed by a decimal point and resolution of class 500ppi.)) two more numeric characters (e.g. 19.69). ), GTE(NV({Fld(1.011)}), Num(19.29)), Exemplar images shall have a minimum ) scanning resolution of the 500 ppi class. ) In this version, NSR and NTR only apply to Record Type-4: Grayscale fingerprint image… Table 14 defines resolution tolerance for fingerprint types. 2% is used as the default; see test note t-11 for details. Note: the minimum value with tolerance was 19.30 in 2011. This is changed to 19.29 in 2013 due to the rounding method mentioned in 7.7.8.4. RT1.56 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.011-NSR- SubSet M-Fld(1.011) B ld: 1.011- Table 22, Character Type for each field. CharType ( NSR- Chars({Fld(1.011)}), CharType Numeric values shall not contain leading Union(CharNum, Set-Str([.])) zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.57 - Fie Table 22 Table 22 specifies the character count for 1 1.011-NSR- EQ M-Fld(1.011) T ld: 1.011- each field. CharCount ( NSR- Count(Chars({Fld(1.011)})), CharCount Int(5) ) 1 NIEM- MO M-Fld(1.011) X 1.011-NSR- ( CharCount Count(Chars({Fld(1.011)})), Set-Int([4,5]) 57Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ) RT1.58 - Fie Table 22, Table 22 specifies which fields contain 1 1.012-NTR- EQ M-Fld(1.012) T ld: 1.012- Annex B, subfields and information items as well as SubfieldCou ( NTR- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.012))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.012-NTR- EQ M-Fld(1.012) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.012.1))), Int(1) ) RT1.59 - Fie 8.1.12, This mandatory field shall be set to 1 1.012-NTR- RegEx M-Fld(1.012) T ld: 1.012- Table 22, “00.00” if there are no Type-4 records in Value ( NTR-Value 7.7.6, the transaction. {Fld(1.012)}, 7.7.6.3.1 When there are Type-4 records present, Str(^[0-9]{2}\.[0-9]{2}$) this field specifies the nominal resolution ) for the image(s) being exchanged. This 1 NIEM- RegEx M-Fld(1.012) X field shall specify the resolution in pixels 1.012-NTR- ( per millimeter. Value {Fld(1.012)}, The resolution shall be within the range Str(^[0-9]{1,2}\.[0-9]{2}$) 19.30 ppmm (490 ppi) to 20.08 ppmm (510 ) ppi). 2 1.012- IfThenElse t11 M-Fld(1.012) REMOVE B Value- ( NIEM All record types containing images are Dependent Present(Rec(4)), ASSERT variable resolution except for Type-4, InRange BELOW which has a fixed resolution. Record Type- ( 4 shall not be used for anything but the 500 NV({Fld(1.012)}), Num(19.29), Num(20.08) ppi class. ), EQ({Fld(1.012)}, Num(00.00)) In this version, NSR and NTR only apply ) to Record Type-4: Grayscale fingerprint 2 1.012-NTR- LTE M-Fld(1.012) B image… Value- ( Dependent- {Fld(1.012)}, …the transmitting resolution shall not be LTE-1.011 {Fld(1.011)} greater than the scanning resolution ) RT1.60 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.012-NTR- SubSet M-Fld(1.012) B ld: 1.012- Table 22, Character Type for each field. CharType ( NTR- Chars({Fld(1.012)}), CharType Numeric values shall not contain leading Union(CharNum, Set-Str([.])) zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may 58Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record also contain leading zeros. RT1.61 - Fie Table 22 Table 22 specifies the character count for 1 1.012-NTR- EQ M-Fld(1.012) T ld: 1.012- each field. CharCount ( NTR- Count(Chars({Fld(1.012)})), CharCount Int(5) ) 1 NIEM- MO M-Fld(1.012) X 1.012-NTR- ( CharCount Count(Chars({Fld(1.012)})), Set-Int([4,5]) ) RT1.62 - Fie Table 22, Table 22 specifies which fields contain 1 1.013-DOM- EQ O-Fld(1.013) T ld: 1.013- Annex B, subfields and information items as well as SubfieldCou ( DOM- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.013))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.013-DOM- EQ O-Fld(1.013) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.013.1))), Int(2) ) 1 1.013-DOM- InfoItemsHaveData O-Fld(1.013) T InfoItemStru ( cture SubFld(1.013.1), Set-Int() ) RT1.63 - Fie 8.1.13, The mandatory first information item 1 1.013-DNM- ReturnResult M↑- B ld: 1.013- Table 22 (domain name / DNM) will uniquely Value ( InfoI(1.013.D DNM-Value identify the agency, entity, or Result(Pass) NM) implementation used for formatting the ) fields in the Type-2 record. The default value for the field shall be the North American Domain implementation (NORAM). RT1.64 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.013-DNM- SubSet M↑- B ld: 1.013- Table 22, Character Type for each field. CharType ( InfoI(1.013.D DNM- Chars({InfoI(1.013.DNM)}), NM) CharType CharsAsciiPrintable ) RT1.65 - Fie Table 22 Table 22 specifies the character count for 1 1.013-DNM- GTE M↑- B 59Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ld: 1.013- each field. CharCount ( InfoI(1.013.D DNM- Count(Chars({InfoI(1.013.DNM)}), NM) CharCount Int(1) ) RT1.66 - Fie 8.1.13, An optional second information item 1 1.013-DVN- ReturnResult O↑- B ld: 1.013- Table 22 (domain version number / DVN) shall Value ( InfoI(1.013.D DVN-Value contain the unique version of the particular Result(Pass) VN) implementation, such as 7.02. ) RT1.67 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.013-DVN- SubSet O↑- B ld: 1.013- Table 22, Character Type for each field. CharType ( InfoI(1.013.D DVN- Chars({InfoI(1.013.DVN)}), VN) CharType CharsAsciiPrintable ) RT1.68 - Fie Table 22 Table 22 specifies the character count for 1 1.013-DVN- GTE O↑- B ld: 1.013- each field. CharCount ( InfoI(1.013.D DVN- Count(Chars({InfoI(1.013.DVN)}), VN) CharCount Int(1) ) RT1.69 - Fie Table 22, Table 22 specifies which fields contain 1 1.014-GMT- EQ O-Fld(1.014) T ld: 1.014- Annex B, subfields and information items as well as SubfieldCou ( GMT- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.014))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.014-GMT- EQ O-Fld(1.014) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.014.1))), Int(1) ) RT1.70 - Fie 8.1.14, This optional field provides a mechanism 1 1.014-GMT- Complex t3 O-Fld(1.014) T ld: 1.014- Table 22 for expressing the date and time in terms of Value ( GMT-Value universal Greenwich Mean Time (GMT) EQ units. ( {Fld(1.014)}, ValidUTC/GMT )) 1 NIEM- Complex t3 O-Fld(1.014) X 1.014-GMT- ( Value EQ {XElm(1.014.nc:DateTime)}, NIEM-ValidUTC/GMT )) RT1.71 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.014-GMT- SubSet O-Fld(1.014) B 60Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ld: 1.014- Table 22, Character Type for each field. CharType ( GMT- Chars({Fld(1.014)}), CharType Numeric values shall not contain leading Union(CharNum, Set-Str([Z])) zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 NIEM- SubSet O-Fld(1.014) B 1.012, 99.100, and 99.101. Any dates may 1.014-GMT- ( also contain leading zeros. CharType Chars({Fld(1.014)}), Union(CharNum, Set-Str([-,:,T,Z])) ) RT1.72 - Fie Table 22 Table 22 specifies the character count for 1 1.014-GMT- EQ O-Fld(1.014) T ld: 1.014- each field. CharCount ( GMT- Count(Chars({Fld(1.014)}), CharCount Int(15) ) 1 NIEM- EQ O-Fld(1.014) X 1.014-GMT- ( CharCount Count(Chars({Fld(1.014)}), Int(20) ) RT1.73 - Fie Table 22, Table 22 specifies which fields contain 1 1.015-DCS- EQ O-Fld(1.015) T ld: 1.015- Annex B, subfields and information items as well as SubfieldCou ( DCS- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.015))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.015-DCS- EQ O-Fld(1.015) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.015.1))), Int(2,3) ) 1 1.015-DCS- InfoItemsHaveData O-Fld(1.015) T InfoItemStru ( cture SubFld(1.015.1), Set-Int([1,2]) ) RT1.74 - Fie 8.1.15, The first information item (character 1 1.015-CSI- IfThenElseResult M↑- B ld: 1.015- Table 22, encoding index / CSI) is the index number Value ( InfoI(1.015.C CSI-Value Table 4, that references an associated character MO(NV{InfoI(1.015.CSI)}, Set-Int([0, 2 to 4, SI) 5.4, 5.6 encoding. See the “Character encoding 128 to 999]), index” column of Table 4 for the valid Result(Pass), values for this information item. IfThenElseResult ( 61Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record 'Legacy' indicates that if there is existing EQ({InfoI(1.015.CSI)}, Str(1)), data using this record type, field, Result(Warning(‘1’ is a Legacy value.)), information item or value it may still be Result(Fail) transmitted in a transaction conformant to ) this version of the standard. In this version ) ‘legacy’ applies to Fields 9.005 through 9.012, Field 10.022 and to the value '1' in Table 4 Character encoding. Note that the value “1” does not appear in the table. It is a legacy value. RT1.75 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.015-CSI- SubSet M↑- B ld: 1.015- Table 22, Character Type for each field. CharType ( InfoI(1.015.C CSI- Chars({InfoI(1.015.CSI)}), SI) CharType Numeric values shall not contain leading CharNum zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1 1.015-CSI- NOT M↑- B 1.012, 99.100, and 99.101. Any dates may NoLeadingZ ( InfoI(1.015.C also contain leading zeros. eros RegEx SI) ( {InfoI(1.015.CSI)}, LeadingZeroNum ) ) RT1.76 - Fie Table 22 Table 22 specifies the character count for 1 1.015-CSI- MO M↑- B ld: 1.015- each field. CharCount ( InfoI(1.015.C CSI- Count(Chars({InfoI(1.015.CSI)}), SI) CharType Set-Int([1,2,3]) ) RT1.77 - Fie 8.1.15, The second information item (character 1 1.015-CSN- ReturnResult M↑- B ld: 1.015- Table 22, encoding name / CSN) shall be the Value ( InfoI(1.015.C CSN-Value Table 4 “Character encoding name” associated Result(Pass) SN) with that index number, taken from ) Table 4. 2 1.015-CSN- IfThenElseResult M↑- X Value- ( InfoI(1.015.C Dependent EQ({InfoI(1.015.CSI)}, Int(0)), SN) EQ({InfoI(1.015.CSN)}, Str(ASCII)), IfThenElseResult ( EQ({InfoI(1.015.CSI)}, Int(1)), 62Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record EQ({InfoI(1.015.CSN)}, Str(8-bit ASCII)), IfThenElseResult ( EQ({InfoI(1.015.CSI)}, Int(2)), EQ({InfoI(1.015.CSN)}, Str(8 UTF-16)), IfThenElseResult ( EQ({InfoI(1.015.CSI)}, Int(3)), EQ({InfoI(1.015.CSN)}, Str(8 UTF-8)), IfThenElseResult ( EQ({InfoI(1.015.CSI)}, Int(4)), EQ({InfoI(1.015.CSN)}, Str(8 UTF-32)), ReturnResult ( Result(Pass))))))) RT1.78 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.015-CSN- SubSet M↑- B ld: 1.015- Table 22, Character Type for each field. CharType ( InfoI(1.015.C CSN- Chars({InfoI(1.015.CSN)}), SN) CharType Numeric values shall not contain leading CharAsciiPrintable zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.79 - Fie Table 22 Table 22 specifies the character count for 1 1.015-CSN- MO M↑- B ld: 1.015- each field. CharCount ( InfoI(1.015.C CSN- Count(Chars({InfoI(1.015.CSN)}), SN) CharCount Set-Int([1 to 16]) ) RT1.80 - Fie 8.1.15, The optional third information item 1 1.015-CSV- ReturnResult O↑- B ld: 1.015- Table 22, (character encoding version / CSV) is the Value ( InfoI(1.015.C CSV-Value Table 4 specific version of the character encoding Result(Pass) SV) used. In the case of the use of UTF-8, the ) third optional information item may be used to hold the specific version used, so that the display terminal can be switched to the correct font family. 63Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record RT1.81 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.015-CSV- SubSet O↑- B ld: 1.015- Table 22, Character Type for each field. CharType ( InfoI(1.015.C CSV- Chars({InfoI(1.015.CSV)}), SV) CharType Numeric values shall not contain leading CharAsciiPrintable zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.82 - Fie Table 22 Table 22 specifies the character count for 1 1.015-CSV- MO M↑- B ld: 1.015- each field. CharCount ( InfoI(1.015.C CSV- Count(Chars({InfoI(1.015.CSV)}), SV) CharCount Set-Int([1 to 16]) ) RT1.83 - Fie Table 22, Table 22 specifies which fields contain 1 1.016-APS- MO O-Fld(1.016) T ld: 1.016- Annex B, subfields and information items as well as SubfieldCou ( APS- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.016))), FieldStructu Set-Int(]1 to 99]) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.016-APS- EQ O-Fld(1.016) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.016))), Int(3) ) 1 1.016-APS- InfoItemsHaveData O-Fld(1.016) T InfoItemStru ( cture SubFld(1.016), Set-Int([1,2,3]) ) RT1.84 - Fie 8.1.16, The first information item (application 1 1.016-APO- ReturnResult M↑- B ld: 1.016- Table 22 profile organization / APO) will uniquely Value ( InfoI(1.016.A APO-Value identify the agency or entity responsible Result(Pass) PO) for the specification. ) RT1.85 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.016-APO- SubSet M↑- B ld: 1.016- Table 22, Character Type for each field. CharType ( InfoI(1.016.A APO- Chars({InfoI(1.016.APO)}), PO) CharType Numeric values shall not contain leading CharAsciiPrintable zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may 64Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record also contain leading zeros. RT1.86 - Fie Table 22 Table 22 specifies the character count for 1 1.016-APO - GTE M↑- B ld: 1.016- each field. CharCount ( InfoI(1.016.A APO- Count(Chars({InfoI(1.016.APO}), PO) CharCount Int(1) ) RT1.87 - Fie 8.1.16, The second information item (application 1 1.016-APN- ReturnResult M↑- B ld: 1.016- Table 22 profile name / APN) shall contain the name Value ( InfoI(1.016.A APN-Value of the specification. Result(Pass) PN) ) RT1.88 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.016-APN- SubSet M↑- B ld: 1.016- Table 22, Character Type for each field. CharType ( InfoI(1.016.A APN- Chars({InfoI(1.016.APN)}), PN) CharType Numeric values shall not contain leading CharAsciiPrintable zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.89 - Fie Table 22 Table 22 specifies the character count for 1 1.016-APN - GTE M↑- B ld: 1.016- each field. CharCount ( InfoI(1.016.A APN- Count(Chars({InfoI(1.016.APN}), PN) CharCount Int(1) ) RT1.90 - Fie 8.1.16, The third information item (application 1 1.016-APV- ReturnResult M↑- B ld: 1.016- Table 22 profile version number / APV) shall Value ( InfoI(1.016.A APV-Value contain the specific version of the Result(Pass) PV) specification. ) RT1.91 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.016-APV- SubSet M↑- B ld: 1.016- Table 22, Character Type for each field. CharType ( InfoI(1.016.A APV- Chars({InfoI(1.016.APV)}), PV) CharType Numeric values shall not contain leading CharAsciiPrintable zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.92 - Fie Table 22 Table 22 specifies the character count for 1 1.016-APV - GTE M↑- B ld: 1.016- each field. CharCount ( InfoI(1.016.A APV- Count(Chars({InfoI(1.016.APV}), PV) CharCount Int(1) ) RT1.93 - Fie 8.1.16 If multiple Application Profile 3 1.016-APS ReturnResult O-Fld(1.016) B ld: 1.016- Specifications are included in this field, the Compliance ( 65Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record APS- specifications must be compatible with Result Compliance each other: this transaction must be in (Warning(Untested Level 3-Application Profiles compliance with all of the cited external references are outside of the scope of specifications. See Section 6. conformance testing to the base standard.)) ) RT1.94 - Fie Table 22, Table 22 specifies which fields contain 1 1.017-ANM- EQ O-Fld(1.017) T ld: 1.017- Annex B, subfields and information items as well as SubfieldCou ( ANM- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.017))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.017-ANM- LTE O-Fld(1.017) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.017.1))), Int(2) ) 1 1.017-ANM- ReturnResult O-Fld(1.017) T InfoItemCou ( nt Result(Pass(All Information Items are optional for this field.)) ) RT1.95 - Fie 8.1.17 Both information items are alphanumeric 1 1.017-DAN- ReturnResult O↑- B ld:1.017- and can have any special characters in the Value ( InfoI(1.017.D DAN-Value names. Result(Pass) AN) ) RT1.96 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.017-DAN- SubSet O↑- B ld:1.017- Table 22, Character Type for each field. CharType ( InfoI(1.017.D DAN- Chars({InfoI(1.017.DAN)}), AN) CharType Numeric values shall not contain leading CharAsciiPrintable zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.97 - Fie Table 22 Table 22 specifies the character count for 1 1.017-DAN GTE O↑- B ld:1.017- each field. -CharCount ( InfoI(1.017.D DAN- Count(Chars({InfoI(1.017.DAN}), AN) CharCount Int(1) ) RT1.98 - Fie 8.1.17 Both information items are alphanumeric 1 1.017- ReturnResult O↑- B ld:1.017- and can have any special characters in the OAN-Value ( InfoI(1.017.O OAN-Value names. Result(Pass) AN) ) RT1.99 - Fie 8.1 Section 8.1 and Table 22 specify the 1 1.017-OAN- SubSet O↑- B 66Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ld:1.017- Table 22, Character Type for each field. CharType ( InfoI(1.017.O OAN- Chars({InfoI(1.017.OAN)}), AN) CharType Numeric values shall not contain leading CharAsciiPrintable zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.100 - Fi Table 22 Table 22 specifies the character count for 1 1.017-OAN GTE O↑- B eld:1.017- each field. -CharCount ( InfoI(1.017.O OAN- Count(Chars({InfoI(1.017.OAN}), AN) CharCount Int(1) ) RT1.101 - Fi Table 22, Table 22 specifies which fields contain 1 1.018-GNS- EQ O-Fld(1.018) T eld: 1.018- Annex B, subfields and information items as well as SubfieldCou ( GNS- Annex G the number of occurrences permitted. nt Count(SubFldsIn(Fld(1.018))), FieldStructu Int(1) re A field contains a minimum of one ) subfield which contains a minimum of one 1 1.018-GNS- EQ O-Fld(1.018) T information item. InfoItemCou ( nt Count(InfoItemsIn(SubFld(1.018.1))), Int(1) ) RT1.102 - Fi 8.1.18 This optional field is used if the transaction 1 1.018-GNS- MO O-Fld(1.018) B eld: 1.018- uses GENC in lieu of ISO 3166-1 Value ( GNS-Value as a code set for country code {Fld(1.018)}, specifications. ISO 3166-1 is the default Set-Str([ISO, GENC]) country code set ) used for the transaction when this field is not contained in Record Type-1. The values for this field are: ISO, GENC RT1.103 - Fi 8.1 Section 8.1 and Table 22 specify the 1 1.018-GNS- SubSet O-Fld(1.018) B eld: 1.018- Table 22, Character Type for each field. CharType ( GNS- Chars({Fld(1.018.GNS)}), CharType Numeric values shall not contain leading CharAlpha zeros unless indicated by the standard text. ) Leading zeros are allowed for 1.002, 1.011, 1.012, 99.100, and 99.101. Any dates may also contain leading zeros. RT1.104 - Fi Table 22 Table 22 specifies the character count for 1 1.018-GNS- MO O-Fld(1.018) B eld: 1.018- each field. CharType ( GNS- Count(Chars({Fld(1.018})), CharCount Set-Int([3,4]) 67Req. # - ID Ref. in Requirement L Assertion Test N Imp. Imp. Supporte Test E Base Summary e ID Assertion o Required Support d Range Result n Std. v t c e e . l s Record Type-1: Transaction information record ) Annex D: Test Notes and Test Exceptions This Annex defines test notes and test exceptions that apply to requirements and assertions documented in Annex C as well as test notes and exceptions for those requirements which may be released in separate publications. As these test notes and requirements may need to be updated as additional requirements are documented, the test notes and test exceptions are included as an external reference. The test notes and exceptions will be made available at: http://www.nist.gov/itl/csd/biometrics/biocta_download.cfm. Acknowledgements This publication was the result of work was sponsored, in part, by the Department of Homeland Security/Office of Biometric Identity Management (OBIM). Christofer J. McGinnis, from IDTP, a NIST/ITL grantee, developed most of the test assertions documented in this publication. 68