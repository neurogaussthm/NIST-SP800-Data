[
  {
    "title": "Abstract",
    "subsections": [
      {
        "content": "Transport Layer Security (TLS) provides mechanisms to protect data during electronic dissemination across the Internet. This Special Publication provides guidance to the selection and configuration of TLS protocol implementations while making effective use of Federal Information Processing Standards (FIPS) and NIST-recommended cryptographic algorithms. It requires that TLS 1.2 configured with FIPS-based cipher suites be supported by all government TLS servers and clients and requires support for TLS 1.3 by January 1, 2024. This Special Publication also provides guidance on certificates and TLS extensions that impact security."
      }
    ]
  },
  {
    "title": "Executive Summary",
    "subsections": [
      {
        "content": "Office of Management and Budget (OMB) Circular A-130, Managing Information as a Strategic Resource, requires managers of public-facing information repositories or dissemination systems that contain sensitive but unclassified data to ensure that sensitive data is protected commensurate with the risk and magnitude of the harm that would result from the loss, misuse, or unauthorized access to or modification of such data. Given the nature of interconnected networks and the use of the Internet to share information, the protection of this sensitive data can become difficult if proper mechanisms are not employed to protect the data. Transport Layer Security (TLS) provides such a mechanism to protect sensitive data during electronic dissemination across the Internet."
      },
      {
        "content": "TLS is a protocol created to provide authentication, confidentiality, and data integrity protection between two communicating applications. TLS is based on a precursor protocol called the Secure Sockets Layer Version 3.0 (SSL 3.0) and is considered to be an improvement to SSL 3.0. SSL 3.0 is specified in [32]. The Transport Layer Security version 1 (TLS 1.0) is specified in Request for Comments (RFC) 2246 [23]. Each document specifies a similar protocol that provides security services over the Internet. TLS 1.0 has been revised to version 1.1, as documented in RFC 4346 [24], and TLS 1.1 has been further revised to version 1.2, as documented in RFC 5246 [25]. In addition, some extensions have been defined to mitigate some of the known security vulnerabilities in implementations using TLS versions 1.0, 1.1, and 1.2. TLS 1.3, described in RFC 8446 [57], is a significant update to previous versions that includes protections against security concerns that arose in previous versions of TLS."
      },
      {
        "content": "This Special Publication provides guidance on the selection and configuration of TLS protocol implementations while making effective use of NIST-approved cryptographic schemes and algorithms. In particular, it requires that TLS 1.2 be configured with cipher suites using NIST-approved schemes and algorithms as the minimum appropriate secure transport protocol and requires support for TLS 1.3 by January 1, 2024. When interoperability with non-government\n```# CURRENT_PAGE_RAW_OCR_TEXT"
      },
      {
        "content": "systems is required, TLS 1.1 and TLS 1.0 may be supported. This Special Publication also identifies TLS extensions for which mandatory support must be provided and also identifies other recommended extensions. The use of the recommendations provided in this Special Publication are intended to promote:"
      },
      {
        "content": "\nMore consistent use of authentication, confidentiality, and integrity mechanisms for the protection of information transported across the Internet;\nConsistent use of the recommended cipher suites that encompass NIST-approved algorithms and open standards;\nProtection against known and anticipated attacks on the TLS protocol; and\nInformed decisions by system administrators and managers in the integration of TLS implementations.\n"
      },
      {
        "content": "While these guidelines are primarily designed for federal users and system administrators to adequately protect sensitive but unclassified U.S. Federal Government data against serious threats on the Internet, they may also be used within closed network environments to segregate data. (The client-server model and security services discussed also apply in these situations). This Special Publication supersedes NIST Special Publication 800-52 Revision 1. This Special Publication should be used in conjunction with existing policies and procedures."
      }
    ]
  },
  {
    "title": "1996 Release of SSL 3.0",
    "subsections": [
      {
        "content": "During this timeframe, the Microsoft Corporation released a protocol known as Private Communications Technology (PCT) and later released a higher-performance protocol known as the Secure Transport Layer Protocol (STLP). PCT and STLP never commanded the market share that SSL 2.0 and SSL 3.0 commanded. The Internet Engineering Task Force (IETF), a technical working group responsible for developing Internet standards to ensure communications compatibility across different implementations, attempted to resolve security engineering and protocol incompatibility issues between the protocols as best it could."
      },
      {
        "content": "The IETF standards track Transport Layer Security protocol Version 1.0 (TLS 1.0) emerged and was codified by the IETF as Request for Comments (RFC) 2246 [23]. While TLS 1.0 is based on SSL 3.0, and the differences between them are not dramatic, they are significant enough that TLS 1.0 and SSL 3.0 do not interoperate."
      },
      {
        "title": "TLS 1.1",
        "content": [
          {
            "text": "TLS 1.1, specified in RFC 4346 [24], was developed to address weaknesses discovered in TLS 1.0, primarily in the areas of initialization vector selection and padding error processing. Initialization vectors were made explicit to prevent a certain class of attacks on the Cipher Block Chaining (CBC) mode of operation used by TLS. The handling of padding errors was altered to treat a padding error as a bad message authentication code rather than a decryption failure. In addition, the TLS 1.1 RFC acknowledges attacks on CBC mode that rely on the time to compute the message authentication code (MAC). The TLS 1.1 specification states that to defend against such attacks, an implementation must process records in the same manner regardless of whether padding errors exist. Further implementation considerations for CBC modes (which were not included in RFC 4346 [24]) are discussed in Section 3.3.2."
          }
        ]
      },
      {
        "title": "TLS 1.2",
        "content": [
          {
            "text": "TLS 1.2, specified in RFC 5246 [25], made several cryptographic enhancements, particularly in the area of hash functions, with the ability to use or specify the SHA-2 family of algorithms for hash, MAC, and Pseudorandom Function (PRF) computations. TLS 1.2 also adds authenticated encryption with associated data (AEAD) cipher suites."
          }
        ]
      },
      {
        "title": "TLS 1.3",
        "content": [
          {
            "text": "TLS 1.3, specified in RFC 8446 [57], represents a significant change to TLS that aims to address threats that have arisen over the years. Among the changes are a new handshake protocol, a new key derivation process that uses the HMAC-based Extract-and-Expand Key Derivation Function (HKDF) [37], and the removal of cipher suites that use RSA key transport or static Diffie-Hellman (DH) key exchanges, the CBC mode of operation, or SHA-1. Many extensions defined for use with TLS 1.2 and previous versions cannot be used with TLS 1.3."
          }
        ]
      },
      {
        "title": "1.2 Scope",
        "content": [
          {
            "text": "Security is not a single property that is (or is not) possessed by a protocol. Rather, security includes a complex set of related properties that together provide the required information assurance characteristics and information protection services. Security requirements are usually derived from a risk assessment of the threats or attacks that an adversary is...\n```# CURRENT PAGE RAW OCR TEXT"
          }
        ]
      },
      {
        "title": "likely to mount",
        "content": [
          {
            "text": "against a system. The adversary is likely to take advantage of implementation vulnerabilities found in many system components, including computer operating systems, application software systems, and the computer networks that interconnect them. Thus, in order to secure a system against a myriad of threats, security must be judiciously placed in the various systems and network layers."
          },
          {
            "text": "These guidelines focus only on network security, and they focus directly on the small portion of the network communications stack that is referred to as the transport layer. Several other NIST publications address security requirements in the other parts of the system and network layers. Adherence to these guidelines only protects the data in transit. Other applicable NIST standards and guidelines should be used to ensure protection of systems and stored data."
          },
          {
            "text": "These guidelines focus on the common use cases where clients and servers must interoperate with a wide variety of implementations, and authentication is performed using public-key certificates. To promote interoperability, implementations often support a wide array of cryptographic options. However, there are much more constrained TLS implementations where security is needed but broad interoperability is not required, and the cost of implementing unused features may be prohibitive. For example, minimal servers are often implemented in embedded controllers and network infrastructure devices, such as routers, and then used with browsers to remotely configure and manage the devices. There are also cases where both the client and server for an application's TLS connection are under the control of the same entity, and therefore allowing a variety of options for interoperability is not necessary. The use of an appropriate subset of the capabilities specified in these guidelines may be acceptable in such cases."
          },
          {
            "text": "The scope is further limited to TLS when used in conjunction with TCP/IP. For example, Datagram TLS (DTLS), which operates over datagram protocols, is outside the scope of these guidelines. NIST may issue separate guidelines for DTLS at a later date."
          },
          {
            "subsection": "1.2.1 Alternative Configurations",
            "text": []
          },
          {
            "text": "TLS may be used to secure the communications of a wide variety of applications in a diverse set of operating environments. As such, there is not a single configuration that will work well for all scenarios. These guidelines attempt to provide general-use recommendations. However, the needs of an agency or application may differ from general needs. Deviations from these guidelines are acceptable, provided that agencies and system administrators assess and accept the risks associated with alternative configurations in terms of both security and interoperability."
          },
          {
            "subsection": "1.3 Document Conventions",
            "text": []
          },
          {
            "text": "Throughout this document, key words are used to identify requirements. The key words \"shall,\" \"shall not,\" \"should,\" and \"should not\" are used. These words are a subset of# IETF Request for Comments (RFC) 2119 Key Words"
          },
          {
            "text": "The IETF Request for Comments (RFC) 2119 key words, and have been chosen based on convention in other normative documents [15]. In addition to the key words, the words \"need,\" \"can,\" and \"may\" are used in this document but are not intended to be normative. The key words \"NIST-approved\" and \"NIST-recommended\" are used to indicate that a scheme or algorithm is described in a Federal Information Processing Standard (FIPS) or is recommended by NIST in a Special Publication (SP)."
          },
          {
            "text": "The recommendations in this document are grouped by server recommendations and client recommendations. Section 3 provides detailed guidance for the selection and configuration of TLS servers. Section 4 provides detailed guidance for the selection, configuration, and use of TLS clients."
          }
        ]
      },
      {
        "title": "2 TLS Overview",
        "content": [
          {
            "text": "TLS exchanges records via the TLS record protocol. A TLS record contains several fields, including version information, application protocol data, and the higher-level protocol used to process the application data. TLS protects the application data by using a set of cryptographic algorithms to ensure the confidentiality, integrity, and authenticity of exchanged application data."
          },
          {
            "text": "TLS defines several protocols for connection management that sit on top of the record protocol, where each protocol has its own record type. These protocols, discussed in Section 2.1, are used to establish and change security parameters and to communicate error and warning conditions to the server and client. Sections 2.2 through 2.6 describe the security services provided by the TLS protocol and how those security services are provisioned. Section 2.7 discusses key management."
          },
          {
            "subsection": "2.1 TLS Subprotocols",
            "text": []
          },
          {
            "text": "There are three subprotocols in the TLS protocol that are used to control the session connection: the handshake, change cipher spec, and alert protocols. The TLS handshake protocol is used to negotiate the session parameters. The alert protocol is used to notify the other party of an error condition. The change cipher spec protocol is used in TLS 1.0, 1.1, and 1.2 to change the cryptographic parameters of a session. In addition, the client and the server exchange application data that is protected by the security services provisioned by the negotiated cipher suite. These security services are negotiated and established with the handshake."
          },
          {
            "text": "The handshake protocol consists of a series of message exchanges between the client and the server. The handshake protocol initializes both the client and server to use cryptographic capabilities by negotiating a cipher suite of algorithms and functions, including key establishment, digital signature, confidentiality, and integrity algorithms. Clients and servers can be configured so that one or more of the following security services are negotiated during the handshake: confidentiality, message integrity, authentication, and replay protection.# Confidentiality and Integrity Services"
          },
          {
            "text": "Confidentiality service provides assurance that data is kept secret, preventing eavesdropping. A message integrity service provides confirmation that unauthorized data modification is detected, thus preventing undetected deletion, addition, or modification of data. An authentication service provides assurance of the sender or receiver's identity, thereby detecting forgery. Replay protection ensures that an unauthorized user does not capture and successfully replay previous data. In order to comply with these guidelines, both the client and the server must be configured for data confidentiality and integrity services."
          }
        ]
      },
      {
        "title": "Handshake Protocol",
        "content": [
          {
            "text": "The handshake protocol is used to optionally exchange X.509 public-key certificates to authenticate the server to the client and may be used to authenticate the client to the server as well. The handshake protocol is responsible for establishing the session parameters. The client and server negotiate algorithms for authentication, confidentiality, and integrity, as well as derive symmetric keys and establish other session parameters, such as extensions. The negotiated set of cryptographic algorithms is called the cipher suite."
          },
          {
            "text": "Alerts are used to convey information about the session, such as errors or warnings. For example, an alert can be used to signal a decryption error (decrypt_error) or that access has been denied (access_denied). Some alerts are used for warnings, and others are considered fatal and lead to immediate termination of the session. A close_notify alert message is used to signal the normal termination of a session. Like all other messages after the handshake protocol is completed, alert messages are encrypted (and optionally compressed in TLS versions prior to TLS 1.3). Details of the handshake, change cipher spec (in TLS versions prior to 1.3), and alert protocols are outside the scope of these guidelines; they are described in RFC 5246 [25] and RFC 8446 [57]."
          }
        ]
      },
      {
        "title": "Shared Secret Negotiation",
        "content": [
          {
            "text": "The client and server establish keying material during the TLS handshake protocol. The derivation of the premaster secret depends on the key exchange method that is agreed upon and the version of TLS used. For example, when Diffie-Hellman is used as the key-exchange algorithm in TLS 1.2 and earlier versions, the client and server send each other their parameters, which are then used to compute the premaster secret. The premaster secret, along with random values exchanged by the client and server in the hello messages, is used in a pseudorandom function (PRF) to compute the master secret. In TLS 1.3, the master secret is derived by iteratively invoking an extract-then-expand function with previously derived secrets. The master secret is used to derive session keys, which are used by the negotiated security services to protect the data exchanged between the client and the server, thus providing a secure channel for the client and the server to communicate.# The establishment of these secrets is secure against eavesdroppers."
          },
          {
            "text": "When the TLS protocol is used in accordance with these guidelines, the application data, as well as the secrets, are not vulnerable to attackers who place themselves in the middle of the connection. The attacker cannot modify the handshake messages without being detected by the client and the server because the Finished message, which is exchanged after security parameter establishment, provides integrity protection for the entire exchange. In other words, an attacker cannot modify or downgrade the security of the connection by placing itself in the middle of the negotiation."
          }
        ]
      },
      {
        "title": "2.3 Confidentiality",
        "content": [
          {
            "text": "Confidentiality is provided for a communication session by the negotiated encryption algorithm for the cipher suite and the encryption keys derived from the master secret and random values, one for encryption by the client (the client write key) and another for encryption by the server (the server write key). The sender of a message (client or server) encrypts the message using the appropriate derived encryption key; the receiver uses the same (independently derived) key to decrypt the message. Both the client and server know these keys and decrypt the messages using the same key that was used for encryption."
          }
        ]
      }
    ]
  },
  {
    "title": "2.5 Authentication",
    "subsections": [
      {
        "content": "Server authentication is performed by the client using the server's public-key certificate, which the server presents during the handshake. The exact nature of the cryptographic operation for server authentication is dependent on the negotiated security parameters and extensions. In many cases, authentication is performed explicitly by verifying digital signatures using public keys that are present in certificates or implicitly by the use of the server public key by the client during the establishment of the master secret. A successful Finished message implies that both parties calculated the same master secret, and thus, the server must have known the private key corresponding to the public key in the server's certificate."
      },
      {
        "content": "Client authentication is optional and only occurs at the server's request. Client authentication is based on the client's public-key certificate. The exact nature of the cryptographic operation for client authentication depends on the negotiated cipher suite's key-exchange algorithm and the negotiated extensions. For example, when the client's public-key certificate contains an RSA public key, the client signs a portion of the handshake message using the private key corresponding to that public key, and the server verifies the signature using the client's public key to authenticate the client."
      }
    ]
  },
  {
    "title": "2.6 Anti-Replay",
    "subsections": [
      {
        "content": "TLS provides inherent protection against replay attacks, except when 0-RTT data (optionally sent in the first flight of handshake messages) is sent in TLS 1.3. The integrity-protected envelope of the message contains a monotonically increasing sequence number. Once the message integrity is verified, the sequence number of the current message is compared with the sequence number of the previous message. The sequence number of the current message must be greater than the sequence number of the previous message in order to further process the message."
      }
    ]
  },
  {
    "title": "2.7 Key Management",
    "subsections": [
      {
        "content": "The security of the server's private key is critical to the security of TLS. If the server's private key is weak or can be obtained by a third party, the third party can masquerade as the server to all clients. Similarly, if a third party can obtain a public-key certificate for a public key corresponding to its own private key in the name of a legitimate server from a certification authority (CA) trusted by the clients, the third party can masquerade as the server to the clients. Requirements and recommendations to mitigate these concerns are addressed later in these guidelines."
      },
      {
        "content": "Similar threats exist for clients. If a client's private key is weak or can be obtained by a third party, the third party can masquerade as the client to a server. Similarly, if a third party can obtain a public-key certificate for a public key corresponding to his own private key in the name of a client from a CA trusted by the server, the third party can masquerade as the client.\n``````markdown"
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "that client to the server. Requirements and recommendations to mitigate these concerns are addressed later in these guidelines. Since the random numbers generated by the client and server contribute to the randomness of the session keys, the client and server must be capable of generating random numbers with at least 112 bits of security each. The various TLS session keys derived from these random values and other data are valid for the duration of the session. Because the session keys are only used to protect messages exchanged during an active TLS session and are not used to protect any data at rest, there is no requirement for recovering TLS session keys. However, all versions of TLS provide mechanisms to store a key related to a session, which allow sessions to be resumed in the future. Keys for a resumed session are derived during an abbreviated handshake that uses the stored key as a form of authentication."
      }
    ]
  },
  {
    "title": "1.3",
    "subsections": [
      {
        "content": "for both government-only and citizen or business-facing applications. In general, servers that support TLS 1.3 should be configured to use TLS 1.2 as well. However, TLS 1.2 may be disabled on servers that support TLS 1.3 if it has been determined that TLS 1.2 is not needed for interoperability. Some server implementations are known to implement version negotiation incorrectly. For example, there are TLS 1.0 servers that terminate the connection when the client offers a version newer than TLS 1.0. Servers that incorrectly implement TLS version negotiation shall not be used."
      },
      {
        "title": "3.2 Server Keys and Certificates",
        "content": [
          {
            "text": "The TLS server shall be configured with one or more public-key certificates and the associated private keys. TLS server implementations should support the use of multiple server certificates with their associated private keys to support algorithm and key size agility. Several options for TLS server certificates meet the requirement for NIST-approved cryptography: an RSA signature certificate, an Elliptic Curve Digital Signature Algorithm (ECDSA) signature certificate, a Digital Signature Algorithm (DSA) signature certificate, a Diffie-Hellman (DH) certificate, and an Elliptic Curve Diffie-Hellman (ECDH) certificate. At a minimum, TLS servers conforming to this specification shall be configured with an RSA signature certificate or an ECDSA signature certificate. The other certificate types and their associated cipher suites are not commonly used, especially in externally-accessible servers, but are included in these guidelines for completeness and to cover edge cases. If the server is configured with an ECDSA signature certificate, either curve P-256 or curve P-384 should be used for the public key in the certificate."
          },
          {
            "text": "TLS servers shall be configured with certificates issued by a CA that publishes revocation information in Online Certificate Status Protocol (OCSP) [63] responses. The CA may additionally publish revocation information in a certificate revocation list (CRL) [19]. The source(s) for the revocation information shall be included in the CA-issued certificate in the appropriate extension to promote interoperability."
          },
          {
            "text": "A TLS server that has been issued certificates by multiple CAs can select the appropriate certificate based on the client-specified \"Trusted CA Keys\" TLS extension (see Section 3.4.2.6). A TLS server that has been issued certificates for multiple server names can select the appropriate certificate based on the client-specified \"Server Name\" TLS extension (see Section 3.4.1.2). A TLS server certificate may also contain multiple names in the Subject Alternative Name extension in order to allow the use of multiple server names of the same name form, such as a Domain Name System (DNS) name, or multiple server names of multiple name forms (e.g., DNS names, IP address, etc.)."
          },
          {
            "text": "Application processes for obtaining certificates differ and require different\n```# Levels of Proof When Associating Certificates to Domains"
          },
          {
            "text": "An applicant can obtain a domain-validated (DV) certificate by proving control over a DNS domain. An Organization Validation (OV) certificate requires further vetting. An Extended Validation (EV) certificate has the most thorough identity vetting process. This recommendation does not provide guidance on which verification level to use."
          }
        ]
      },
      {
        "title": "Section 3.2.1: Server Certificate Profile",
        "content": [
          {
            "text": "The server certificate profile, described in this section, provides requirements and recommendations for the format of the server certificate. To comply with these guidelines, the TLS server certificate shall be an X.509 version 3 certificate; both the public key contained in the certificate and the signature shall provide at least 112 bits of security. Prior to TLS 1.2, the server Certificate message required that the signing algorithm for the certificate be the same as the algorithm for the certificate key (see Section 7.4.2 of [24]). If the server supports TLS versions prior to TLS 1.2, the certificate should be signed with an algorithm consistent with the public key:"
          },
          {
            "text": "\nCertificates containing RSA, ECDSA, or DSA public keys should be signed with those same signature algorithms, respectively;\nCertificates containing Diffie-Hellman public keys should be signed with DSA; and\nCertificates containing ECDH public keys should be signed with ECDSA.\n"
          },
          {
            "text": "The extended key usage extension limits how the keys in a certificate are used. There is a key purpose specifically for server authentication, and the server should be configured to allow its use. The use of the extended key usage extension will facilitate successful server authentication, as some clients may require the presence of an extended key usage extension. The use of the server DNS name in the Subject Alternative Name field ensures that any name constraints on the certification path will be properly enforced."
          },
          {
            "text": "The server certificate profile is listed in Table 3-1. In the absence of agency-specific certificate profile requirements, this certificate profile should be used for the server certificate."
          }
        ]
      },
      {
        "title": "Section 3.2.2: Obtaining Revocation Status Information for the Client Certificate",
        "content": [
          {
            "text": "The server shall perform revocation checking of the client certificate when client authentication is used. Revocation information shall be obtained by the server from one or more of the following locations:"
          },
          {
            "text": "\nCertificate Revocation List (CRL) or OCSP [63] response in the server's local store;\nOCSP response from a locally-configured OCSP responder;\nOCSP response from the OCSP responder location identified in the OCSP field in the Authority Information Access extension in the client certificate; or\nCRL from the CRL Distribution Points extension in the client certificate.# CURRENT_PAGE_RAW_OCR_TEXT\n"
          },
          {
            "text": "When the local store does not have the current or a cogent CRL or OCSP response and the OCSP responder and the CRL distribution point are unavailable or inaccessible at the time of TLS session establishment, the server will either deny the connection or accept a potentially revoked or compromised certificate. The decision to accept or reject a certificate in this situation should be made according to agency policy."
          }
        ]
      },
      {
        "title": "3.2.3 Server Public-Key Certificate Assurance",
        "content": [
          {
            "text": "The policies, procedures, and security controls under which a public-key certificate is issued by a CA are documented in a certificate policy. The use of a certificate policy that is designed with the secure operation of Public Key Infrastructure (PKI) in mind and adherence to the stipulated certificate policy mitigates the threat that the issuing CA can be compromised or that the registration system, persons, or process can be compromised to obtain an unauthorized certificate in the name of a legitimate entity and thus compromise the clients. With this in mind, the CA Browser Forum, a private-sector organization, has carried out some efforts in this area by writing requirements for issuing certificates from publicly trusted CAs in order for those CAs and their trust anchor to remain in browser trust stores [16]. Under another effort, the CA Browser Forum has written guidelines for issuing Extended Validation Certificates [17]."
          },
          {
            "text": "Several concepts are under development that further mitigate the risks associated with the compromise of a CA or X.509 certificate registration system, process, or personnel. These include the Certificate Transparency project (see Section 3.4.2.15) and other emerging concepts, which are discussed in Appendix E."
          },
          {
            "text": "The policy under which a certificate has been issued may optionally be represented in the certificate using the certificatePolicies extension, specified in [19] and updated in [72]. When used, one or more certificate policy object identifiers (OID) are asserted in this extension, with each OID representing a specific certificate policy. Many TLS clients (e.g., browsers), however, do not offer the ability to accept or reject certificates based on the policies under which they were issued. Therefore, it is generally necessary for TLS server certificates to be issued by CAs that only issue certificates in accordance with a certificate policy that specifies adequate security controls."
          },
          {
            "text": "When an agency is obtaining a certificate for a TLS server for which all the clients are under the agency's control, the agency may issue the certificate from its own CA if it can configure the clients to trust that CA. In other cases, the agency should obtain a certificate from a publicly-trusted CA (a CA that clients that will be connecting to the server have already been configured to trust)."
          }
        ]
      },
      {
        "title": "3.3 Cryptographic Support",
        "content": [
          {
            "text": "Cryptographic support in TLS is provided through the use of various cipher suites. A cipher suite specifies a collection of algorithms for key exchange (in TLS 1.2 and earlier only) and for# Providing Confidentiality and Integrity Services to Application Data"
          },
          {
            "text": "The cipher suite negotiation occurs during the TLS handshake protocol. The client presents cipher suites that it supports to the server, and the server selects one of them to secure the session data. In addition to the selection of appropriate cipher suites, system administrators may also have additional considerations specific to the implementation of the cryptographic algorithms, as well as cryptographic module validation requirements. Acceptable cipher suites are listed in Section 3.3.1, grouped by certificate type and protocol version. Cipher suite implementation considerations are discussed in Section 3.3.2, and recommendations regarding cryptographic module validation are described in Section 3.3.3."
          }
        ]
      },
      {
        "title": "3.3.1 Cipher Suites",
        "content": [
          {
            "text": "Cipher suites specify the cryptographic algorithms that will be used for a session. Cipher suites in TLS 1.0 through TLS 1.2 have the form:"
          },
          {
            "text": "TLS_KeyExchangeAlg_WITH_EncryptionAlg_MessageAuthenticationAlg"
          },
          {
            "text": "For example, the cipher suite TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA uses ephemeral ECDH key establishment with parameters signed using RSA, confidentiality provided by AES-128 (Advanced Encryption Standard with 128-bit key) in cipher block chaining mode, and message authentication performed using HMAC_SHA. For further information on cipher suite interpretation, see Appendix B."
          },
          {
            "text": "Cipher suites are defined differently in TLS 1.3. These cipher suites do not specify the key exchange algorithm and have the form:"
          },
          {
            "text": "TLS_AEAD_HASH"
          },
          {
            "text": "For example, the cipher suite TLS_AES_128_GCM_SHA256 uses AES-128 in Galois Counter Mode for confidentiality and message authentication and uses SHA-256 for the PRF. TLS 1.3 cipher suites cannot be negotiated for TLS 1.2 connections, and TLS 1.2 cipher suites cannot be negotiated with TLS 1.3."
          },
          {
            "text": "When negotiating a cipher suite, the client sends a handshake message with a list of cipher suites it will accept. The server chooses from the list and sends a handshake message back indicating which cipher suite it will accept. Although the client may order the list with what it considers to be the strongest cipher suites listed first, the server may ignore the preference order and choose any of the cipher suites proposed by the client. The server may have its own cipher suite preference order, and it may be different from the client's. Therefore, there is no guarantee that the negotiation will settle on the strongest common suite. If no cipher suites are common to the client and server, the connection is aborted."
          },
          {
            "text": "The server shall be configured to only use cipher suites that are composed entirely of NIST-approved algorithms (i.e., [6, 7, 9, 26-28, 44-46, 49]). A complete list of acceptable cipher suites for general use is provided in this section, grouped by certificate type and TLS protocol version. The Internet Assigned Numbers Authority (IANA) value for each cipher suite is given after its text description in parentheses."
          },
          {
            "text": "In some situations, such as closed environments, it may be appropriate to use pre-shared keys.# Pre-shared Keys and Cipher Suites"
          },
          {
            "text": "Pre-shared keys are symmetric keys that are already in place prior to the initiation of a TLS session and are used in the derivation of the premaster secret. For cipher suites that are acceptable in pre-shared key environments, see Appendix C."
          },
          {
            "text": "NIST is deprecating the use of RSA key transport as used in TLS. Some applications or environments may require the use of RSA key transport during a transition period. Acceptable cipher suites for use in this situation are located in Appendix D."
          },
          {
            "text": "The following cipher suite listings are grouped by certificate type and TLS protocol version. The cipher suites in these lists include the cipher suites that contain NIST-approved cryptographic algorithms. Cipher suites that do not appear in this section, Appendix C, or Appendix D shall not be used."
          },
          {
            "text": "Cipher suites using ephemeral DH and ephemeral ECDH (i.e., those with DHE or ECDHE in the second mnemonic) provide perfect forward secrecy. When ephemeral keys are used to establish the master secret, each ephemeral key-pair (i.e., the server ephemeral key-pair and the client ephemeral key-pair) shall have at least 112 bits of security."
          }
        ]
      },
      {
        "title": "3.3.1.1 Cipher Suites for TLS 1.2 and Earlier Versions",
        "content": [
          {
            "text": "The first revision of this guidance required support for a small set of cipher suites to promote interoperability and align with TLS specifications. There are no longer any mandatory cipher suite requirements. Cipher suites that comprise AES and other NIST-approved algorithms are acceptable to use, although they are not necessarily equal in terms of security. Cipher suites that use the Triple Data Encryption Algorithm (TDEA, also written as 3DES) are no longer allowed due to the limited amounts of data that can be processed under a single key. The server shall be configured to only use cipher suites for which it has a valid certificate containing a signature providing at least 112 bits of security."
          },
          {
            "text": "By removing requirements that specific cipher suites be supported, system administrators have more freedom to meet the needs of their environments and applications. It also increases agility by allowing administrators to immediately disable cipher suites when attacks are discovered without breaking compliance."
          },
          {
            "text": "If a subset of the cipher suites that are acceptable for the server certificate(s) are supported, the following list gives general guidance on choosing the strongest options:"
          },
          {
            "text": "\nPrefer ephemeral keys over static keys (i.e., prefer DHE over DH, and prefer ECDHE over ECDH). Ephemeral keys provide perfect forward secrecy.\nPrefer GCM or CCM modes over CBC mode. The use of an authenticated encryption mode prevents several attacks (see Section 3.3.2 for more information). Note that these are not available in versions prior to TLS 1.2.\nPrefer CCM over CCM_8. The latter contains a shorter authentication tag, which provides a lower authentication strength.\n"
          },
          {
            "text": "This list does not have to be strictly followed, as some environments or applications may have special circumstances. Note that this list may become outdated if an attack emerges on.# CURRENT PAGE RAW OCR TEXT"
          },
          {
            "text": "one of the preferred components. If an attack significantly impacts the recommended cipher suites, NIST will address the issue in an announcement on the NIST Computer Security Resource Center website (https://csrc.nist.gov)."
          }
        ]
      },
      {
        "title": "3.3.1.1.1 Cipher Suites for ECDSA Certificates",
        "content": [
          {
            "text": "TLS version 1.2 includes authenticated encryption modes and support for the SHA-256 and SHA-384 hash algorithms, which are not supported in prior versions of TLS. These cipher suites are described in [61] and [56]. TLS 1.2 servers that are configured with ECDSA certificates may be configured to support the following cipher suites, which are only supported by TLS 1.2:"
          },
          {
            "text": "\nTLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 (0xC0, 0x2B)\nTLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 (0xC0, 0x2C)\nTLS_ECDHE_ECDSA_WITH_AES_128_CCM (0xC0, 0xAC)\nTLS_ECDHE_ECDSA_WITH_AES_256_CCM (0xC0, 0xAD)\nTLS_ECDHE_ECDSA_WITH_AES_128_CCM_8 (0xC0, 0xAE)\nTLS_ECDHE_ECDSA_WITH_AES_256_CCM_8 (0xC0, 0xAF)\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256 (0xC0, 0x23)\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384 (0xC0, 0x24)\n"
          },
          {
            "text": "TLS servers may be configured to support the following cipher suites when ECDSA certificates are used with TLS versions 1.2, 1.1, or 1.0:"
          },
          {
            "text": "\nTLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA (0xC0, 0x09)\nTLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA (0xC0, 0x0A)\n"
          }
        ]
      },
      {
        "title": "3.3.1.1.2 Cipher Suites for RSA Certificates",
        "content": [
          {
            "text": "TLS 1.2 servers that are configured with RSA certificates may be configured to support the following cipher suites:"
          },
          {
            "text": "\nTLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC0, 0x2F)\nTLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xC0, 0x30)\nTLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (0x00, 0x9E)\nTLS_DHE_RSA_WITH_AES_256_GCM_SHA384 (0x00, 0x9F)\nTLS_DHE_RSA_WITH_AES_128_CCM (0xC0, 0x9E)\nTLS_DHE_RSA_WITH_AES_256_CCM (0xC0, 0x9F)\nTLS_DHE_RSA_WITH_AES_128_CCM_8 (0xC0, 0xA2)\nTLS_DHE_RSA_WITH_AES_256_CCM_8 (0xC0, 0xA3)\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256 (0xC0, 0x27)\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384 (0xC0, 0x28)\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA256 (0x00, 0x67)\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA256 (0x00, 0x6B)\n"
          },
          {
            "text": "TLS servers may be configured to support the following cipher suites when RSA certificates are used with TLS versions 1.2, 1.1, or 1.0:"
          },
          {
            "text": "\nTLS_ECDHE_RSA_WITH_AES_128_CBC_SHA (0xC0, 0x13)\nTLS_ECDHE_RSA_WITH_AES_256_CBC_SHA (0xC0, 0x14)\nTLS_DHE_RSA_WITH_AES_128_CBC_SHA (0x00, 0x33)\nTLS_DHE_RSA_WITH_AES_256_CBC_SHA (0x00, 0x39)\n"
          }
        ]
      },
      {
        "title": "3.3.1.1.3 Cipher Suites for DSA Certificates",
        "content": [
          {
            "text": "TLS 1.2 servers that are configured with DSA certificates may be configured to support the following cipher suites:"
          },
          {
            "text": "\nTLS_DHE_DSS_WITH_AES_128_GCM_SHA256 (0x00, 0xA2)\nTLS_DHE_DSS_WITH_AES_256_GCM_SHA384 (0x00, 0xA3)\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA256 (0x00, 0x40)\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA256 (0x00, 0x6A)\n"
          },
          {
            "text": "TLS servers may be configured to support the following cipher suites when DSA certificates are used with TLS versions 1.2, 1.1, or 1.0:"
          },
          {
            "text": "\nTLS_DHE_DSS_WITH_AES_128_CBC_SHA (0x00, 0x32)\nTLS_DHE_DSS_WITH_AES_256_CBC_SHA (0x00, 0x38)\n"
          }
        ]
      },
      {
        "title": "3.3.1.1.4 Cipher Suites for DH Certificates# DH Certificates",
        "content": [
          {
            "text": "DH certificates contain a static key and are signed using either DSA or RSA. Unlike cipher suites that use ephemeral DH, these cipher suites contain static DH parameters. While the use of static keys is technically acceptable, the use of ephemeral key cipher suites is encouraged and preferred over the use of the cipher suites listed in this section."
          }
        ]
      },
      {
        "title": "DSA-Signed DH Certificates",
        "content": [
          {
            "text": "TLS 1.2 servers that are configured with DSA-signed DH certificates may be configured to support the following cipher suites:"
          },
          {
            "text": "\nTLS_DH_DSS_WITH_AES_128_GCM_SHA256 (0x00, 0xA4)\nTLS_DH_DSS_WITH_AES_256_GCM_SHA384 (0x00, 0xA5)\nTLS_DH_DSS_WITH_AES_128_CBC_SHA256 (0x00, 0x3E)\nTLS_DH_DSS_WITH_AES_256_CBC_SHA256 (0x00, 0x68)\n"
          },
          {
            "text": "TLS servers may be configured to support the following cipher suites when DSA-signed DH certificates are used with TLS versions 1.2, 1.1, or 1.0:"
          },
          {
            "text": "\nTLS_DH_DSS_WITH_AES_128_CBC_SHA (0x00, 0x30)\nTLS_DH_DSS_WITH_AES_256_CBC_SHA (0x00, 0x36)\n"
          }
        ]
      }
    ]
  },
  {
    "title": "Cipher Suites for ECDH Certificates",
    "subsections": [
      {
        "content": "ECDH certificates contain a static key and are signed using either ECDSA or RSA. Unlike cipher suites that use ephemeral ECDH, these cipher suites contain static ECDH parameters. The use of ephemeral key cipher suites is encouraged and preferred over the use of the cipher suites listed in this section."
      },
      {
        "title": "ECDSA-Signed ECDH Certificates",
        "content": [
          {
            "text": "TLS 1.2 servers that are configured with ECDSA-signed ECDH certificates may be configured to support the following cipher suites:"
          },
          {
            "text": "\nTLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256 (0xC0, 0x2D)\nTLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384 (0xC0, 0x2E)\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256 (0xC0, 0x25)\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384 (0xC0, 0x26)\n"
          },
          {
            "text": "TLS servers may be configured to support the following cipher suites when ECDSA-signed ECDH certificates are used with TLS versions 1.2, 1.1, or 1.0:"
          },
          {
            "text": "\nTLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA (0xC0, 0x04)\nTLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA (0xC0, 0x05)\n"
          }
        ]
      }
    ]
  },
  {
    "title": "Cipher Suites for TLS 1.3# TLS 1.3 Cipher Suites",
    "subsections": [
      {
        "content": "TLS 1.3 servers may be configured to support the following cipher suites:"
      },
      {
        "content": "\nTLS_AES_128_GCM_SHA256 (0x13, 0x01)\nTLS_AES_256_GCM_SHA384 (0x13, 0x02)\nTLS_AES_128_CCM_SHA256 (0x13, 0x04)\nTLS_AES_128_CCM_8_SHA256 (0x13, 0x05)\n"
      },
      {
        "content": "These cipher suites may be used with either RSA or ECDSA server certificates; DSA and DH certificates are not supported by TLS 1.3. These cipher suites may also be used with pre-shared keys, as specified in Appendix C."
      },
      {
        "title": "3.3.2 Implementation Considerations",
        "content": [
          {
            "text": "System administrators need to fully understand the ramifications of selecting cipher suites and configuring applications to support only those cipher suites. The security guarantees of the cryptography are limited to the weakest cipher suite supported by the configuration. When configuring an implementation, there are several factors that affect the selection of supported cipher suites."
          },
          {
            "text": "RFC 4346 [24] describes timing attacks on CBC cipher suites, as well as mitigation techniques. TLS implementations shall use the bad_record_mac error to indicate a padding error when communications are secured using a CBC cipher suite. Implementations shall compute the MAC regardless of whether padding errors exist."
          },
          {
            "text": "In addition to the CBC attacks addressed in RFC 4346 [24], the Lucky 13 attack [1] demonstrates that a constant-time decryption routine is also needed to prevent timing attacks. TLS implementations should support constant-time decryption or near constant-time decryption."
          },
          {
            "text": "The POODLE attack exploits nondeterministic padding in SSL 3.0 [43]. The vulnerability does not exist in the TLS protocols, but the vulnerability can exist in a TLS implementation when the SSL decoder code is reused to process TLS data [38]. TLS implementations shall correctly decode the CBC padding bytes."
          },
          {
            "text": "Note that CBC-based attacks can be prevented by using AEAD cipher suites (e.g., GCM, CCM), which are supported in TLS 1.2."
          },
          {
            "subsection": "3.3.2.1 Algorithm Support",
            "text": []
          },
          {
            "text": "Many TLS servers and clients support cipher suites that are not composed of only NIST-approved algorithms. Therefore, it is important that the server is configured to only use NIST-recommended cipher suites. This is particularly important for server implementations that do not allow the server administrator to specify preference order. In such servers, the only way to ensure that a server uses NIST-approved algorithms is to disable cipher suites that use other algorithms."
          },
          {
            "text": "If the server implementation does allow the server administrator to specify a preference, the system administrator is encouraged to use the preference recommendations listed in Section 3.3.1.1."
          }
        ]
      },
      {
        "title": "3.3.3 Validated Cryptography",
        "content": [
          {
            "text": "The cryptographic module used by the server shall be a FIPS 140-validated cryptographic module [50, 51]. All cryptographic algorithms that are included in the configured cipher suites and the random number generator shall be within the scope of the validation.# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "Note that the TLS 1.0 and 1.1 pseudorandom function (PRF) uses MD5 and SHA-1 in parallel so that if one hash function is broken, security is not compromised. While MD5 is not a NIST-approved algorithm, the PRF is specified as acceptable in SP 800-135 [21]. In TLS 1.2, the default hash function in the PRF is SHA-256. TLS 1.3 replaces the PRF with the HMAC-based Extract-and-Expand Key Derivation Function (HKDF), described in RFC 5869 [37]."
          },
          {
            "text": "Also note that in TLS versions prior to 1.2, the use of SHA-1 is considered acceptable for signing ephemeral keys and for client authentication using digital signatures. This is due to the difficulty for a third party to cause a collision that is not detected. Other than the SHA-1 exception listed for specific instances above, all cryptography used shall provide at least 112 bits of security. All server and client certificates shall contain public keys that offer at least 112 bits of security. All server and client certificates and certificates in their certification paths shall be signed using key pairs that offer at least 112 bits of security and SHA-224 or a stronger hashing algorithm. All ephemeral keys used by the client and server shall offer at least 112 bits of security. All symmetric algorithms used to protect the TLS data shall use keys that offer at least 112 bits of security."
          },
          {
            "text": "The FIPS 140 validation certificate for the cryptographic module used by the server shall indicate that the random bit generator (RBG) has been validated in accordance with the SP 800-90 series [8, 48, 66]. The server random value, sent in the ServerHello message, contains a 4-byte timestamp value and 28-byte random value in TLS versions 1.0, 1.1, and 1.2, and contains a 32-byte random value in TLS 1.3. The validated random number generator shall be used to generate the random bytes of the server random value. The validated random number generator should be used to generate the 4-byte timestamp of the server random value."
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "title": "3.4.1 Mandatory TLS Extensions",
        "content": [
          {
            "text": "The server shall support the use of the following TLS extensions."
          },
          {
            "text": "\nRenegotiation Indication\nServer Name Indication\nExtended Master Secret\nSignature Algorithms\nCertificate Status Request extension\n"
          },
          {
            "subsection": "3.4.1.1 Renegotiation Indication",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2"
          },
          {
            "text": "In TLS versions 1.0 to 1.2, session renegotiation is vulnerable to an attack in which the attacker forms a TLS connection with the target server, injects content of its choice, and then splices in a new TLS connection from a legitimate client. The server treats the legitimate client's initial TLS handshake as a renegotiation of the attacker's negotiated session and thus believes that the initial data transmitted by the attacker is from the legitimate client. The session renegotiation extension is defined to prevent such a session splicing or session interception. The extension uses the concept of cryptographically binding the initial session negotiation and session renegotiation. Server implementations shall perform initial and subsequent renegotiations in accordance with RFC 5746 [59] and RFC 8446 [57]."
          },
          {
            "subsection": "3.4.1.2 Server Name Indication",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2, 1.3"
          },
          {
            "text": "Multiple virtual servers may exist at the same network address. The server name indication extension allows the client to specify which of the servers located at the address it is trying to connect with. This extension is available in all versions of TLS. The server shall be able to process and respond to the server name indication extension received in a ClientHello message as described in [29]."
          },
          {
            "subsection": "3.4.1.3 Extended Master Secret",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2"
          },
          {
            "text": "Bhargavan et al. have shown that an active attacker can synchronize two TLS sessions such that they share the same master secret, thus allowing the attacker to perform a man-in-the-middle attack [12]. The Extended Master Secret extension, specified in RFC 7627 [13], prevents such attacks by binding the master secret to a hashed log of the full handshake. The server shall support the use of this extension."
          },
          {
            "subsection": "3.4.1.4 Signature Algorithms",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.2, 1.3"
          },
          {
            "text": "Servers shall support the processing of the signature algorithms extension received in a ClientHello message. The extension, its syntax, and processing rules are described in Sections 7.4.1.4.1, 7.4.2, and 7.4.3 of RFC 5246 [25] and Section 4.2.3 of RFC 8446 [57]. Note that the extension described in RFC 8446 updates the extension described in RFC 5246 by adding an additional signature scheme."
          },
          {
            "subsection": "3.4.1.5 Certificate Status Request",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2, 1.3"
          },
          {
            "text": "When the client wishes to receive the revocation status of the TLS server certificate from the\n```# TLS Server and Client Communication"
          },
          {
            "text": "The client includes the Certificate Status Request (status_request) extension in the ClientHello message. Upon receipt of the status_request extension, a server with a certificate issued by a CA that supports OCSP shall include the certificate status along with its certificate by sending a CertificateStatus message immediately following the Certificate message. While the extension itself is extensible, only OCSP-type certificate status is defined in [29]. This extension is also called OCSP stapling."
          }
        ]
      },
      {
        "title": "3.4.2 Conditional TLS Extensions",
        "content": [
          {
            "text": "Support the use of the following TLS extensions under the circumstances described in the following subsections:"
          },
          {
            "text": "\nThe Fallback Signaling Cipher Suite Value (SCSV) shall be supported if the server supports versions of TLS prior to TLS 1.2 and does not support TLS 1.3.\nThe Supported Groups extension shall be supported if the server supports ephemeral ECDH cipher suites or if the server supports TLS 1.3.\nThe Key Share extension shall be supported if the server supports TLS 1.3.\nThe EC Point Format extension shall be supported if the server supports EC cipher suites.\nThe Multiple Certificate Status extension should be supported if status information for the server's certificate is available via OCSP and the extension is supported by the server implementation.\nThe Trusted CA Indication extension shall be supported if the server communicates with memory-constrained clients (e.g., low-memory client devices in the Internet of Things) and the server has been issued certificates by multiple CAs.\nThe Encrypt-then-MAC extension shall be supported if the server is configured to negotiate CBC cipher suites.\nThe Truncated HMAC extension may be supported if the server communicates with constrained-device clients, cipher suites that use CBC mode are supported, and the server implementation does not support variable-length padding.\nThe Pre-Shared Key extension may be supported if the server supports TLS 1.3.\nThe Pre-Shared Key Exchange Modes extension shall be supported if the server supports TLS 1.3 and the Pre-Shared Key extension.\nThe Supported Versions extension shall be supported if the server supports TLS 1.3.\nThe Cookie extension shall be supported if the server supports TLS 1.3.\nThe Certificate Signature Algorithms Extension shall be supported if the server supports TLS 1.3 and should be supported for TLS 1.2.\nThe Post-handshake Client Authentication extension may be supported if the server supports TLS 1.3.\nThe Signed Certificate Timestamps extension should be supported if the server's certificate was issued by a publicly trusted CA and the certificate does not include a Signed Certificate Timestamps List extension.\n"
          },
          {
            "subsection": "3.4.2.1 Fallback Signaling Cipher Suite Value (SCSV)",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2"
          },
          {
            "text": "TLS 1.3 includes a downgrade protection mechanism that previous versions do not. In versions# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "Prior to TLS 1.3",
        "content": [
          {
            "text": "An attacker can use an external version negotiation as a means to force unnecessary protocol downgrades on a connection. In particular, the attacker can make it appear that the connection failed with the requested TLS version, and some client implementations will try the connection again with a downgraded protocol version. This cipher suite value, described in RFC 7507 [42], provides a mechanism to prevent unintended protocol downgrades in versions prior to TLS 1.3. Clients signal when a connection is a fallback, and if the server deems it inappropriate (i.e., the server supports a higher TLS version), the server returns a fatal alert. When TLS versions prior to TLS 1.2 are supported by the server and TLS version 1.3 is not supported, the fallback SCSV shall be supported."
          }
        ]
      },
      {
        "title": "3.4.2 Supported Groups",
        "content": [
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2, 1.3"
          },
          {
            "text": "The Supported Groups extension (supported_groups) allows the client to indicate the domain parameter groups that it supports to the server. The extension was originally called the Supported Elliptic Curves extension (elliptic_curves) and was only used for elliptic curve groups, but it may now also be used to negotiate finite field groups. In TLS 1.3, the Supported Groups extension must be used to negotiate both elliptic curve and finite field groups. Servers that support either ephemeral ECDH cipher suites or TLS 1.3 shall support this extension. When elliptic curve cipher suites are configured, at least one of the NIST-approved curves, P-256 (secp256r1) and P-384 (secp384r1), shall be supported as described in RFC 8422 [52]. Additional NIST-recommended elliptic curves are listed in SP 800-56A, Appendix D [6]. Finite field groups that are approved for TLS in SP 800-56A, Appendix D may be supported."
          }
        ]
      },
      {
        "title": "3.4.2.3 Key Share",
        "content": [
          {
            "text": "Applies to TLS version 1.3"
          },
          {
            "text": "The Key Share extension is used in TLS 1.3 to send cryptographic parameters. Servers that support TLS 1.3 shall support this extension as described in Section 4.2.7 of RFC 8446 [57]."
          }
        ]
      },
      {
        "title": "3.4.2.4 Supported Point Formats",
        "content": [
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2"
          },
          {
            "text": "Servers that support EC cipher suites with TLS 1.2 and below shall be able to process the supported point format received in the ClientHello message by the client. The servers shall process this extension in accordance with Section 5.1 of RFC 8422 [52]. Servers that support EC cipher suites shall also be able to send the supported EC point format in the ServerHello message as described in Section 5.2 of RFC 8422 [52]."
          }
        ]
      }
    ]
  },
  {
    "title": "3.4.2 Extensions",
    "subsections": [
      {
        "title": "3.4.2.6 Trusted CA Indication",
        "content": [
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2\nThe trusted CA indication (trusted_ca_keys) extension allows a client to specify which CA root keys it possesses. This is useful for sessions where the client is memory-constrained and possesses a small number of root CA keys. Servers that communicate with memory-constrained clients and that have been issued certificates by multiple CAs shall be able to process and respond to the trusted CA indication extension received in a ClientHello message as described in [29]."
          }
        ]
      },
      {
        "title": "3.4.2.7 Encrypt-then-MAC",
        "content": [
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2\nSeveral attacks on CBC cipher suites have been possible due to the MAC-then-encrypt order of operations used in TLS versions 1.0, 1.1, and 1.2. The Encrypt-then-MAC extension alters the order that the encryption and MAC operations are applied to the data. This is believed to provide stronger security and mitigate or prevent several known attacks on CBC cipher suites. Servers that are configured to negotiate CBC cipher suites shall support this extension as described in [33]."
          }
        ]
      },
      {
        "title": "3.4.2.8 Truncated HMAC",
        "content": [
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2\nThe Truncated HMAC extension allows a truncation of the HMAC output to 80 bits for use as a MAC tag. An 80-bit MAC tag complies with the recommendations in SP 800-107 [20] but reduces the security provided by the integrity algorithm. Because forging a MAC tag is an online attack, and the TLS session will terminate immediately when an invalid MAC tag is encountered, the risk introduced by using this extension is low. However, truncated MAC tags shall not be used in conjunction with variable-length padding due to attacks described by Paterson et al. [53]. This extension is only applicable when cipher suites that use CBC modes are supported."
          }
        ]
      },
      {
        "title": "3.4.2.9 Pre-Shared Key",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe Pre-Shared Key (PSK) extension (pre_shared_key), available in TLS 1.3, is used to indicate the identity of the pre-shared key to be used for PSK key establishment. In TLS 1.3 pre-shared keys may either be established out-of-band, as in TLS 1.2 or below, or in a previous connection, in which case they are used for session resumption. Servers that support TLS 1.3 may be configured to support this extension in order to support session resumption or to support the use of pre-shared keys that are established out-of-band."
          }
        ]
      },
      {
        "title": "3.4.2.10 Pre-Shared Key Exchange Modes",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nA TLS 1.3 client must send the Pre-Shared Key Exchange Modes extension (psk_key_exchange_modes) if it sends the Pre-Shared Key extension. TLS 1.3 servers use the\n```# List of Key Exchange Modes"
          }
        ]
      },
      {
        "title": "3.4.2.11 Supported Versions",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe supported versions extension is sent in the ClientHello message to indicate which versions of TLS the client supports. A TLS 1.3 server shall be able to process this extension. When it is absent from the ClientHello message, the server shall use the version negotiation specified in TLS 1.2 and earlier."
          }
        ]
      },
      {
        "title": "3.4.2.12 Cookie",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe cookie extension allows the server to force the client to prove that it is reachable at its apparent network address and offload state information to the client. Servers that support TLS 1.3 may support the cookie extension in accordance with RFC 8446 [57]."
          }
        ]
      },
      {
        "title": "3.4.2.13 Certificate Signature Algorithms",
        "content": [
          {
            "text": "Applies to TLS versions: 1.2, 1.3\nThe Certificate Signature Algorithms extension (signature_algorithms_cert) indicates the signature algorithms that may be used in certificates. (When it is not present, algorithms in the Signature Algorithms extension apply to certificates as well.) TLS servers that support TLS 1.3 shall support this extension, and it should be supported for TLS 1.2."
          }
        ]
      },
      {
        "title": "3.4.2.14 Post-handshake Client Authentication",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe Post-handshake Client Authentication extension (post_handshake_auth) allows the server to request client authentication after the handshake is complete. TLS servers that support TLS 1.3 may support this extension."
          }
        ]
      }
    ]
  },
  {
    "title": "Signed Certificate Timestamps TLS extension",
    "subsections": [
      {
        "title": "3.4.3 Discouraged TLS Extensions",
        "content": [
          {
            "text": "The following extensions should not be used:"
          },
          {
            "text": "\nClient Certificate URL\nEarly Data Indication\n"
          },
          {
            "text": "The Raw Public Keys extension shall not be supported."
          },
          {
            "subsection": "3.4.3.1 Client Certificate URL",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2"
          },
          {
            "text": "The Client Certificate URL extension allows a client to send a URL pointing to a certificate rather than sending a certificate to the server during mutual authentication. This can be very useful for mutual authentication with constrained clients. However, this extension can be used for malicious purposes. The URL could belong to an innocent server on which the client would like to perform a denial of service attack, turning the TLS server into an attacker. A server that supports this extension also acts as a client while retrieving a certificate and, therefore, becomes subject to additional security concerns. For these reasons, the Client Certificate URL extension should not be supported. However, if an agency determines that the risks are minimal and this extension is needed for environments where clients are in constrained devices, the extension may be supported. If the client certificate URL extension is supported, the server shall be configured to mitigate the security concerns described above and in Section 11.3 of [29]."
          },
          {
            "subsection": "3.4.3.2 Early Data Indication",
            "text": []
          },
          {
            "text": "Applies to TLS version 1.3"
          },
          {
            "text": "The Early Data Indication extension (early_data) allows the client to send application data in the ClientHello message when pre-shared keys are used. This includes pre-shared keys that are established out-of-band as well as those used for session resumption. TLS does not protect this early data against replay attacks. Servers should not process early data received in the ClientHello message. If the server is configured to send the Early Data Indication extension, the server shall use methods of replay protection, such as those described in Section 8 of RFC 8446 [57]. See Section 3.6 for more information on early data (also called 0-RTT data)."
          },
          {
            "subsection": "3.4.3.3 Raw Public Keys",
            "text": []
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2, 1.3"
          },
          {
            "text": "The Raw Public Keys extension, described in RFC 7250 [71], provides an alternative to certificate-based authentication that only uses the information contained in the SubjectPublicKeyInfo field in an X.509 version 3 certificate. While this reduces the size of the public key structure and simplifies processing, it removes any assurances that a public key belongs to a particular entity. To provide authentication when using this extension, an out-of-band binding between a public key and entity must be used."
          }
        ]
      },
      {
        "title": "3.5 Client Authentication",
        "content": [
          {
            "text": "Where strong cryptographic client authentication is required, TLS servers may use the TLS protocol client authentication option to request a certificate from the client to cryptographically authenticate the client. For example, the Personal Identity Verification (PIV) Authentication certificate [47] (and the associated private key) provides a suitable option for\n```# Authentication of Federal Employees and Contractors"
          },
          {
            "text": "To ensure that agencies are positioned to take full advantage of the PIV Card, all TLS servers that perform client authentication shall implement certificate-based client authentication. The client authentication option requires the server to implement the X.509 path validation mechanism and a trust anchor store. Requirements for these mechanisms are specified in Sections 3.5.1 and 3.5.2, respectively. To ensure that cryptographic authentication actually results in strong authentication, client keys shall be capable of providing at least 112 bits of security. Section 3.5.3 describes mechanisms that can contribute, albeit indirectly, to enforcing this requirement. Section 3.5.4 describes the client's use of the server hints list."
          },
          {
            "text": "The TLS server shall be configurable to terminate the connection with a fatal \"handshake failure\" alert when a client certificate is requested and the client does not have a suitable certificate."
          }
        ]
      },
      {
        "title": "3.5.1 Path Validation",
        "content": [
          {
            "text": "The client certificate shall be validated in accordance with the certification path validation rules specified in Section 6 of [19]. In addition, the revocation status of each certificate in the certification path shall be validated using the Online Certificate Status Protocol (OCSP) or a certificate revocation list (CRL). OCSP checking shall be in compliance with RFC 6960 [63]. Revocation information shall be obtained as described in Section 3.2.2."
          },
          {
            "text": "The server shall be able to determine the certificate policies that the client certificate is trusted for by using the certification path validation rules specified in Section 6 of RFC 5280 [19]. Server and back-end applications may use this determination to accept or reject the certificate. Checking certificate policies assures the server that only client certificates that have been issued with acceptable assurance, in terms of CA and registration system and process security, are accepted."
          },
          {
            "text": "Not all commercial products may support the public-key certification path validation and certificate policy processing rules listed and cited above. When implementing client authentication, federal agencies shall either use the commercial products that meet these requirements or augment commercial products to meet these requirements."
          },
          {
            "text": "The server shall be able to provide the client certificate and the certificate policies for which the client certification path is valid to consuming applications in order to support access control decisions."
          }
        ]
      },
      {
        "title": "3.5.2 Trust Anchor Store",
        "content": [
          {
            "text": "Having an excessive number of trust anchors installed in the TLS application can expose the application to all the PKIs emanating from those trust anchors. The best way to minimize the exposure is to only include the trust anchors in the trust anchor store that are absolutely necessary for client public-key certificate authentication.# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "Trust Anchors Configuration",
        "content": [
          {
            "text": "The server shall be configured only with trust anchors that the system owner trusts and, of those, only the ones that are required to authenticate the clients in the case where the server supports client authentication in TLS. System administrators of a TLS server that supports certificate-based client authentication shall perform an analysis of the client certificate issuers and use that information to determine the minimum set of trust anchors required for the server. These trust anchors are typically a small subset of the trust anchors that may be included on the server by default. Also, note that this trust anchor store is distinct from the machine trust anchor store. Thus, the default set of trust anchors shall be examined to determine if any of them are required for client authentication. Some specific enterprise and/or PKI service trust anchors may need to be added."
          },
          {
            "text": "In the U.S. Federal Government environment, in most situations, the Federal Common Policy Root or the agency root (if cross-certified with the Federal Bridge Certification Authority or the Federal Common Policy Root) should be sufficient to build a certification path to the client certificates."
          }
        ]
      },
      {
        "title": "3.5.3 Checking the Client Key Size",
        "content": [
          {
            "text": "The only direct mechanism for a server to check whether the key size and algorithms presented in a client public-key certificate are acceptable is for the server to examine the public key and algorithm in the client's certificate. An indirect mechanism is to check that the certificate policies extension in the client public-key certificate indicates the minimum cryptographic strength of the signature and hashing algorithms used and for the server to perform certificate policy processing and checking. The server shall check the client key length if client authentication is performed and the server implementation provides a mechanism to do so. Federal agencies shall use the key size guidelines provided in SP 800-131A [10] to check the client key size."
          }
        ]
      },
      {
        "title": "3.5.4 Server Hints List",
        "content": [
          {
            "text": "Clients may use the list of trust anchors sent by the server in the CertificateRequest message to determine if the client's certification path terminates at one of these trust anchors. The list sent by the server is known as a \"hints list.\" When the server and client are in different PKI domains and the trust is established via direct cross-certification between the two PKI domains (i.e., the server PKI domain and the client PKI domain) or via transitive cross-certification (i.e., through cross-certifications among multiple PKI domains), the client may erroneously decide that its certificate will not be accepted by the server since the client's trust anchor is not sent in the hints list. To mitigate this failure, the server shall either: 1) maintain the trust anchors of the various PKIs whose subscribers are the potential clients for the server and include them in the hints list or 2) be configured to send an empty hints list so that the client can always provide a certificate it.# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "Trust Anchor Store",
        "content": [
          {
            "text": "The hints list shall be distinct from the server's trust anchor store. In other words, the server shall continue to only populate its trust anchor store with the trust anchor of the server's PKI domain and the domains it needs to trust directly for client authentication. Note that the distinction between the server hints list and the server's own trust store is as follows:"
          },
          {
            "text": "\nThe hints list is the list of trust anchors that a potential client might trust, and\nThe server's trust store is the list of trust anchors that the server explicitly trusts.\n"
          }
        ]
      },
      {
        "title": "3.6 Session Resumption and Early Data",
        "content": [
          {
            "text": "Previous TLS sessions can be resumed, allowing for a connection to be established using an abbreviated handshake. All versions of TLS offer session resumption, although the mechanism for performing resumption differs. A server may be configured to ignore requests to resume a session if the implementation allows it."
          },
          {
            "text": "Additional mechanisms have been developed for session resumption, such as the Stateless TLS Session Resumption extension [62]. While these guidelines neither encourage nor discourage the use of such mechanisms, it is important to understand the security impact if long-term or shared keys are compromised. If resumption is allowed, frequent key replacement and short lifetimes for resumption information are recommended, as applicable. See [67] for discussion on the security impacts of resumption mechanisms."
          },
          {
            "text": "TLS 1.3 allows the client to send data (known as 0-RTT data) in the first flight of a handshake. This practice may provide opportunities for attackers, such as replay attacks. The TLS 1.3 specification describes two mechanisms to mitigate threats introduced by 0-RTT data. One of these mechanisms is single-use tickets, which allows each session ticket to be used only once. It may be difficult to implement this mechanism in an environment with distributed servers as a session database must be shared between servers. ClientHello recording is a second mechanism that defends against replay attacks by recording a unique value derived from the ClientHello and rejecting duplicates. To limit the size of the list, the server can maintain a list only within a specified time window. In general, 0-RTT data should not be accepted by the server. If the server does allow 0-RTT data, then the server should use the single-use ticket mechanism in accordance with RFC 8446 (see Section 8 of [57])."
          }
        ]
      },
      {
        "title": "3.7 Compression Methods",
        "content": [
          {
            "text": "The use of compression may enable attackers to perform attacks using compression-based side channels (e.g., [60], [11]). To defend against these attacks, the null compression method shall be enabled, and all other compression methods shall be disabled."
          }
        ]
      },
      {
        "title": "3.8 Operational Considerations",
        "content": [
          {
            "text": "The sections above specify TLS-specific functionality. This functionality is necessary but is not sufficient to achieve security in an operational environment. Federal agencies shall ensure that TLS servers include appropriate network security protections as specified in other NIST guidelines, such as SP 800-53 [36].# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "The server shall operate on a secure operating system. Where the server relies on a FIPS 140 Level 1 cryptographic module, the software and private key shall be protected using the operating system identification, authentication, and access control mechanisms. In some highly sensitive applications, server private keys may require protection using a FIPS 140 Level 2 or higher hardware cryptographic module."
          },
          {
            "text": "The server and associated platform shall be kept up-to-date in terms of security patches. This is critical to various aspects of security."
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "\nCertificates containing Diffie-Hellman certificates should be signed with DSA; and\nCertificates containing ECDH public keys should be signed with ECDSA.\n"
      },
      {
        "content": "The client certificate profile is listed in Table 4-1. In the absence of an agency-specific client certificate profile, this profile should be used for client certificates. If a client has multiple certificates that meet the requirements of the TLS server, the TLS client (e.g., a browser) may ask the user to select from a list of certificates. The extended key usage (EKU) extension limits the operations for which the keys in a certificate may be used, and so the use of the EKU extension in client certificates may eliminate this request. If the EKU extension is included in client certificates, then the id-kp-client-auth key purpose OID should be included in the certificates to be used for TLS client authentication and should be omitted from any other certificates."
      },
      {
        "content": "Client certificates are also filtered by TLS clients on the basis of an ability to build a path to one of the trust anchors in the hints list sent by the server as described in Section 3.5.4."
      },
      {
        "title": "4.2.2 Obtaining Revocation Status Information for the Server Certificate",
        "content": [
          {
            "text": "The client shall perform revocation checking of the server certificate. Revocation information can be obtained by the client from one of the following locations:"
          },
          {
            "text": "\nOCSP response or responses in the server's CertificateStatus message ([29], [54]) (or Certificate message in TLS 1.3);\nCertificate Revocation List (CRL) or OCSP response in the client's local certificate store;\nOCSP response from a locally configured OCSP responder;\nOCSP response from the OCSP responder location identified in the OCSP field in the Authority Information Access extension in the server certificate; or\nCRL from the CRL Distribution Point extension in the server certificate.\n"
          },
          {
            "text": "When the server does not provide the revocation status, the local certificate store does not have the current or a cogent CRL or OCSP response, and the OCSP responder and the CRL distribution point are unavailable or inaccessible at the time of TLS session establishment, the client will either terminate the connection or accept a potentially revoked or compromised certificate. The decision to accept or reject a certificate in this situation should be made according to agency policy."
          }
        ]
      },
      {
        "title": "4.2.3 Client Public-Key Certificate Assurance",
        "content": [
          {
            "text": "The client public-key certificate may be trusted by the servers on the basis of the policies, procedures, and security controls used to issue the client public-key certificate as described in Section 3.5.1. For example, these guidelines recommend that the PIV Authentication certificate be the norm for authentication of federal employees and long-term contractors. PIV Authentication certificate policy is defined in the Federal PKI Common Policy Framework [31], and PIV-I Authentication certificate policy is defined in the X.509 Certificate Policy for the Federal Bridge Certification Authority [68]. Depending on the requirements of the server-side application, other certificate policies may also be acceptable. Guidance regarding other\n```# Certificate Policies"
          },
          {
            "text": "is outside the scope of these guidelines."
          }
        ]
      },
      {
        "title": "4.3 Cryptographic Support",
        "content": [
          {
            "subsection": "4.3.1 Cipher Suites",
            "text": []
          },
          {
            "text": "The acceptable cipher suites for a TLS client are the same as those for a TLS server. General-purpose cipher suites are listed in Section 3.3.1. Cipher suites appropriate for pre-shared key environments for TLS 1.2 and prior versions are listed in Appendix C. Applications that require RSA key transport as the key exchange method may use cipher suites listed in Appendix D during the deprecation period. When ephemeral keys are used to establish the master secret, each ephemeral key-pair (i.e., the server ephemeral key-pair and the client ephemeral key-pair) shall have at least 112 bits of security. The client should not be configured to use cipher suites other than those listed in Section 3.3.1, Appendix C, or Appendix D. To mitigate attacks against CBC mode, TLS implementations that support versions prior to TLS 1.3 shall use the bad_record_mac error to indicate a padding error. Implementations shall compute the MAC regardless of whether padding errors exist. TLS implementations should support constant-time decryption or near constant-time decryption. This does not apply to TLS 1.3 implementations as they do not support cipher suites that use CBC mode."
          },
          {
            "subsection": "4.3.2 Validated Cryptography",
            "text": []
          },
          {
            "text": "The client shall use validated cryptography as described for the server in Section 3.3.3. The validated random number generator shall be used to generate the random bytes (32 bytes in TLS 1.3; 28 bytes in prior TLS versions) of the client random value. The validated random number generator should be used to generate the 4-byte timestamp of the client random value for TLS versions prior to TLS 1.3."
          }
        ]
      },
      {
        "title": "4.4 TLS Extension Support",
        "content": [
          {
            "text": "In general, it is advised that clients only be configured to support extensions that are required for interoperability or enhance security. Extensions that are not needed should not be enabled."
          },
          {
            "subsection": "4.4.1 Mandatory TLS Extensions",
            "text": []
          },
          {
            "text": "The client shall be configured to use the following extensions:"
          },
          {
            "text": "\nRenegotiation Indication\nServer Name Indication\nExtended Master Secret\nSignature Algorithms\nCertificate Status Request\n"
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2"
          },
          {
            "text": "The Renegotiation Indication extension is required by these guidelines as described in Section 3.4.1.1. Clients shall perform the initial and subsequent renegotiations in accordance with RFC 5746 [59]."
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2, 1.3"
          },
          {
            "text": "The server name indication extension is described in Section 3.4.1.2. The client shall be capable of including this extension in a ClientHello message as described in RFC 6066 [29]."
          },
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "The Extended Master Secret extension",
        "content": [
          {
            "text": "The Extended Master Secret extension described in Section 3.4.1.3 prevents man-in-the-middle attacks by binding the master secret to a hashed log of the full handshake. The client shall support this extension."
          }
        ]
      },
      {
        "title": "4.4.1.4 Signature Algorithms",
        "content": [
          {
            "text": "Applies to TLS versions: 1.2, 1.3"
          },
          {
            "text": "The clients shall assert acceptable hashing and signature algorithm pairs in this extension in TLS 1.2 and TLS 1.3 ClientHello messages. The extension, its syntax, and processing rules are described in Sections 7.4.1.4.1, 7.4.4, 7.4.6 and 7.4.8 of RFC 5246 [25] and in Section 4.2.3 of RFC 8446 [57]. Note that the extension described in RFC 8446 updates the extension described in RFC 5246 by adding an additional signature scheme."
          }
        ]
      },
      {
        "title": "4.4.1.5 Certificate Status Request",
        "content": [
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2, 1.3"
          },
          {
            "text": "The client shall include the \"status_request\" extension in the ClientHello message."
          }
        ]
      },
      {
        "title": "4.4.2 Conditional TLS Extensions",
        "content": [
          {
            "text": "A TLS client supports the following TLS extensions under the circumstances described:"
          },
          {
            "text": "\nThe Fallback Signaling Cipher Suite Value (SCSV) shall be supported if the client supports versions of TLS prior to TLS 1.2 and does not support TLS 1.3.\nThe Supported Groups extension shall be supported if the client supports ephemeral ECDH cipher suites or if the client supports TLS 1.3.\nThe Key Share extension shall be supported if the client supports TLS 1.3.\nThe EC Point Format TLS extension shall be supported if the client supports EC cipher suite(s).\nThe Multiple Certificate Status extension should be enabled if the extension is supported by the client implementation.\nThe Trusted CA Indication extension should be supported by clients that run on memory-constrained devices where only a small number of CA root keys are stored.\nThe Encrypt-then-MAC extension shall be supported when CBC mode cipher suites are configured.\nThe Truncated HMAC extension may be supported by clients that run on constrained devices when variable-length padding is not supported and cipher suites that use CBC mode are supported.\nThe Pre-Shared Key extension may be supported by TLS 1.3 clients.\nThe Pre-Shared Key Exchange Modes extension shall be supported by TLS 1.3 clients that support the Pre-Shared Key extension.\nThe Supported Versions extension shall be supported by TLS 1.3 clients.\nThe Cookie extension shall be supported by TLS 1.3 clients.\nThe Certificate Signature Algorithms Extension shall be supported if the client supports TLS 1.3 and should be supported for TLS 1.2.\nThe Post-handshake Client Authentication extension may be supported if the client supports TLS 1.3.\n"
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": []
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "use. When CBC mode cipher suites are configured, clients shall support this extension as described in RFC 7366 [33]. The client shall include this extension in the ClientHello message whenever the ClientHello message includes CBC cipher suites."
      },
      {
        "title": "4.4.2.8 Truncated HMAC",
        "content": [
          {
            "text": "Applies to TLS versions: 1.0, 1.1, 1.2\nThe Truncated HMAC extension is described in Section 3.4.2.8. Clients running on constrained devices may support this extension. The Truncated HMAC extension shall not be used in conjunction with variable-length padding due to attacks described by Paterson et al. [53]. This extension is only applicable when cipher suites that use CBC modes are supported."
          }
        ]
      },
      {
        "title": "4.4.2.9 Pre-Shared Key",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe Pre-Shared Key extension (pre_shared_key) is used to indicate the identity of the pre-shared key to be used for PSK key establishment. In TLS 1.3, pre-shared keys may either be established out-of-band, as in TLS 1.2 and prior versions, or in a previous connection, in which case they are used for session resumption. Clients that support TLS 1.3 may be configured to use this extension in order to allow session resumption or to allow the use of pre-shared keys that are established out-of-band."
          }
        ]
      },
      {
        "title": "4.4.2.10 Pre-Shared Key Exchange Modes",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nA TLS 1.3 client must send the Pre-Shared Key Exchange Modes extension (psk_key_exchange_modes) if it sends the Pre-Shared Key extension. Otherwise, the server will abort the handshake. TLS clients that support TLS 1.3 and the Pre-Shared Key extension shall implement this extension."
          }
        ]
      },
      {
        "title": "4.4.2.11 Supported Versions",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe supported versions extension indicates which versions of TLS the client is able to negotiate. A TLS 1.3 client shall send this extension in the ClientHello message."
          }
        ]
      },
      {
        "title": "4.4.2.12 Cookie",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe cookie extension allows the server to force the client to prove that it is reachable at its apparent network address and offload state to the client. Clients that support TLS 1.3 shall support the cookie extension in accordance with RFC 8446 [57]."
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "title": "4.4.2.14 Post-handshake Client Authentication",
        "content": [
          {
            "text": "Applies to TLS version 1.3\nThe client sends the Post-handshake Client Authentication extension (post_handshake_auth) to indicate that it is willing to respond to client authentication requests after the handshake is complete. TLS clients that support TLS 1.3 may support this extension."
          }
        ]
      },
      {
        "title": "4.4.3 Discouraged TLS Extensions",
        "content": [
          {
            "text": "The following extensions should not be used:\n1. Client Certificate URL\n2. Early Data Indication"
          },
          {
            "text": "The Raw Public Key extension shall not be supported. The reasons for discouraging the use of these extensions can be found in Section 3.4.3."
          }
        ]
      },
      {
        "title": "4.5 Server Authentication",
        "content": [
          {
            "text": "The client shall be able to build the certification path for the server certificate presented in the TLS handshake with at least one of the trust anchors in the client trust store if an appropriate trust anchor is present in the store. The client may use all or a subset of the following resources to build the certification path: the local certificate store, certificates received from the server during the handshake, Lightweight Directory Access Protocol (LDAP), the resources declared in the CA Repository field of the Subject Information Access extension in various CA certificates, and the resources declared in the CA Issuers field of the Authority Information Access extension in various certificates."
          },
          {
            "subsection": "4.5.1 Path Validation",
            "text": []
          },
          {
            "text": "The client shall validate the server certificate in accordance with the certification path validation rules specified in Section 6 of [19]. The revocation status of each certificate in the certification path shall be checked using the Online Certificate Status Protocol (OCSP) or a certificate revocation list (CRL). OCSP checking shall be in compliance with [63]. Revocation information shall be obtained as described in Section 4.2.2."
          },
          {
            "text": "Not all clients support name constraint checking. Federal agencies should only procure clients that perform name constraint checking in order to obtain assurance that unauthorized certificates are properly rejected."
          },
          {
            "text": "The client shall terminate the TLS connection if path validation fails. Federal agencies shall only use clients that check that the DNS name or IP address (whichever is presented in the client TLS request) matches a DNS name or IP address contained in the server certificate. The client shall terminate the TLS connection if the name check fails."
          },
          {
            "subsection": "4.5.2 Trust Anchor Store",
            "text": []
          },
          {
            "text": "Having an excessive number of trust anchors installed in the TLS client can increase the chances for the client to be spoofed. As the number of trust anchors increase, the number of CAs that the client trusts increases, and the chances that one of these CAs or its registration system or process will be compromised to issue TLS server certificates also increases."
          },
          {
            "text": "Clients shall not overpopulate their trust stores with various CA certificates that can be verified via cross-certification. Direct trust of these certificates can expose the\n```# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "clients unduly to a",
        "content": [
          {
            "text": "variety of situations including, but not limited to, revocation or compromise of these trust anchors. Direct trust also increases the operational and security burden on the clients to promulgate the addition and deletion of trust anchors. Instead, the client shall rely on the server overpopulating or not providing the hints list to mitigate the client certificate selection and path-building problem as discussed in Section 3.5.4."
          }
        ]
      },
      {
        "title": "4.5.3 Checking the Server Key Size",
        "content": [
          {
            "text": "The only direct mechanism for a client to check if the key size presented in a server public certificate is acceptable is for the client to examine the server public key in the certificate. An indirect mechanism is to ensure that the server public-key certificate was issued under a policy that indicates the minimum cryptographic strength of the signature and hashing algorithms used. In some cases, this can be done by the client performing certificate policy processing and checking. However, since many TLS clients cannot be configured to accept or reject certificates based on the policies under which they were issued, this may require ensuring that the trust anchor store only contains trust anchors for CAs that issue certificates under acceptable policies. The client shall check the server public key length if the client implementation provides a mechanism to do so. The client shall also check the server public key length if the server uses ephemeral keys for the creation of the master secret and the client implementation provides a mechanism to do so. The length of each write key is determined by the negotiated cipher suite. Restrictions on the length of the shared session keys can be enforced by configuring the client to only support cipher suites that meet the key length requirements."
          }
        ]
      },
      {
        "title": "4.5.4 User Interface",
        "content": [
          {
            "text": "When the TLS client is a browser, the browser interface can be used to determine if a TLS session is in effect. The indication that a TLS session is in effect varies by browser. Examples of indicators include a padlock in the URL bar, the word \"secure\" preceding the URL, or a different color for the URL bar. Some clients, such as browsers, may allow further investigation of the server certificate and negotiated session parameters by clicking on the lock (or other indicator). Users should examine the interface for the presence of the indicator to ensure that the TLS session is in force and should also visually examine website URLs to ensure that the user intended to visit the indicated website. Users should be aware that URLs can appear to be legitimate but still not be valid. For example, the numeric \"1\" and the letter \"l\" appear quite similar or the same to the human eye. Client authentication keys may be located outside of the client (e.g., in PIV Cards). Users shall follow the relevant policies and procedures for protecting client authentication keys outside of the client."
          }
        ]
      },
      {
        "title": "4.6 Session Resumption and Early Data# Session Resumption Considerations and Server Recommendations",
        "content": [
          {
            "text": "Session resumption considerations and server recommendations were given in Section 3.6. There are no specific recommendations for clients regarding session resumption when using TLS 1.2, 1.1, or 1.0. Clients typically will not know if any anti-replay mechanisms are in place to prevent replay attacks on 0-RTT data in TLS 1.3. Therefore, clients using TLS 1.3 should not send 0-RTT data."
          },
          {
            "text": "RFC 7918 [39] describes a technique called False Start that allows a TLS 1.2 client to send early data. While this concept is similar to the 0-RTT data of TLS 1.3, there are differences that affect security. For example, an attacker may perform downgrade attacks, both of protocol versions and cipher suites, and obtain client data before the handshake is determined to be invalid. While RFC 7918 provides recommendations for improving security, it is safest to disable False Start unless there is a real need for it. TLS 1.2 clients shall not use False Start."
          }
        ]
      },
      {
        "title": "4.7 Compression Methods",
        "content": [
          {
            "text": "The client shall follow the same compression recommendations as the server, which are described in Section 3.7."
          }
        ]
      }
    ]
  }
]