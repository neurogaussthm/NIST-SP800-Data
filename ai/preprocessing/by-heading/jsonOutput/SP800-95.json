[
  {
    "title": "Executive Summary",
    "subsections": [
      {
        "content": "The advance of Web services technologies promises to have far-reaching effects on the Internet and enterprise networks. Web services based on the eXtensible Markup Language (XML), SOAP, and related open standards, and deployed in Service Oriented Architectures (SOA) allow data and applications to interact without human intervention through dynamic and ad hoc connections. Web services technology can be implemented in a wide variety of architectures, can co-exist with other technologies and software design approaches, and can be adopted in an evolutionary manner without requiring major transformations to legacy applications and databases."
      },
      {
        "content": "The security challenges presented by the Web services approach are formidable and unavoidable. Many of the features that make Web services attractive, including greater accessibility of data, dynamic application-to-application connections, and relative autonomy (lack of human intervention) are at odds with traditional security models and controls. The primary purpose of this publication is to inform people about securing Web services. Difficult issues and unsolved problems exist, such as protecting the following:"
      },
      {
        "content": "\nConfidentiality and integrity of data that is transmitted via Web services protocols in service-to-service transactions, including data that traverses intermediary services\nFunctional integrity of the Web services that requires the establishment of trust between services on a transaction-by-transaction basis\nAvailability in the face of denial of service attacks that exploit vulnerabilities unique to Web service technologies, especially targeting core services, such as discovery service, on which other services rely.\n"
      },
      {
        "content": "Perimeter-based network security technologies (e.g., firewalls) are inadequate to protect SOAs for the following reasons:"
      },
      {
        "content": "\nSOAs are dynamic and can seldom be fully constrained to the physical boundaries of a single network.\nSOAP is transmitted over HyperText Transfer Protocol (HTTP), which is allowed to flow without restriction through most firewalls.\n"
      },
      {
        "content": "Moreover, Transport Layer Security (TLS), which is used to authenticate and encrypt Web-based messages, is inadequate for protecting SOAP messages because it is designed to operate between two endpoints. TLS cannot accommodate Web services' inherent ability to forward messages to multiple other Web services simultaneously."
      },
      {
        "content": "The Web service processing model requires the ability to secure SOAP messages and XML documents as they are forwarded along potentially long and complex chains of consumer, provider, and intermediary services. The nature of Web services processing makes those services subject to unique attacks, as well as variations on familiar attacks targeting Web servers."
      },
      {
        "content": "Ensuring the security of Web services involves augmenting traditional security mechanisms with security frameworks based on the use of authentication, authorization, confidentiality, and integrity mechanisms. This# Security Mechanisms in Web Services"
      },
      {
        "content": "The document describes how to implement those security mechanisms in Web services. It also discusses how to make Web services and portal applications robust against the attacks to which they are subject. The following is a summary of security techniques for Web services:"
      },
      {
        "title": "Security Techniques",
        "content": [
          {
            "text": "\n\nConfidentiality of Web service messages using XML Encryption. This is a specification from the World Wide Web Consortium (W3C) and it provides a mechanism to encrypt XML documents.\n\n\nIntegrity of Web service messages using XML Signature. This is a specification produced jointly by the W3C and the Internet Engineering Task Force (IETF). The power of XML Signature is to selectively sign XML data.\n\n\nWeb service authentication and authorization using XML Signature, Security Assertion Markup Language (SAML) and eXtensible Access Control Markup Language (XACML) as proposed by the Organization for Advancement of Structured Information Standards (OASIS) group. SAML and XACML provide mechanisms for authentication and authorization in a Web services environment.\n\n\nWeb Services (WS)-Security. This specification, produced by OASIS, defines a set of SOAP header extensions for end-to-end SOAP messaging security. It supports message integrity and confidentiality by allowing communicating partners to exchange signed encrypted messages in a Web services environment.\n\n\nSecurity for Universal Description, Discovery and Integration (UDDI). Produced by OASIS, UDDI allows Web services to be easily located and subsequently invoked. Security for UDDI enables publishers, inquirers and subscribers to authenticate themselves and authorize the information published in the directory.\n\n"
          },
          {
            "text": "Confidentiality of Web service messages using XML Encryption. This is a specification from the World Wide Web Consortium (W3C) and it provides a mechanism to encrypt XML documents."
          },
          {
            "text": "Integrity of Web service messages using XML Signature. This is a specification produced jointly by the W3C and the Internet Engineering Task Force (IETF). The power of XML Signature is to selectively sign XML data."
          },
          {
            "text": "Web service authentication and authorization using XML Signature, Security Assertion Markup Language (SAML) and eXtensible Access Control Markup Language (XACML) as proposed by the Organization for Advancement of Structured Information Standards (OASIS) group. SAML and XACML provide mechanisms for authentication and authorization in a Web services environment."
          },
          {
            "text": "Web Services (WS)-Security. This specification, produced by OASIS, defines a set of SOAP header extensions for end-to-end SOAP messaging security. It supports message integrity and confidentiality by allowing communicating partners to exchange signed encrypted messages in a Web services environment."
          },
          {
            "text": "Security for Universal Description, Discovery and Integration (UDDI). Produced by OASIS, UDDI allows Web services to be easily located and subsequently invoked. Security for UDDI enables publishers, inquirers and subscribers to authenticate themselves and authorize the information published in the directory."
          }
        ]
      },
      {
        "title": "Challenges",
        "content": [
          {
            "text": "While many of the Web services challenges have been met with existing standards, there are a number of challenges that standards organizations are addressing\u2014particularly in the area of Web services discovery and reliability. The Web Services Interoperability Organization (WS-I) acknowledges that there are many challenges that have yet to be addressed. Some examples of these challenges are:"
          },
          {
            "text": "\nRepudiation of transactions\nSecure issuance of credentials\nExploitation of covert channels\nCompromised services\nSpread of malware, such as viruses and Trojan horses via SOAP messages\nDenial of service attacks\nIncorrect service implementations.\n"
          },
          {
            "text": "The following sections discuss several Web services security challenges in detail, including Web services discovery, quality of service and quality of protection, and protection from denial of service attacks."
          }
        ]
      },
      {
        "title": "Discovery",
        "content": [
          {
            "text": "In Web services discovery, participants identify and compose Web Services Description Language (WSDL) specific services based on definitions in a UDDI registry. Due to the potentially large number of service candidates in the registry, performance rankings for algorithms used to search, match and compose services can vary from case to case.# Current Page Raw OCR Text"
          },
          {
            "text": "As the set of available Web services expands, advanced tools to help identify services that match a customer's functional and security requirements become increasingly important. It is important for service providers to describe their service capabilities and service requesters to describe their requirements in an unambiguous and semantic way. Techniques that take advantage of Semantic Web technologies can improve discovery capabilities. The Ontology Web Language for Services (OWL-S) is an example, but more work needs to be done to integrate such technologies into Web service registries."
          },
          {
            "text": "In OWL-S, the service requester can describe the service requirements using terms from a semantic model. Reasoning techniques are then used to find the semantic similarity between the service description and the request to find a set of matching services automatically. While both UDDI and OWL-S can be used to specify the security properties of a Web service, such support is not inherent in the discovery system. However, W3C's Semantic Annotations for WSDL is a step in the direction of merging Web services discovery technology with semantic Web technology. Even with semantic Web services discovery, true automation will require that the requester be able to determine explicitly the security requirements of the provider in addition to its functionality."
          }
        ]
      },
      {
        "title": "End to End Quality of Service and Protection",
        "content": [
          {
            "text": "Most Web services deployed do not provide guarantees for Quality of Service (QoS) or Quality of Protection (QoP) under the scenario of attacks. QoS is important in defining the expected level of performance a particular Web service will have. By prioritizing traffic, overall performance of the system can be improved. The WS-Reliability and WS-ReliableMessaging standards provide some level of QoS. Both standards support guaranteed message delivery and message ordering. The standard considers other QoS parameters, such as rate of failure or average latency, as out of scope because they are usually dealt with by lower layer protocols. For Web services to truly support QoS, existing QoS support must be extended so that the packets corresponding to individual Web service messages can be routed accordingly to achieve predictable performance."
          }
        ]
      },
      {
        "title": "Overlap between OASIS and W3C Standards",
        "content": [
          {
            "text": "Similar and overlapping Web services security standards that are being developed by multiple standard bodies are a source of confusion to system developers. Moreover, these standards are constantly being updated, resulting in interoperability problems. There is a need for more formal specification and testing of standards."
          }
        ]
      },
      {
        "title": "Methodologies for Web Services Security",
        "content": [
          {
            "text": "The main emphasis of Web services security today is on basic infrastructure (e.g., protocols and languages). As technology matures and Web services become widely adopted, there will be a need for methodologies and recommended practices for security to help developers identify assets to be protected, analyze possible attacks, and decide protection levels and tradeoffs."
          }
        ]
      },
      {
        "title": "Availability and Protection from Denial of Service Attacks",
        "content": [
          {
            "text": "Availability enables a Web services application to detect a Denial of Service (DoS) attack, to continue operation as long as possible, and then to gracefully recover and resume.# Operations After a DoS Attack"
          },
          {
            "text": "There is a need for techniques to replicate data and services to ensure continuity of operations in the event of a fault. There is also a need for management and monitoring solutions to provide service performance and availability monitoring to meet certain service level objectives."
          }
        ]
      },
      {
        "title": "Security Actions to Consider",
        "content": [
          {
            "text": "The items below are possible actions that organizations should consider; some of the items may not apply to all organizations. In particular, it is necessary to balance these actions against budget requirements and the potential risks an organization's Web services may face."
          },
          {
            "text": "\n\nReplicate Data and Services to Improve Availability. Since Web services are susceptible to DoS attacks, it is important to replicate data and applications in a robust manner. Replication and redundancy can ensure access to critical data in the event of a fault. It will also enable the system to react in a coordinated way to deal with disruptions.\n\n\nUse Logging of Transactions to Improve Non-repudiation and Accountability. Non-repudiation and accountability require logging mechanisms involved in the entire Web service transaction. As of early 2007, there are few implemented logging standards that can be used across an entire SOA. In particular, the level of logging provided by various UDDI registries, identity providers, and individual Web services varies greatly. Where the provided information is not sufficient to maintain accountability and non-repudiation, it may be necessary to introduce additional software or services into the SOA to support these security requirements.\n\n\nUse Threat Modeling and Secure Software Design Techniques to Protect from Attacks. The objective of secure software design techniques is to ensure that the design and implementation of Web services software does not contain defects that can be exploited. Threat modeling and risk analysis techniques should be used to protect the Web services application from attacks. Used effectively, threat modeling can find security strengths and weaknesses, discover vulnerabilities and provide feedback into the security life cycle of the application. Software security testing should include security-oriented code reviews and penetration testing. By using threat modeling and secure software design techniques, Web services can be implemented to withstand a variety of attacks.\n\n\nUse Performance Analysis and Simulation Techniques for End to End Quality of Service and Quality of Protection. Queuing networks and simulation techniques have long played critical roles in designing, developing and managing complex information systems. Similar techniques can be used for quality assured and highly available Web services. In addition to QoS of a single service, end-to-end QoS is critical for most composite services. For example, enterprise systems with several business partners must complete business processes in a timely manner to meet real time market conditions. The dynamic and compositional nature of Web services makes end-to-end QoS management a major challenge for service-oriented distributed systems.\n\n\nDigitally Sign UDDI Entries to Verify the Author of Registered Entries. UDDI# CURRENT_PAGE_RAW_OCR_TEXT\n\n"
          },
          {
            "text": "Replicate Data and Services to Improve Availability. Since Web services are susceptible to DoS attacks, it is important to replicate data and applications in a robust manner. Replication and redundancy can ensure access to critical data in the event of a fault. It will also enable the system to react in a coordinated way to deal with disruptions."
          },
          {
            "text": "Use Logging of Transactions to Improve Non-repudiation and Accountability. Non-repudiation and accountability require logging mechanisms involved in the entire Web service transaction. As of early 2007, there are few implemented logging standards that can be used across an entire SOA. In particular, the level of logging provided by various UDDI registries, identity providers, and individual Web services varies greatly. Where the provided information is not sufficient to maintain accountability and non-repudiation, it may be necessary to introduce additional software or services into the SOA to support these security requirements."
          },
          {
            "text": "Use Threat Modeling and Secure Software Design Techniques to Protect from Attacks. The objective of secure software design techniques is to ensure that the design and implementation of Web services software does not contain defects that can be exploited. Threat modeling and risk analysis techniques should be used to protect the Web services application from attacks. Used effectively, threat modeling can find security strengths and weaknesses, discover vulnerabilities and provide feedback into the security life cycle of the application. Software security testing should include security-oriented code reviews and penetration testing. By using threat modeling and secure software design techniques, Web services can be implemented to withstand a variety of attacks."
          },
          {
            "text": "Use Performance Analysis and Simulation Techniques for End to End Quality of Service and Quality of Protection. Queuing networks and simulation techniques have long played critical roles in designing, developing and managing complex information systems. Similar techniques can be used for quality assured and highly available Web services. In addition to QoS of a single service, end-to-end QoS is critical for most composite services. For example, enterprise systems with several business partners must complete business processes in a timely manner to meet real time market conditions. The dynamic and compositional nature of Web services makes end-to-end QoS management a major challenge for service-oriented distributed systems."
          },
          {
            "text": "Digitally Sign UDDI Entries to Verify the Author of Registered Entries. UDDI# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "Registries Openly",
        "content": [
          {
            "text": "Provide details about the purpose of a Web service as well as how to access it. Web services use UDDI registries to discover and dynamically bind to Web services at run time. Should an attacker compromise a UDDI entry, it would be possible for requesters to bind to a malicious provider. Therefore, it is important to digitally sign UDDI entries so as to verify the publisher of these entries."
          },
          {
            "text": "\nEnhance Existing Security Mechanisms and Infrastructure. Web services rely on many existing Internet protocols and often coexist with other network applications on an organization's network. As such, many Web service security standards, tools, and techniques require that traditional security mechanisms, such as firewalls, intrusion detection systems (IDS), and secured operating systems, are in effect before implementation or deployment of Web services applications.\n"
          }
        ]
      },
      {
        "title": "Conclusions",
        "content": [
          {
            "text": "Web services are important drivers for the software industry. The primary goal of service-oriented computing is to make a collection of software services accessible via standardized protocols whose functionality can be automatically discovered and integrated into applications. While several standards bodies (such as W3C and OASIS) are laying the foundation for Web services, several research problems must be solved to make secure Web services a reality. Service description, automatic service discovery as well as QoS are some of the important problems that need to be solved. Web services are increasingly becoming an integral part of organizational information technology (IT) infrastructures\u2014even though there are still unmet security challenges. To this end, the development and deployment of secure Web services is essential to many organizations' IT infrastructures. However, Web service security standards do not provide all of the required properties to develop robust, secure, and reliable Web services. To adequately support the needs of the Web services based applications, effective risk management and appropriate deployment of alternate countermeasures are essential. Defense-in-depth through security engineering, secure software development, and risk management can provide much of the robustness and reliability required by these applications."
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "organizations on a voluntary basis and is not subject to copyright. Attribution is desired and requested. Nothing in this document should be taken to contradict standards and guidelines made mandatory and binding on Federal agencies by the Secretary of Commerce under statutory authority, nor should these guidelines be interpreted as altering or superseding the existing authorities of the Secretary of Commerce, Director of the OMB, or any other Federal official."
      },
      {
        "title": "1.2 Purpose and Scope",
        "content": [
          {
            "text": "This publication seeks to assist organizations in understanding the challenges in integrating information security practices into SOA design and development based on Web services. This publication also provides practical, real-world guidance on current and emerging standards applicable to Web services, as well as background information on the most common security threats to SOAs based on Web services. This document presents information that is largely independent of particular hardware platforms, operating systems, and applications. Supplementary security mechanisms (i.e., perimeter security appliances) are considered outside the scope of this publication. Interfaces between Web services components and supplementary controls are noted as such throughout this document on a case-by-case basis."
          }
        ]
      },
      {
        "title": "1.3 Audience",
        "content": [
          {
            "text": "The document, while technical in nature, provides the background information to help readers understand the topics that are discussed. The intended audience for this document includes the following:"
          },
          {
            "text": "\nSystem and software architects and engineers trained in designing, implementing, testing, or evaluating Web services\nSoftware developers experienced in XML, C#, Visual Basic for .NET (VB.NET), C, or Java for Web services\nSecurity architects, engineers, analysts, and secure software developers/integrators\nResearchers who are furthering and extending service interfaces and conceptual designs.\n"
          },
          {
            "text": "This document assumes that readers have some minimal Web services expertise. Because of the constantly changing nature of Web services threats and vulnerabilities, readers are expected to take advantage of other resources (including those listed in this document) for more current and detailed information. The practices recommended in this document are designed to help mitigate the risks associated with Web services. They build on and assume the implementation of practices described in other NIST guidelines listed in Appendix F."
          }
        ]
      },
      {
        "title": "1.4 Document Structure",
        "content": [
          {
            "text": "The remainder of this document is organized into five major sections. Section 2 provides background to Web services and portals and their relationship to security. Section 3 discusses the many relevant Web service security functions and related technology. Section 4 discusses Web portals, the human user's entry point into the SOA based on Web services. Section 5 discusses the challenges associated with secure Web service-enabling of legacy applications. Finally, Section 6 discusses\n```# Secure Implementation Tools and Technologies"
          },
          {
            "text": "The document also contains several appendices. Appendix A offers discussion of several attacks commonly leveraged against Web services and SOAs. Appendix B provides an overview of Electronic Business eXtensible Markup Language (ebXML), a Web services protocol suite developed by the United Nations Centre for Trade Facilitation and Electronic Business (UN/CEFACT). Appendices C and D contain a glossary and acronym list, respectively. Appendices E and F list print resources and online tools and resources that may be useful references for gaining a better understanding of Web services and SOAs, security concepts and methodologies, and the general relationship between them."
          }
        ]
      },
      {
        "title": "2. Background to Web Services and Their Relationship to Security",
        "content": [
          {
            "text": "Organizations are adopting SOA to support their mission critical applications. SOA is a computing paradigm emphasizing dynamic service discovery, composition, and interoperability. Web services are a technology that can be used to implement SOA and are increasingly becoming the SOA implementation of choice. For a SOA to truly meet its goals, applications must be secure and reliable. A large number of security standards have been proposed for Web services by a number of different organizations. This section provides an overview of Web services, the associated security challenges, and the standards available for securing Web services."
          },
          {
            "subsection": "2.1 Introducing Web Services",
            "text": []
          },
          {
            "text": "There are various aspects of Web services: messaging, discovery, portals, roles, and coordination. This section uses an example Web service to illustrate the use of each aspect in developing a SOA application. The example consists of a loan processing Web service which relies on two other Web services: an interest rate service and a credit check service."
          },
          {
            "text": "To define the format of each SOAP message, W3C developed the WSDL. WSDL interfaces are created by each Web service and can be shared to allow dynamic binding. Through dynamic binding, Web services can communicate with newly added services without any additional programming or configuration changes. To facilitate the discovery of Web services, a discovery standard called UDDI was developed. UDDI allows Web services to search for one another dynamically. When combined with WSDL, Web services can easily discover and use new services at run-time without human intervention."
          },
          {
            "text": "In the bank loan example, the loan service needs to discover the rate service before using it. The rate Web service is listed in the UDDI registry as a Web service capable of providing information about the bank's rates. When the loan service is initiated, the UDDI registry is accessed and searched for a Web service capable of providing the bank's rate information. The UDDI registry returned the rate service's Uniform Resource Identifier (URI) and details about how to access the rate service, which are derived from the WSDL interface."
          },
          {
            "text": "Figure 2-1 illustrates the discovery process."
          },
          {
            "text": "\nThe rate service's WSDL is mapped into a UDDI registry entry\nThe loan service queries the UDDI registry for a Web service capable of# Providing Interest Rate Information\n"
          }
        ]
      }
    ]
  },
  {
    "title": "2.1.4.2 Provider Web Services",
    "subsections": [
      {
        "content": "The provider accepts a request from the requester and provides a response based on the input. The provider is responsible for setting the standards for authentication, authorization, encryption, and non-repudiation. The provider communicates its requirements through the extensibility of WSDL, a discovery service, or both. Some requirements may be negotiable, allowing requesters and providers to dynamically determine how to proceed, but at this time WSDL and discovery services do not provide a standard way for negotiating such requirements. Standards are under development to address this shortcoming. In the loan service example, both the rate service and credit service are providers. When the rate provider receives a request, it performs the necessary calculations to determine the current rates offered by the bank. Once the request has been processed, the provider sends an appropriate response containing the bank's current rate information. When the credit provider receives a request, it returns a response containing the creditworthiness of the customer."
      },
      {
        "content": "Web services provide a SOA in which applications are loosely coupled, allowing Web services to dynamically bind to other Web services at run-time depending on the needs of the user or application. Web services publish their functions to the UDDI registry so that other Web services can find needed functionality. This enables the reuse of applications, particularly legacy applications; by developing a Web services interface that is accessible via SOA, organizations can conserve resources used for costly migrations between platforms. Often, this results in a chain of Web service invocations and an associated performance penalty. This penalty, however, is often offset by the savings in development time and consistency of results associated with re-using components. In a network with low latency and high availability, this performance penalty can be minimized to the point that it is not noticeable."
      }
    ]
  },
  {
    "title": "2.1.4.3 Intermediary Web Services",
    "subsections": [
      {
        "content": "An intermediary service is a Web service that is invoked in a chain. The most common example of an intermediary Web service is an XML gateway that receives requests from requesters, performs security checks against the requests, and then forwards the requests to an internal Web service provider. From the perspective of the requester, there is only a single provider, but in reality there are two. There can be any number of intermediary services involved within a single Web service transaction. Figure 2-4 illustrates how multiple intermediary services may interact with other services.# CURRENT_PAGE_RAW_OCR_TEXT"
      },
      {
        "content": "In the loan example, both the credit and rate services are intermediaries. As shown in Figure 2-5, the credit service receives a request from the loan service and then forwards the request on to the credit bureau services for each of the major credit bureaus. This allows the user's credit information to be checked by multiple sources while allowing the loan service to use a single service. As part of its calculations, the rate service may wish to make a request to a Web service that provides the current Treasury bonds rate."
      },
      {
        "title": "2.1.5 Coordination: Orchestration and Choreography",
        "content": [
          {
            "text": "When multiple requesters, providers, and intermediaries are participating in a Web service transaction, it may be necessary to coordinate them. There are two different types of mechanisms for coordinating Web services: Web services orchestration and Web services choreography. Web services orchestration is performed within an organization's SOA and concerns the use of existing Web services to create another Web service. Web services choreography is performed among multiple organizations' SOAs and describes relationships between Web services so that Web services understand how to interact with one another to perform a process. Figure 2-6 illustrates how no single Web service is in control in a choreography."
          },
          {
            "text": "When invoking a Web service orchestration, the encapsulating Web service uses an orchestration engine to define which Web services will be invoked. In contrast, when invoking a Web service choreography, the sequence of Web services is more dynamic, and the decisions are made by the relationships defined between individual Web services rather than by a unifying orchestration engine. Figure 2-7 illustrates how the Web service orchestration is controlled by a single Web service."
          },
          {
            "text": "Using the loan service example, the credit service could be implemented as a choreography. Each Web service in the transaction is not necessarily operated by the same organization as the credit service. Each Web service, the credit service and the individual credit bureau service, would enumerate the rules and expectations for interacting with one another. The credit service would dynamically look up the credit bureau service, process the information that is needed to interact with it, and then initiate a choreography among the services."
          },
          {
            "text": "The rate service may be implemented as an orchestration, as all of the involved Web services would be internal to the rate service's organization. To fully calculate the interest rates that the loan service will use, the rate service consists of a chain of SOAP requests and responses passed from one internal Web service to another to gather the necessary information to respond with accurate rates. Each transaction within the orchestration is controlled by the rate service, so that requests and responses occur in the proper order and failures do not propagate throughout the transaction. Once complete, the rate service returns the result of the orchestration to the loan service, as shown in Figure 2-8."
          }
        ]
      },
      {
        "title": "2.2 Elements of Security",
        "content": [
          {
            "text": "Because a Web service relies on some of the same underlying HTTP and Web-based architecture as# Web Services Security"
          },
          {
            "text": "Common web applications, it is susceptible to similar threats and vulnerabilities. Web services security is based on several important concepts, including:"
          }
        ]
      },
      {
        "title": "Identification and Authentication",
        "content": [
          {
            "text": "Verifying the identity of a user, process, or device, often as a prerequisite to allowing access to resources in an information system."
          }
        ]
      },
      {
        "title": "Authorization",
        "content": [
          {
            "text": "The permission to use a computer resource, granted, directly or indirectly, by an application or system owner."
          }
        ]
      },
      {
        "title": "Integrity",
        "content": [
          {
            "text": "The property that data has not been altered in an unauthorized manner while in storage, during processing, or in transit."
          }
        ]
      },
      {
        "title": "Non-repudiation",
        "content": [
          {
            "text": "Assurance that the sender of information is provided with proof of delivery and the recipient is provided with proof of the sender's identity, so neither can later deny having processed the information."
          }
        ]
      },
      {
        "title": "Confidentiality",
        "content": [
          {
            "text": "Preserving authorized restrictions on information access and disclosure, including means for protecting personal privacy and proprietary information."
          }
        ]
      },
      {
        "title": "Privacy",
        "content": [
          {
            "text": "Restricting access to subscriber or relying party information in accordance with Federal law and organization policy."
          }
        ]
      },
      {
        "title": "2.3 Web Services Security Dimensions",
        "content": [
          {
            "text": "The web services security dimensions have been defined as: secure messaging, resource protection, negotiation of contracts, trust management, and security properties. These dimensions encompass the elements of security (discussed in Section 2.2) in a web services environment. Each dimension is essential to the development of secure applications using web services, but each dimension affects a different layer of the web service. This section describes each security dimension and provides an overview of what technologies are available, what is on the horizon, and what remains to be done."
          },
          {
            "subsection": "2.3.1 Secure Messaging",
            "text": []
          },
          {
            "text": "Web services rely on the Internet for communication. Because SOAP was not designed with security in mind, SOAP messages can be viewed or modified by attackers as the messages traverse the Internet. There are several options available for securing web service messages:"
          },
          {
            "text": "\nHTTP over SSL/TLS (HTTPS). Because SOAP messages are transmitted using HTTP, it is trivial to modify a web service to support HTTPS.\nXML Encryption and XML Signature. These XML security standards developed by W3C allow XML content to be signed and encrypted. Because all SOAP messages are written in XML, web service developers can sign or encrypt any portion of the SOAP message using these standards, but there is no standard mechanism for informing recipients how these standards were applied to the message.\nWS-Security. WS-Security was developed to provide SOAP extensions that define mechanisms for using XML Encryption and XML Signature to secure SOAP messages.\n"
          },
          {
            "text": "Each secure messaging option has its own strengths and weaknesses. They are discussed in more depth in Section 3.6."
          },
          {
            "subsection": "2.3.2 Protecting Resources",
            "text": []
          },
          {
            "text": "When resources are made publicly available, it is important to ensure that they are adequately protected. Usually, web services are intended to be accessible only to authorized users.# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "Requesters and Access Control",
        "content": [
          {
            "text": "Requesters, requiring mechanisms for access control. To perform access control, Web services need to identify and authenticate one another. Several different methods are available, including transport layer authentication, token authentication via the WS-Security specification using SAML assertions or other tokens, and the SOAP authentication header. Authorizations for Web services are often done through custom implementations, but the XACML is an OASIS standard available for performing authorization decisions, eliminating the time and cost associated with developing and testing a custom solution."
          },
          {
            "text": "In the loan service example, the rate service is a provider service. When the rate provider receives a request, it needs to validate the identity of the requester and the supplied input. By validating the requester's identity, the rate service can check with organizational policies to determine whether the requester is authorized to access rate information. By validating the input, the rate service can ensure that the request includes valid and acceptable parameters. If the requester submits unexpected content, it is reason to suspect that an attacker may be probing the Web service for vulnerabilities. Once the request has been processed, the provider sends an appropriate response containing the bank's current rate information."
          }
        ]
      },
      {
        "title": "Challenges in Protecting Resources",
        "content": [
          {
            "text": "The challenges faced in protecting resources go beyond simply providing access control mechanisms. The goal of an attacker may not be simply accessing the Web service. Rather, the attacker's objectives may include disrupting the service, acting as a man-in-the-middle, eavesdropping on the service, impersonating the service, or even using weaknesses in the service's implementation to control the host platform. Typical threats to Web services are discussed in more detail in Section 2.6."
          }
        ]
      },
      {
        "title": "Negotiation of Contracts",
        "content": [
          {
            "text": "One of the primary goals of SOA is to facilitate the automation of business processes by allowing services to automatically discover one another and immediately take advantage of the functionality offered. To facilitate business transactions, Web services need to be able to create, enforce, and abide by contracts between organizations. For example, a credit service relies on another organization's Web services. A contract between the two organizations ensures that all Web services will operate as expected and that the information passed between organizations will be properly secured. In many situations, these contracts are negotiated and agreed upon by the organizations before implementation can begin. Ideally, Web services would be able to negotiate and agree upon such contracts electronically, immediately after discovery during runtime to take advantage of new functionality immediately. Negotiating such contracts electronically opens up a number of potential legal ramifications for the organizations involved. Therefore, in lieu of this ideal, many SOAs rely on an implicit contract offered by the WSDL interface of a Web service and expect it to operate as advertised."
          },
          {
            "text": "The ebXML suite of standards provides tools for negotiating business processes and contracts using Web services. However, ebXML was developed as a replacement for Electronic Data.# Interchange (EDI)"
          },
          {
            "text": "and, as such, is often considered too complex to use for regular Web services. Because ebXML Web services rely on SOAP, portions of the ebXML standards may be individually adopted for small organizations. Usually, the WSDL interface or registry entry of an individual Web service can be considered an implicit contract between the services, but there are no standards that support the enforcement of implicit contracts. Research in the realm of Web service choreography will aid in enforcing implicit contracts."
          },
          {
            "text": "Web services may have specific QoS or QoP requirements. For example, a credit service may require that certain information be encrypted and signed using WS-Security, while the requester service may require a guaranteed response through reliable messaging. The ebXML suite of standards provides support for security properties in contracts, but it does not fully support automatic security properties negotiation. The WS-Choreography standard provides some support for negotiating security requirements. A promising area of research is Semantic Web services. Using Semantic Web technologies, Web services can intelligently search for other Web services with specific properties, including security properties. In addition, the Semantic Web Services Architecture (SWSA) developed by the Defense Advanced Research Projects Agency (DARPA) Agent Markup Language (DAML) Program specifically addresses negotiating contracts among Semantic Web services and the associated architectural requirements:"
          },
          {
            "text": "\nNegotiation protocol. Web services require a protocol for negotiating properties of the transaction. Research is underway to develop negotiation protocols using Semantic Web technologies.\nNegotiation service. To facilitate negotiation, a provider that allows other services to offload negotiation can serve as a core service within the SOA.\nMediation service. Services involved in negotiation may need to have disputes over various properties of the service contract mediated by a trusted core service.\nAuditing service. The resulting contract between services will need to be stored for non-repudiation services by a trusted core service.\nNegotiation-enabled Web service. Individual Web services will be able to inform one another that they support negotiation through the discovery process.\n"
          },
          {
            "text": "While these architectural requirements are specific to SWSA, these functions can prove useful when developing any SOA capable of supporting negotiation."
          }
        ]
      },
      {
        "title": "2.3.4 Trust Relationships",
        "content": [
          {
            "text": "Web services standards are inherently flexible and have allowed several architecture models to evolve: a brokered trust model, a pairwise trust model, a federated trust model, and a perimeter defense model. While these models use the term trust, they are limited to being able to trust the identity of the service. Being able to establish a Web service's identity does not mean that the service itself is inherently trustworthy. There is always the possibility that a Web service has entered an erroneous state or has been compromised.# Trust in Web Services"
          },
          {
            "text": "In their 1996 paper, McKnight and Chervany defined trust as \"the extent to which one believes (and feels confident in believing) that the other person is trustworthy in the situation.\" Based on this definition, authenticating the identity of a Web service may not be sufficient when determining whether or not to trust a remote Web service. When trust relationships span multiple organizations, the requirements for individual Web services will vary. For this reason, regardless of whether the provider is a trusted entity in terms of its identity, the requester should not presume that it will not send erroneous or potentially malicious content in a response to the requester's request. Similarly, because providers listen (like a server) for requests from various requesters, they should not presume that erroneous or malicious content will not be sent in place of valid requests."
          },
          {
            "text": "Nevertheless, identifying and authenticating Web services is an essential step in establishing trust. Each trust model provides different benefits and drawbacks, allowing trust to be supported in a wide variety of environments. With this caveat on the definition of trust in a Web services environment, the remainder of this document uses the term trust when discussing authentication to maintain consistency with standards and research papers."
          }
        ]
      },
      {
        "title": "Trust Models",
        "content": [
          {
            "subsection": "Pairwise Trust Model",
            "text": []
          },
          {
            "text": "The pairwise trust model is the simplest of all trust architectures, but the least scalable. In the pairwise architecture, each Web service is provided\u2014at configuration\u2014the security information of all other Web services that will be interacted with so that those transactions and Web services can be trusted. This approach eliminates the need for developers to coordinate with other entities, but it creates an unscalable and non-uniform security architecture because adding a new Web service would require adding new information to all existing services it could interact with. When the SOA becomes large and dynamic, adding a new service can become time and resource intensive."
          },
          {
            "subsection": "Brokered Trust Model",
            "text": []
          },
          {
            "text": "In the brokered trust model, an independent third party acts as a trusted third party (TTP) for the Web service. The requester and provider interface with the third party for a variety of security services. Unlike the pairwise trust model, Web services using the brokered trust model need to be designed with the broker's interface in mind, so that identity information can be properly retrieved by the Web service. This approach eases the distribution of identity information between Web services; each Web service will only need to verify the identity of the trust broker rather than the identity of all Web services in the SOA."
          },
          {
            "subsection": "Federated Trust Model",
            "text": []
          },
          {
            "text": "A federated trust model allows Web services from different organizations to seamlessly interact with one another via various federation mechanisms. It builds upon both the brokered and pairwise trust models by allowing organizations to use their own central trust brokers while relying on pairwise trust or brokered trust between organizations. Each organization that wishes to federate must do so following complex business procedures and protocols, but the end result allows the Web services of each organization to interact with few or no changes to their original configuration."
          },
          {
            "subsection": "Perimeter Defense Strategy",
            "text": []
          },
          {
            "text": "Another commonly used Web service architecture is the perimeter defense strategy. Devices known as XML gateways are placed between providers and requesters. An XML gateway acts as...# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "a proxy for the",
        "content": [
          {
            "text": "Web service by performing the security-related functionality in its place. Although XML gateways are useful tools in an organization's security strategy, they are not a panacea. Should an attacker bypass the XML gateway, all internal Web services will be vulnerable to attack. Internal Web services must be designed, developed, and configured securely."
          }
        ]
      },
      {
        "title": "2.3.5 Requirements for Secure Software",
        "content": [
          {
            "text": "All software, including Web services, needs to satisfy requirements for performance, cost, usability, and security. Examples of possible requirements for secure software are predictability, correctness, and availability."
          }
        ]
      },
      {
        "title": "2.4 Meeting the Requirements for Securing Web Services",
        "content": [
          {
            "text": "Several organizations, including OASIS, W3C, the Liberty Alliance, and various members of industry have put together numerous security standards and techniques for securing Web services. For the most part, these standards and techniques all complement or extend one another, but there are some conflicting or competing standards. This section provides an overview of the various standards and how they can be used to meet security requirements and protect against threats to Web services. Section 3 discusses the most widely accepted standards, technologies, and techniques in detail."
          },
          {
            "subsection": "2.4.1 Secure Web Service Standards Stack",
            "text": []
          },
          {
            "text": "The open standards communities that created Web services developed a number of security standards for Web services. Figure 2-9 illustrates a notional reference model for Web services security standards. This reference model maps the different standards to the different functional layers of a typical Web service implementation. These layers are modeled after the OSI Reference Model but are not intended to be interpreted as strictly hierarchical."
          },
          {
            "text": "Standards at the network, transport and XML security layers are used to secure messages as they are transmitted over the network. The security standards IPsec, SSL/TLS (Secure Sockets Layer/Transport Layer Security), XML Encryption and XML Signature each operate on SOAP messages at a different level."
          },
          {
            "text": "Above the XML Security layer, there are two types of standards: standards built on top of SOAP and standalone standards. Message security standards WS-Security and WS-SecureConversation define how to use XML Signature, XML Encryption and credentials to secure SOAP at the message layer while reliable messaging standards define the protocols and constructs necessary to ensure that messages will be received. The access control standards are not unique to Web services; XACML can define the access policy for any system and SAML can be used to define assertions in any environment. The policy layer's WS-Policy defines a grammar to communicate the policy requirements of a Web service. These standards are described in more detail in Section 3."
          },
          {
            "text": "Security management specifications define other Web services to manage credentials such as PKI certificates within the SOA. Identity management standards take advantage of access control standards, policy standards and SOAP standards to offer services for distributing and managing user identities and.# Credentials within the SOA"
          }
        ]
      },
      {
        "title": "2.4.2 Relationship of Web Service Security Requirements to Standards",
        "content": [
          {
            "text": "Table 2-1 shows which security requirements are satisfied by the various specifications and standards."
          },
          {
            "text": "Each SOA security dimension has one or more security requirements. Each requirement may have any number of standards that support it. For example, both SSL/TLS and WS-Security provide confidentiality, integrity and authentication support for the messaging dimension, while the accountability requirement of the resource protection dimension does not have any supporting standards."
          }
        ]
      },
      {
        "title": "2.5 Core Services",
        "content": [
          {
            "text": "The notion of core services has yet to be completely defined. Traditionally, these are services that can be used by any of the Web services in an organization's SOA. Two examples are the Open Grid Services Architecture (OGSA), developed for the Globus Grid, and the Department of Defense's (DoD's) Net-Centric Enterprise Services (NCES), developed for the Global Information Grid. Both OGSA and NCES provide a set of services available throughout an organization that are commonly used or essential to most Web services, such as discovery, authentication, and authorization. OGSA provides a comprehensive list of what can be offered as core services: service management, service communication, policy services, and security services. Most SOAs use these same categories of core services but may provide differing names:"
          },
          {
            "text": "\nService management services: assist in managing a SOA by providing mechanisms to install, maintain, monitor, and troubleshoot Web services.\nService communication services: provide support for various types of communications models between services: queued messaging, publish-subscribe event notification, and distributed logging services.\nPolicy services: provide a framework for creating, administering, and managing policies for the infrastructure; these policies cover security, resource allocation, and performance.\nSecurity services: provide support for different security models, mechanisms, protocols, and technologies that extend core Web services security protocols to support activities such as authorization, authentication, trust policy enforcement, and credential transformation.\n"
          },
          {
            "text": "In the loan service example, shown in Figure 2-10, core services are used to offload identification, authentication, and authorization, among other capabilities, so that developers of the loan, rate, and credit services do not have to implement their own security functionality. For instance, when the loan service makes a request, it first retrieves an identifier from the identification service associated with the subject. When the rate service receives the request, it uses the authentication service to validate both the subject and the loan service. If authentication is successful, the rate service queries the authorization service to ensure the loan service and subject are authorized to receive policy information."
          },
          {
            "text": "By offloading some of the processing to these core services, the implementation of the loan, rate and credit services is simplified when compared to a single Web service with similar functionalities.# Functionality"
          },
          {
            "text": "This further improves security by lowering the number of possible defects that could exist in the individual services, but it introduces a slight performance penalty associated with the communication with the core services. Core services may also introduce a single point of failure in the SOA."
          }
        ]
      },
      {
        "title": "2.6 Threats Facing Web Services",
        "content": [
          {
            "text": "Security decisions must always be made with an understanding of the threats facing the system to be secured. While there are a wealth of security standards and technologies available for securing Web services, they may not be adequate or necessary for a particular organization or an individual service. For that reason, it is important to understand the threats that face Web services so that organizations can determine which threats their Web services must be secured against. According to WS-I, the top threats facing Web services are:"
          },
          {
            "text": "\nMessage alteration. An attacker inserts, removes or modifies information within a message to deceive the receiver.\nLoss of confidentiality. Information within a message is disclosed to an unauthorized individual.\nFalsified messages. Fictitious messages that an attacker intends the receiver to believe are sent from a valid sender.\nMan in the middle. A third party sits between the sender and provider and forwards messages such that the two participants are unaware, allowing the attacker to view and modify all messages.\nPrincipal spoofing. An attacker constructs and sends a message with credentials such that it appears to be from a different, authorized principal.\nForged claims. An attacker constructs a message with false credentials that appear valid to the receiver.\nReplay of message. An attacker resends a previously sent message.\nReplay of message parts. An attacker includes portions of one or more previously sent messages in a new message.\nDenial of service. An attacker causes the system to expend resources disproportionately such that valid requests cannot be met.\n"
          },
          {
            "text": "The importance of these threats may vary depending on an organization's needs and purpose. In some instances, messages need not be kept confidential, so loss of confidentiality is not a concern. Similarly, organizations may offer a Web service to the public. For example, a Web service that provides information about the current weather forecast need not be concerned if a request is from a falsified sender. Regardless, it is important to understand these threats and what technologies are available to mitigate them."
          },
          {
            "text": "The following Web services and HTTP standards can protect against many of these threats:"
          },
          {
            "text": "\nW3C XML Encryption. Used by WS-Security to encrypt messages and provide confidentiality of part or all of a SOAP message.\nW3C XML Signature. Used by WS-Security to digitally sign messages and provide message integrity and sender authentication.\nWS-Security Tokens. Allows messages to include credentials to aid receivers in determining.# CURRENT_PAGE_RAW_OCR_TEXT\n"
          }
        ]
      },
      {
        "title": "whether or not the message sender is authorized to perform the requested action.",
        "content": [
          {
            "subsection": "Supported token types include:",
            "text": []
          },
          {
            "text": "\nUsername/password. The most common credentials in Web applications\nOASIS SAML Assertion. Asserts that the sender has been authenticated and/or supply attributes associated with the sender\nIETF X.509 certificate. Coupled with XML Signature, a receiver can verify that the CA issued the certificate used to sign the SOAP message\nISO Rights Expression Language. Used to provide public key information, attributes of those keys, as well as information about the sender's license\nIETF Kerberos token. Allows Web services to exist in a Kerberos domain.\nW3C WS-Addressing IDs. Allows the message sender to supply a unique identifier for the message\nIETF SSL/TLS. Secures the HTTP protocol over which SOAP messages are sent and received\nSSL/TLS with client authentication. Requires both the sender and receiver to authenticate with one another before securing the HTTP protocol\nIETF HTTP authentication. Allows usernames, passwords (via HTTP Basic) or password digests (via HTTP Digest) to be sent as part of the HTTP header.\n"
          },
          {
            "text": "These technologies, along with other technologies that support them, are discussed in-depth in Section 3."
          },
          {
            "text": "Table 2-2 illustrates which standards provide protection against these threats. As the table shows, SSL/TLS and WS-Security, through XML Encryption and XML Signature, provide similar protections against threats; Section 3.6 discusses SSL/TLS, WS-Security and WS-SecureConversation and the trade-offs associated with each technology."
          },
          {
            "text": "As shown in Table 2-2, there are no standards that protect against DoS attacks. While the OASIS WS-Reliability standard and the work produced by the OASIS WS-RX technical committee address message reliability, ensuring the availability of Web services remains a hard problem. Many of the availability techniques used by high volume Web applications, such as load balancing, clustering and replication, can be used to aid in preserving availability."
          },
          {
            "text": "Web services also face threats associated with all software: defects in a Web service implementation may lead to exploitable vulnerabilities. Web services, like Web applications, are remotely accessible, so attackers can take advantage of the Web service's availability to probe it for potential exploits. As with any remotely accessible service, it is important that Web services be implemented securely and that traditional network security tools and techniques be used to limit access to the Web service to only those networks and systems that should have legitimate access. Some aspects of secure Web service development are discussed in Section 6."
          }
        ]
      }
    ]
  },
  {
    "title": "Supported by an Organization's IDS",
    "subsections": [
      {
        "content": "While certain types of firewalls support filtering HTTP content, and some can support filtering SOAP, filtering all XML messages with traditional firewalls can prove to be expensive and reduce the throughput of the firewall. Due to the SOA paradigm, which allows for messages to be passed via intermediaries rather than simply by point-to-point communication, SSL/TLS is inadequate for a number of possible SOAP transactions because SSL/TLS is designed to secure transactions between individual Web services\u2014and will not protect against an intermediary performing a man-in-the-middle attack."
      },
      {
        "content": "The SOAP specification explains that SOAP was designed with the intent of leaving security for an extension:"
      },
      {
        "content": "\"Two major design goals for SOAP are simplicity and extensibility. SOAP attempts to meet these goals by omitting, from the messaging framework, features that are often found in distributed systems. Such features include but are not limited to 'reliability', 'security', 'correlation', 'routing', and 'Message Exchange Patterns' (MEPs). While it is expected that many features will be defined, this specification provides specifics only for two MEPs. Other features are left to be defined as extensions by other specifications.\""
      },
      {
        "content": "WS-I has produced a document describing SOAP's security challenges, which include the following:"
      },
      {
        "content": "\nSOAP does not perform any authentication between SOAP endpoints or intermediaries, so there is no way to verify the origin of a SOAP message.\nSOAP does not provide a mechanism for ensuring data integrity or confidentiality either at rest or during transit.\nSOAP does not provide a mechanism for detecting resubmitted SOAP messages.\n"
      },
      {
        "content": "The WSDL description of a Web service is usually automatically provided by the Web service framework used (e.g., appending ?wsdl to the Web service URI will return its WSDL) and may openly reveal the entire API of the Web service\u2014even parts of the Web service that may have been disabled or that are used solely for debugging purposes. Exposing too much information about a Web service through its WSDL descriptor may provide information about the design and security requirements of the Web service."
      },
      {
        "content": "UDDI registries openly provide details about the purpose of a Web service as well as how to access it. In particular, UDDI provides tModels (described in Section 3.9.1) as \"a way to mark a description with information that designates how it behaves, what conventions it follows, and what specifications or standards the service complies with.\" Attackers may use this information to find potential flaws in the Web service. For example, the UDDI entry may show that the Web service uses a vulnerable specification. Any information in excess of that required to bind to the Web service may benefit an attacker."
      },
      {
        "content": "Additionally, Web services use UDDI registries to discover and dynamically bind to Web services at run time. Because the UDDI specifications did not address digitally signing entries until version 3.0.2.\n```# Web Services' Interfaces with Network/Infrastructure Security Architectures"
      },
      {
        "content": "(released as an OASIS standard in 2005), many UDDI registries do not provide a robust mechanism for verifying the authenticity of registry entries. This may allow malicious Web services to be added to the registry and used by other Web services."
      }
    ]
  },
  {
    "title": "When Dealing with Libraries",
    "subsections": [
      {
        "content": "When dealing with libraries that perform authentication, authorization, and other security functions that are not supported by the base framework. For example, XACML and SAML provide a flexible and platform-independent framework for distributed authorization. To properly implement XACML and SAML support may require overriding the framework's authentication mechanism at various points, which could lead to potential vulnerabilities in the Web service application. Supporting SAML or WS-Security in place of native authentication mechanisms may require the Web service to bypass authentication services provided by the framework, leading to potentially vulnerable code. Until frameworks provide native support for platform-independent authentication and authorization mechanisms, there will always be the potential for custom-developed code to be inadequately robust and lead to potential security breaches."
      },
      {
        "title": "2.9 Summary",
        "content": [
          {
            "text": "This section introduced the underlying concepts of Web services and the security challenges they face. The challenges have five dimensions:"
          },
          {
            "text": "\n\nSecure messaging. Ensure that SOAP messages traversing networks are not viewed or modified by attackers. WS-Security and WS-SecureConversation provide the confidentiality and integrity services necessary.\n\n\nProtection of resources. Ensure that individual Web services are adequately protected through appropriate identification, authentication, and access control mechanisms. There is a plethora of standards available for controlling access to Web services.\n\n\nNegotiation of contracts. To truly meet the goals of SOA and automate business processes, Web services should be capable of negotiating business contracts as well as the QoP and QoS of the associated transactions. While this remains a hard problem, standards are emerging to address portions of contract negotiation\u2014particularly in the QoP and QoS field.\n\n\nTrust management. One of the underlying principles of security is ensuring that all entities involved in a transaction trust one another. To this end, Web services support a variety of trust models that can be used to enable Web services to trust the identities of entities within the SOA.\n\n\nSecurity properties. All Web service security processes, tools, and techniques rely on secure implementation. A vulnerable Web service may allow attackers to bypass many\u2014if not all\u2014of the security mechanisms discussed in Section 3.\n\n"
          },
          {
            "text": "Secure messaging. Ensure that SOAP messages traversing networks are not viewed or modified by attackers. WS-Security and WS-SecureConversation provide the confidentiality and integrity services necessary."
          },
          {
            "text": "Protection of resources. Ensure that individual Web services are adequately protected through appropriate identification, authentication, and access control mechanisms. There is a plethora of standards available for controlling access to Web services."
          },
          {
            "text": "Negotiation of contracts. To truly meet the goals of SOA and automate business processes, Web services should be capable of negotiating business contracts as well as the QoP and QoS of the associated transactions. While this remains a hard problem, standards are emerging to address portions of contract negotiation\u2014particularly in the QoP and QoS field."
          },
          {
            "text": "Trust management. One of the underlying principles of security is ensuring that all entities involved in a transaction trust one another. To this end, Web services support a variety of trust models that can be used to enable Web services to trust the identities of entities within the SOA."
          },
          {
            "text": "Security properties. All Web service security processes, tools, and techniques rely on secure implementation. A vulnerable Web service may allow attackers to bypass many\u2014if not all\u2014of the security mechanisms discussed in Section 3."
          },
          {
            "text": "To adequately meet the challenges posed by each security dimension, the Web services community has developed a large number of standards. Each standard meets a different security challenge faced by Web services. WS-Security and SSL/TLS, for example, address the secure messaging domain, while WS-Federation and Liberty Identity Federation Framework (IDFF) address the trust management domain."
          },
          {
            "text": "Some security domains, such as messaging and trust management, are addressed by competing or overlapping standards, while others, such as the security properties domain, require further research within the community to fully address the challenges faced. Some standards address relevant security.\n```# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "properties. For example, WS-Reliability and WS-ReliableMessaging provide some QoS functionality, allowing guaranteed message passing even if the network is under attack. More standards and technology are necessary to provide full support for all of the necessary security properties. When determining which Web services standards and technologies to adopt, it is important to be aware of the threats facing an organization's Web services and prioritize them to ensure that resources are distributed appropriately for the Web services being secured."
          }
        ]
      },
      {
        "title": "3. Web Service Security Functions and Related Technologies",
        "content": [
          {
            "text": "Web service security standards, functions, and technologies continue to evolve at a rapid pace, driven by changes in the types of software attacks, community stakeholders, and Web services policy decision makers. This section describes several current and emerging standards, initiatives, and techniques aimed at improving the security of Web services. Many of the concepts used in securing Web applications are useful for understanding the security of Web services. Several resources on the subject of Web application security are provided in Appendix F for further reference."
          },
          {
            "subsection": "3.1 Service-to-Service Authentication",
            "text": []
          },
          {
            "text": "Authentication is required to limit access to resources, to identify participants in transactions, and to create seamless personalization of information based on identity. A means of sharing the fact that authentication has been performed successfully is necessary to support single sign-on, allowing users to authenticate with one system and use other services and applications within a SOA."
          },
          {
            "text": "Service-to-service authentication can be performed using a variety of methods, from HTTP-based token authentication to SSL/TLS-certificate based authentication, or by passing tokens along with the SOAP request. The HTTP and SSL/TLS-based methods are performed below the SOAP message layer and are transparent to the Web services involved, while SOAP-based token protocols require interaction between Web services."
          },
          {
            "text": "Token-based Web services authentication is usually performed using the OASIS WS-Security standard, which supports tokens based on a variety of authentication standards: usernames, X.509 PKI certificates, Kerberos tickets, or SAML assertions (SAML is discussed in-depth in Section 3.5.3). WS-Security libraries are available for most of the widely used Java and .NET Web services development platforms."
          },
          {
            "text": "When a service provider attempts to access a remote Web service on behalf of a user, it should send an authentication token within a WS-Security message. These tokens convey that the initiating entity (e.g., a user or requester) has been authenticated and provide information about the entity, such as the authentication mechanism, time, and possibly subject attributes that may be applicable. Often, these tokens take the form of a SAML assertion."
          },
          {
            "text": "For authenticating Web services between organizations using identity federation, the Liberty Alliance developed Liberty ID-WSF, which supports service-to-service authentication based on pairwise trust and federated identity. Federated authentication can also be performed using the WS-Trust and WS-Federation specifications developed to support WS-Security. Web# Service Authentication Using SAML and WS-Security"
          },
          {
            "text": "Service authentication using SAML and WS-Security is described in the following section. Identity federation technologies are discussed in-depth in Section 3.2."
          }
        ]
      }
    ]
  },
  {
    "title": "3.1.3 Security Concerns of WS-Security",
    "subsections": [
      {
        "content": "There are several concerns prevalent in a WS-Security compliant Web service. Many of these concerns are not specific to WS-Security and apply to message integrity and confidentiality mechanisms in general. WS-Security can be susceptible to replay attacks. An attacker may be able to reuse a WS-Security packet that is recorded. To mitigate this problem, timestamps, sequence numbers, and expirations should be sent signed within the WS-Security message. The receiving endpoint should then check to make sure that the message received has not been replayed."
      },
      {
        "content": "WS-Security provides support for tokens that can be sent in the WS-Security header of a SOAP message. Without proper safeguards, these security tokens can be substituted. It is important when using WS-Security tokens to sign the appropriate portions of the message. WS-Security headers that are signed by the sender can be used to detect alterations."
      },
      {
        "content": "Credential management may be a concern with WS-Security. PKI is most commonly deployed using X.509 certificates. PKI is used in e-commerce for performing SSL/TLS transactions over the World.```markdown"
      }
    ]
  },
  {
    "title": "Wide Web",
    "subsections": [
      {
        "content": "In many security architectures, user credentials are presented in the form of X.509 certificates. To this end, XML protocols and Web services security protocols have been developed to work with PKIs and X.509 in particular. XML Encryption can use a PKI for encrypting XML messages while XML Signature relies on a PKI for digitally signing XML content using algorithms similar to those defined in FIPS 186-2. As such, Web services innately support working within a PKI. Management of X.509 certificates and other credentials may or may not be provided by the SOA. While SOAP-compliant services exist to interact with a PKI (e.g., XKMS), most installed PKIs use older non-XML-based protocols which require certificate management to take place out-of-band from XML-based communication."
      },
      {
        "content": "Most WS-Security, SAML, and XML Security libraries do not perform full certificate validation by default. All certificate libraries will validate to make sure that the certificate was signed by a trusted Certificate Authority (CA). Most certificate libraries are not configured\u2014and may not adequately support\u2014checking the certificate against the CA's Certificate Revocation List (CRL) or the Online Certificate Status Protocol (OCSP), the two main standards for detecting whether or not a certificate has been revoked. To support the more advanced features of PKI certificate management, either additional libraries or appropriate versions of the Web services framework should be used. For example, newer versions of Java (1.5+) support OCSP, and Microsoft's Windows XP and Windows Server 2003 support OCSP for .NET-based Web services. For some applications, they may need to interact explicitly with the CRL or OCSP responder through some API to fully use PKI certificate management. Some PKI libraries, however, will perform CRL or OCSP checking automatically when validating digital signatures. The use of CRLs, OCSP, and PKI authentication is described in more detail in FIPS 196, NIST SP 800-32 and NIST SP 800-25."
      },
      {
        "title": "3.2 Identity Management",
        "content": [
          {
            "text": "Identity management for SOA encompasses the full range of identity-related events, information, and documents by which an entity's identity is verified, identity documents and credentials are issued to the entity, and entity identities are authenticated at point of entry into the SOA. In the SOA, an entity's identity forms the basis for both authorization and trust."
          },
          {
            "text": "An Identity Management System (IDMS), such as that pictured in Figure 3-1, is responsible for verifying the identities of entities, registering them, and issuing them digital identifiers. In accordance with\n```# Homeland Security Presidential Directive (HSPD) 12"
          }
        ]
      },
      {
        "title": "Subject: Policy for a Common Identification Standard for Federal Employees and Contractors",
        "content": [
          {
            "text": "NIST Federal Information Processing Standard (FIPS) 201-1, Personal Identity Verification of Federal Employees and Contractor, describes a number of requirements that must be satisfied before a human entity may be registered in a Federal IDMS, including a National Agency Check and Inquiries (NACI) background check. Non-government organizations may have different rules for registration. For example, users who wish to gain access to many e-commerce sites often need to provide only a valid email address and a credit card number."
          },
          {
            "text": "Once an entity has been issued a digital identifier, that identifier can be used within that organization to associate other information with the entity, such as role and authorization attributes. The identifier may also become part of the digital credential that authorizes the entity to access different resources in the SOA."
          },
          {
            "text": "Once registered, an entity must provide a portion of its credentials sufficient to authenticate that entity's identity. Again, different organizations have different policies for what constitutes sufficient authentication credentials. Many e-commerce sites require the entity to supply a username and password; other organizations may require the entity to submit an X.509 certificate."
          },
          {
            "text": "After the entity's identity has been authenticated, the policy decision point (PDP) of the system or resource to which it desires access must determine whether the now-authenticated entity is also authorized to access the resource. To perform authorization, the PDP relies on privilege management and attribute management. Privilege management enforces the policies that govern entity access. The policy decision to allow or deny access may be based on a single entity attribute such as the entity's role, or it may require a combination of fine-grained attributes such as the physical location of the entity, its currently active role in the system, and its clearance level. The attribute management system uses the entity's digital identifier (issued by the IDMS) to locate and retrieve those of the entity's attributes that are required by the privilege management policy."
          },
          {
            "subsection": "3.2.1 Identity Management Architectures",
            "text": []
          },
          {
            "text": "There are three major identity architectures available for use in Web services:"
          },
          {
            "text": "\n\nIsolated identity management. Isolated identity management is the architecture used by most Web applications on the Internet. In isolated identity management, service providers act both as a credential provider and identity provider. This simplifies management for a single service and negates the need for a TTP to handle either the credentials or providers. The drawback for an isolated identity management system is that every service must know the credentials and identifiers for all authorized requesters. In a large SOA, administering each provider may become unmanageable.\n\n\nFederated identity management. In identity federation, a group of providers agrees to recognize user identifiers from one another. Each service provider acts as a credential and identity provider for a subset of requesters. By issuing assertions (e.g., SAML authentication and attribute assertions), a# Service Provider and Identity Management\n\n"
          },
          {
            "text": "Isolated identity management. Isolated identity management is the architecture used by most Web applications on the Internet. In isolated identity management, service providers act both as a credential provider and identity provider. This simplifies management for a single service and negates the need for a TTP to handle either the credentials or providers. The drawback for an isolated identity management system is that every service must know the credentials and identifiers for all authorized requesters. In a large SOA, administering each provider may become unmanageable."
          },
          {
            "text": "Federated identity management. In identity federation, a group of providers agrees to recognize user identifiers from one another. Each service provider acts as a credential and identity provider for a subset of requesters. By issuing assertions (e.g., SAML authentication and attribute assertions), a# Service Provider and Identity Management"
          },
          {
            "text": "A service provider can supply other providers with the necessary information about the requester without requiring the requester to authenticate a second time. This simplifies identity and credential management for the SOA as a whole, but requires individual services to be aware of and trust assertions from one another. In a single enterprise-wide SOA, it may not be difficult for providers to trust one another, but they may be less willing to trust assertions when the SOA includes providers from different organizations. A requester in the SOA may make a request to a provider and supply an arbitrary assertion to gain access. In identity federation, it is important to develop organizational policies appropriate for the types of data that traverse the SOA."
          }
        ]
      },
      {
        "title": "Centralized Identity Management",
        "content": [
          {
            "text": "In centralized identity management, providers rely on a single TTP to provide credentials and identifiers to requesters. Centralized identity management is similar to federated identity management in that the identity and credential providers supply assertions directly to service providers, allowing requesters access without authenticating a second time. In this architecture, individual service providers need only be aware of the identity provider. In a cross-organizational SOA, organizations may be willing to trust another organization's identity providers more than individual services. A major drawback of the centralized identity management architecture is that the identity providers may act as a single point of failure. Should all of an organization's identity providers suffer a DoS, it will not be possible for providers to accept any requests."
          },
          {
            "text": "When developing a new SOA or updating an existing SOA, it is important to consider the size of the SOA and the organization's priorities. One or more of these architectures may not be suitable for SOAs of a certain size or may violate organizational policies."
          }
        ]
      },
      {
        "title": "Laws of Identity",
        "content": [
          {
            "text": "In May 2005, Kim Cameron, Identity and Access Architect at Microsoft, authored The Laws of Identity based on his research into the requirements for a unified identity metasystem, a system of identity systems that exposes a unified interface for disparate underlying identity technologies. Organizations that follow these laws when developing or deploying an identity management architecture will be able to better support cross-organizational collaboration. The seven laws are as follows:"
          },
          {
            "text": "\nUser Control and Consent. Identity systems must not reveal identifying information without the user's consent.\nMinimal Disclosure for a Constrained Use. Identity systems must disclose the least amount of identifying information while simultaneously limiting its use as much as possible.\nJustifiable Parties. Identity systems must disclose identifying information only to parties having a justifiable need to know it.\nDirected Identity. An identity system must support both omni-directional and uni-directional identifiers. An omni-directional identifier can be shared with any third party while a uni-directional identifier can only be used between two parties.\n\nPluralism of Operators and Technologies. An identity system must support multiple identity systems and technologies.# Technologies and Multiple Identity Providers\n\n\nHuman Integration. The identity system must define the human user as a component of the distributed system.\n\nConsistent Experience Across Contexts. The identity system must provide users with a consistent experience while enabling support for different technologies and providers.\n"
          },
          {
            "text": "Pluralism of Operators and Technologies. An identity system must support multiple identity systems and technologies.# Technologies and Multiple Identity Providers"
          },
          {
            "text": "Human Integration. The identity system must define the human user as a component of the distributed system."
          },
          {
            "text": "Each of the major identity architectures discussed in Section 3.2.1 can be configured to follow these laws. By harnessing these laws, identity architectures can securely and adequately share identifying information amongst themselves so that large organizations or multiple organizations with differing policies and identity management architectures can better support a SOA."
          }
        ]
      }
    ]
  },
  {
    "title": "Configurations",
    "subsections": [
      {
        "content": "with some being explicit Web services while others are implicitly supplied. Should an organization choose to implement its own identity management architecture, it should determine which of these services are necessary and implement them accordingly."
      },
      {
        "title": "3.3 Establishing Trust between Services",
        "content": [
          {
            "text": "For SAML or WS-Security to be useful on a large scale, trust relationships need to be established between remote Web services. A signed SAML assertion or WS-Security message is of no use if the receiver of the assertion cannot guarantee that the information asserted is trustworthy."
          },
          {
            "text": "In the original SAML specification, only direct trust relationships are discussed\u2014these are referred to as pairwise circles of trust. By contrast, SAML v2.0 provides two additional trust models for SAML: brokered trust and community trust."
          },
          {
            "text": "Pairwise trust circles are the tightest and most direct form of trust relationship. Each entity that is authorized to communicate with another must share its key information. In a pairwise trust circle, if a SAML assertion can be verified, it is from an authorized entity. One major drawback of pairwise trust is that each entity must have a copy of the public key from every other entity with which it communicates, making the system inherently unscalable."
          },
          {
            "text": "Brokered trust models are an extension of the pairwise trust model. When two services communicate that do not know each other's keys, a TTP is used to exchange the key information for them. This scales better than the pairwise trust circle because adding a new service provider involves simply exchanging its key information with the TTP. The Web service providers have to trust that the TTP has not been compromised. This differs from the pairwise model in which each service provider is independently responsible for trust."
          },
          {
            "text": "Another difficulty with the brokered trust model is that there may be a situation where the two services can communicate with the TTP but should not communicate with each other. In the pairwise model, entities that should not communicate with one another would simply not have the appropriate cryptographic keys to do so, preventing any messages from being passed. In the brokered trust model, each entity can communicate with the TTP and thus with other entities. Either the TTP or the individual entities must know who should and should not communicate with one another."
          },
          {
            "text": "The community trust model relies on an external PKI for establishing trust. This trust model assumes that the PKI interfaces are implemented correctly and that none of the certificate authorities have been compromised. This model provides simplicity similar to that of the pairwise trust model and scalability superior to the brokered trust model. If the remote entity's key can be retrieved through the PKI interface, a trusted authority has signed its key and it is safe to communicate with it. There must be a mechanism in place preventing two entities from communicating against policy even if they can retrieve each other's keys. This could be done either through PKI or the individual entities. Adding a new service is as simple as adding its key to the PKI."
          },
          {
            "text": "Signed SAML assertions have the same security shortcomings as any technology.\n```# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "that uses public key cryptography: the private key must not be compromised. The best way to protect against this situation is to keep keys secured and generate new keys on a regular basis. Once an attacker has compromised an entity's private key, that entity can be impersonated."
          },
          {
            "text": "Whether Web services need to trust one another within a single organization or across multiple organizational boundaries, trust federation frameworks provide support for all of the aforementioned trust models. Section 3.3.2 discusses the various frameworks available for federation of trust."
          }
        ]
      },
      {
        "title": "3.3.1 Federation of Trust",
        "content": [
          {
            "text": "Trust in distributed computing environments is usually verified using PKI certificates signed by a certificate authority or by passing custom tokens generated by a TTP, as is done in a Kerberos environment. Traditionally, these trust mechanisms have worked well within a single organization. Once information sharing crosses organizational boundaries, entities communicating with one another do not necessarily have the same source of trust. Before the advent of Web services, information sharing across organizational boundaries traditionally was handled by using a proxy that bridges the boundary or by cross-signing certificates."
          },
          {
            "text": "In a SOA, Web services from multiple organizations should be able trust one another without requiring extensive restructuring of the trust environment. To this end, trust federation frameworks can be configured to use an organization's pre-existing authentication mechanisms. Liberty Alliance provides both Web application and Web service federation using SAML to perform the trust brokering. WS-Federation allows different security realms to federate by defining trust brokers, who will validate security tokens used between Web services using WS-Trust."
          },
          {
            "text": "The following subsections provide additional information on the trust frameworks identified above. It must be noted, however, that these frameworks continue to evolve. Thus, the material provided is meant to offer a current snapshot of the features they offer as of this guide's date of publication."
          }
        ]
      },
      {
        "title": "3.3.2 Trust Federation Frameworks",
        "content": [
          {
            "text": "The following subsections provide additional details of the Liberty Alliance and WS-Trust frameworks. These standards provide similar features and functionality using different techniques and have been designed with different goals in mind. Determining which framework is best for a particular organization depends greatly on what is deployed and on the organization's architectural goals."
          },
          {
            "subsection": "3.3.2.1 Liberty Alliance",
            "text": []
          },
          {
            "text": "The Liberty Alliance aims to develop a standards-based identity federation framework suitable for businesses and governments. Liberty Alliance-compliant products can interact with one another within a federated environment, allowing organizations to federate identities without having to agree on the same providers."
          },
          {
            "text": "The Liberty Alliance has defined the Identity Web Services Framework, which defines how Web services can interact on a user's behalf through appropriate use of SAML by defining several services, including the following:# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "Discovery Services",
        "content": [
          {
            "text": "\nAllow Web services to dynamically look up the identity providers of a particular principal\n"
          }
        ]
      },
      {
        "title": "Interaction Services",
        "content": [
          {
            "text": "\nProvide a mechanism for getting the principal's permission to perform various actions\n"
          }
        ]
      },
      {
        "title": "Data Services",
        "content": [
          {
            "text": "\nProvide the Web service functionality that will be used on behalf of the principal\n"
          }
        ]
      },
      {
        "title": "Identity Services",
        "content": [
          {
            "text": "\nProvide access to information about the principal that may not be provided by the SAML assertion associated with the Web service request.\n"
          },
          {
            "subsection": "3.3.2.2 WS-Federation and WS-Trust",
            "text": []
          },
          {
            "text": "WS-Federation and WS-Trust were developed by IBM, Microsoft, RSA, Verisign, BEA, and several other vendors to create an identity federation system based on extensions to WS-Security that uses the core Web services protocols: SOAP and WSDL. WS-SecurityPolicy is an extension of the WS-Policy framework that allows a Web service to define a set of requirements detailing how messages should be secured and what tokens are required by the Web service. It is used by WS-Trust to determine what tokens are needed to interact with a particular Web service. As discussed in Section 3.1.2, these are referred to as claims."
          },
          {
            "text": "WS-Trust is used to exchange trust tokens between Web services. WS-Trust is an extension to WS-Security that provides methods for issuing, renewing, and validating security tokens as well as methods for establishing and brokering trust relationships between Web services. If the requester does not supply appropriate claims, it can use the security policy declared by WS-SecurityPolicy to determine the URI of the provider's Security Token Service (STS), who can provide the requester with the appropriate claims. Additionally, WS-Trust supports multi-messaging exchanges, allowing providers to use a challenge-response mechanism for authorization. Because WS-Trust builds upon WS-Security, claims can be anything from a digital signature to a X.509 certificate or an XML-based token such as a SAML assertion."
          },
          {
            "text": "WS-Federation expands on WS-Trust by providing various protocols by which STSs (interchangeably called Identity Providers in WS-Federation), requesters, and providers can interact with one another to allow Web services to trust each other across organizational boundaries. Each organization is a separate trust realm. WS-Federation allows Web services to communicate between multiple trust realms. Additionally, WS-Federation provides two profiles for how requesters interact with providers and STSs: the active requester profile and the passive requester profile. The passive requester profile details how messages should be passed between a requester Web browser, the provider, the Identity Providers (IPs) and STSs of both organizations so that WS-Federation can be used within the context of Web applications, providing users with a single sign-on experience. The active requester profile details how requesters should interact with the provider and the IP/STSs to access a provider in another trust realm."
          },
          {
            "subsection": "3.4 Describing Web Services Policies (WS-Policy)",
            "text": []
          },
          {
            "text": "WSDL describes how to communicate with a Web service by detailing the protocol bindings and message formats the Web service expects. In many cases, knowledge of protocol bindings# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "and message formats is not sufficient for requesters to dynamically bind to the provider. WSDL is limited to describing what needs to be placed in the message itself; it does not specify what type of metadata should be supplied, such as how the message will be authenticated or what portions of the message should be signed. To this end, Microsoft, IBM, BEA and others developed the Web Services Policy (WS-Policy) Framework, which allows providers to express the capabilities, requirements and characteristics of the Web service."
          },
          {
            "text": "WS-Policy requirements can range from specific on-the-wire requirements, such as requiring WS-Security encryption and signatures, to more abstract requirements, such as QoS or privacy requirements. A WS-Policy policy expression can provide senders with the essential metadata to fully automate the task of dynamic binding. A policy expression contains a set of policy alternatives encompassing sets of assertions."
          },
          {
            "text": "Policy assertions are defined for a number of WS-* specifications, including WS-SecurityPolicy, WS-ReliableMessaging Policy Assertion (WS-RM Policy) and WS-Addressing WSDL Binding. The WS-Policy Primer defines how these specifications can be used within a policy expression. As of mid-2007, there are three primary specifications defining WS-Policy assertions:"
          },
          {
            "text": "\nWS-SecurityPolicy defines assertions to specify integrity, confidentiality, and information about security tokens.\nWS-RM Policy defines assertions that can be used to specify how a Web service uses WS-ReliableMessaging.\nWS-Addressing WSDL Binding defines elements that can be used within a WSDL descriptor to specify the use of WS-Addressing.\n"
          },
          {
            "text": "Figure 3-2 shows a sample WS-Policy expression. The root expression of the example in Figure 3-2 is an All tag, which is used to specify that all of the contained expressions must be met by the requester for it to comply with the provider policy. The All tag contains the following expressions:"
          },
          {
            "text": "\nwsap:UsingAddressing, which specifies that requesters should include WS-Addressing information in the SOAP header.\nsp:TransportBinding, which specifies that requesters should use TLS to secure the SOAP message and defines the required parameters.\n"
          },
          {
            "text": "The sp:TransportBinding element contains an All tag containing two expressions:"
          },
          {
            "text": "\nsp:TransportToken, which specifies what type of token the sender must provide. In this example, sp:HttpsToken indicates that senders must provide a client certificate through TLS.\nsp:AlgorithmSuite specifies what algorithms the sender's TLS library must support. In this example, sp:Basic256Sha256Rsa15, defined by WS-SecurityPolicy, is used to indicate that the Advanced Encryption Standard (AES) algorithm should be used with a key size of 256 bits for symmetric cryptography, the 256-bit Secure Hash Algorithm (SHA) should be used for hashing, and version 1.5 of the RSA encryption algorithm for asymmetric cryptography.\n"
          },
          {
            "text": "WS-Policy can also be used to describe the parameters necessary when using WS-ReliableMessaging to ensure message delivery. Figure 3-3 shows a policy defining an inactivity timeout of 2 seconds, a base retransmission interval of 5 seconds using the exponential backoff algorithm and an acknowledgement.# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "interval of 5 seconds.",
        "content": [
          {
            "text": "Receivers have the option of specifying whether senders should use TLS or WS-Security to secure SOAP messages. Some receivers may wish to let senders decide which option to support. In this case, the ExactlyOne expression would be used to indicate the option in a manner similar to Figure 3-4."
          },
          {
            "text": "The ExactlyOne expression in Figure 3-4 contains two expressions related to securing Web service messages between the requester and provider. Senders must choose exactly one of these options when sending a SOAP message to this service:"
          },
          {
            "text": "\nsp:TransportBinding, which indicates requesters may use SSL/TLS to secure messages\nAll, which contains two WS-SecurityPolicy expressions that must be followed when using WS-Security in place of SSL/TLS:\nsp:SignedParts, which indicates that both the SOAP message body and header must be signed\nsp:EncryptedParts, which indicates that the SOAP message body must be encrypted.\n"
          },
          {
            "text": "Each policy expression can contain an All expression, an ExactlyOne expression or a policy expression element from a WS-Policy grammar, such as WS-Security, WS-RM, or WS-Addressing. Each of these expressions may contain another Policy expression. This level of flexibility allows providers to completely specify the requirements that must be met by requesters beyond those described in the provider's WSDL description."
          },
          {
            "text": "Policy expressions are external to the metadata stored in UDDI and WSDL, so providers must rely on a separate mechanism for distributing WS-Policy information: WS-MetadataExchange or WS-PolicyAttachment. The WS-MetadataExchange specification defines an encapsulation format for Web service metadata (such as WS-Policy expressions), a mechanism for metadata-driven message exchange, and relies on the WS-Transfer specification to provide a Web service endpoint from which requesters can retrieve the metadata. The WS-PolicyAttachment specification defines how to reference policies from WSDL definitions, how to associate policies with deployed endpoints, and how to associate policies with UDDI entries."
          },
          {
            "text": "In 2006, WS-Policy and WS-PolicyAttachment were submitted to W3C for standardization. They are scheduled to be released as W3C Recommendations in 2007. In 2005, WS-SecurityPolicy was submitted to the OASIS Web Services Secure Exchange Technical Committee. Even though these specifications are not official OASIS standards, interoperable commercial and open source implementations are available from organizations that were not involved in developing the specification, such as the Apache Software Foundation and Sun Microsystems."
          }
        ]
      },
      {
        "title": "3.5 Distributed Authorization and Access Management",
        "content": [
          {
            "text": "Given the distributed nature of Web services architectures, managing authorization and access control credentials for users in a SOA environment can be challenging. Section 3.5 describes a number of traditional and emerging models and practices that may be extended to capture, manage, and enforce access control decisions for authorized users."
          },
          {
            "subsection": "3.5.1 Authorization Models# Authorization Models in Access Management",
            "text": []
          },
          {
            "text": "The following subsections describe the authorization models most relevant to access management in a SOA, namely role-based, attribute-based, policy-based, and risk-adaptive access control. While role-based access control models may be familiar to most software designers and developers, knowledge of the other models can provide a perspective on the direction in which Web services access management is heading."
          }
        ]
      },
      {
        "title": "3.5.1.1 Role-Based Access Control",
        "content": [
          {
            "text": "Role-based access control (RBAC) is an authorization mechanism that associates a set of access privileges with a particular role, often corresponding to a job function. With RBAC, all user access is mediated through roles. RBAC simplifies security management by providing a role hierarchy structure. In addition, RBAC has extensive provisions for constraints on user access based on administrator-defined relationships. This feature makes it possible to implement complex controls such as separation of duty. Constraints can include either static or dynamic attributes. Most commercially available RBAC systems conform to some of the RBAC standards, which are summarized on the NIST RBAC Web site. Additionally, OASIS provides the Core and hierarchical role based access control profile of XACML, allowing organizations to support RBAC using the flexible and platform-independent XACML specification."
          },
          {
            "text": "In most cases, COTS Web servers or Web service platforms will support designation and assignment of privileges to roles as part of their standard definition of user accounts and access control privileges. In worst cases, the administrator will have to create the necessary user groups, enroll the appropriate users, and assign them role-appropriate privileges."
          },
          {
            "text": "RBAC on a Web service platform should be implemented at a minimum for the administrator, developers, and any other privileged accounts that will be required for the Web service to operate. The Web service platform must be configured to enforce separation of roles (i.e., not allowing a user assigned to one role to perform functions exclusively assigned to another role). The privileges associated with each role should be assigned in a way that implements least privilege\u2014each role should be assigned only the minimum privileges needed to perform the functions required by the role."
          },
          {
            "text": "Most vendors implement some form of RBAC in their core Web services products. Another alternative is to implement or deploy RBAC at the Web services level, which is supported by a number of XML gateways and Web service vendors. However, the RBAC policies supported are less granular because a COTS product may need to be generic so it can support many different types of organizational policies."
          }
        ]
      },
      {
        "title": "3.5.1.2 Attribute-Based Access Control (ABAC)",
        "content": [
          {
            "text": "ABAC provides a mechanism for representing a subject's (either a user or application) access profile through a combination of the following attribute types:"
          },
          {
            "text": "\nSubject Attributes (S). Associated with a subject that defines the identity and characteristics of that subject.\nResource Attributes (R). Associated with a resource, such as a Web service, system function, or data.# Environment Attributes (E)\n"
          },
          {
            "text": "Describes the operational, technical, or situational environment or context in which the information access occurs. ABAC policy rules are generated as Boolean functions of S, R, and E attributes and dictate whether a subject S can access a resource R in a particular environment E - as loosely indicated in Figure 3-5:"
          },
          {
            "text": "ABAC clearly provides an advantage over traditional RBAC when extended into SOA environments, which can be extremely dynamic in nature. ABAC policy rules can be custom-defined with consideration for semantic context and are significantly more flexible than RBAC for fine-grained alterations or adjustments to a subject's access profile. ABAC also integrates seamlessly with XACML, which relies on policy-defined attributes to make access control decisions."
          },
          {
            "text": "One additional benefit to Web service implementations of ABAC lies in the nature of the loose definition of subjects. Because ABAC provides the flexibility to associate policy rules to any actor, it can be extended to Web service software agents as well. Figure 3-6 illustrates how an ABAC attribute authority (AA) can be integrated with a SAML framework. In this diagram, the AA generates attribute assertions, which contain all the attributes necessary for an access control decision based on an ABAC policy written in XACML. The PDP uses the attribute assertions, the authentication assertion, and the XACML policy to generate an authorization decision assertion. XACML is discussed in detail in Section 3.5.4."
          },
          {
            "text": "In Figure 3-6, the requester's authentication assertion is provided by the identity provider before accessing the resource. The following steps describe how SAML and XACML use the requester's attributes to determine whether access should be granted:"
          },
          {
            "text": "\nThe requester attempts to access the resource and supply the authentication assertion.\nThe Policy Enforcement Point (PEP) sends a SAML authorization decision request to the PDP.\nThe PDP requests certain attribute assertions that are associated with the requester.\nThe AA returns the appropriate attribute assertions.\nThe PDP requests the XACML policy from the policy store.\nThe PDP receives the XACML policy.\nAfter querying the XACML policy, the PDP sends an authorization decision assertion to the PEP.\nBased on the authorization decision assertion, the PEP grants the requester access to the resource.\n"
          }
        ]
      },
      {
        "title": "3.5.1.3 Policy-Based Access Control",
        "content": [
          {
            "text": "Policy-based access control (PBAC) is a logical and somewhat bounded extension of ABAC that is useful for enforcing strict environment-level access control policies. PBAC introduces the notion of a policy authority, which serves as the access decision point for the environment in question. PBAC leverages the granular policy rule functions inherent to ABAC; it focuses more on automatically enforcing mandatory access controls (MAC), which are traditionally much more bounded than discretionary controls."
          }
        ]
      },
      {
        "title": "3.5.1.4 Risk Adaptive Access Control",
        "content": [
          {
            "text": "Risk adaptive access control (RAdAC) is another variation on traditional access control methods. As opposed to RBAC, ABAC, and PBAC, however, RAdAC makes access control decisions on the basis of...# A Relative Risk Profile of the Subject"
          },
          {
            "text": "A relative risk profile of the subject and not necessarily strictly on the basis of a predefined policy rule."
          }
        ]
      },
      {
        "title": "Figure 3-7",
        "content": [
          {
            "text": "Figure 3-7 illustrates the logical process governing RAdAC, which uses a combination of a measured level of risk the subject poses and an assessment of operational need as the primary attributes by which the subject's access rights are determined."
          },
          {
            "text": "As a policy-driven mechanism, RAdAC is ostensibly an abstraction of PBAC. Unlike PBAC, however, a RAdAC framework requires associations with sources that are able to provide real-time, situation aware information upon which risk can be assessed with each authentication request."
          },
          {
            "subsection": "3.5.2 Enforcing Least Privilege for Services",
            "text": []
          },
          {
            "text": "Trust and privilege are not synonymous. This said, trusted objects are often used to perform privileged functions. Least privilege can and should be applied regardless of what access control methodology is in use. In a Web services environment, each Web service should be designed to not request or expect to obtain privileges that exceed the minimum privileges it needs to perform its current operation."
          },
          {
            "text": "Because of the functions they perform, trusted objects often require higher privileges than untrusted objects. Regardless of whether an object is trusted or untrusted, a privilege should be granted to it only at the moment the object needs that privilege, and the object should relinquish the privilege as soon as it completes the function/access for which the privilege was needed. Objects should not be allowed to retain a privilege that they are not actively using. Privileges should never be granted in anticipation of their being needed to perform some function/access in the future."
          },
          {
            "text": "The application's design should ensure that only a minimal number of application objects need to be trusted or are ever granted privileges that exceed those of the end users that are associated with those objects. Whenever possible, implement objects without privileges, and if necessary, divide the complex functions they must perform into multiple simple functions, with a separate minimal required privilege for each function."
          },
          {
            "text": "The application should also support minimization of permissions granted to a user, with each user granted only those minimal privileges needed to execute the application and access the data/resources for which the user is authorized. In most cases, user privileges will be determined by the user's role. As with other application objects, user privileges should be assigned at the moment they are needed, and revoked as soon as they are no longer being used."
          },
          {
            "text": "Web services should be designed so that only a few components perform trusted operations. By restricting trusted functions to a small number of components, the overall architecture is simplified and the potential attack scenarios are minimized. Nevertheless, trusted functions should not be limited solely to a single component, which introduces a single point of failure. If the single trusted component fails, none of the dependent components will be able to function adequately, leading to a loss of availability. Trusted Web services should be deployed to be as available as possible."
          },
          {
            "text": "There are three important concepts to consider when developing the access control policy for Web services. These concepts apply equally within the OS itself and within the SOA.# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "as a whole."
          }
        ]
      },
      {
        "title": "Separation of Duties",
        "content": [
          {
            "text": "Developers should write Web services to require only appropriate system roles or attributes to operate correctly."
          }
        ]
      },
      {
        "title": "Separation of Roles and Separation of Privileges",
        "content": [
          {
            "text": "The roles or attributes required for Web services should directly correspond to the set of functions to be performed."
          }
        ]
      },
      {
        "title": "Separation of Domains (Compartmentalization)",
        "content": [
          {
            "text": "Access control policy may benefit from separating Web services into various compartments. For example, separating roles associated with rate service A from those associated with rate service B will allow an administrator to modify each service's permissions separately. The difficulty of compartmentalization depends on the access control mechanism used: this could be implemented in ABAC using resource attributes or through additional roles in RBAC."
          },
          {
            "text": "Note that most general purpose operating systems' access controls cannot isolate intentionally cooperating programs. If the cooperation of malicious programs is a concern, the application should be implemented on a system which implements mandatory access controls and limits covert channels."
          },
          {
            "subsection": "3.5.3 SAML",
            "text": []
          },
          {
            "text": "SAML defines an XML vocabulary for sharing security assertions that specify whether and how an entity was authenticated, information about an entity's attributes or whether an entity is authorized to perform a particular action. These assertions enable identity federation and distributed authorization within a SOA."
          },
          {
            "text": "The SAML specification defines a framework for creating and exchanging generic assertions with given validity periods, signatures, encrypted elements and unique identifiers (among other attributes). Assertions are associated with a given subject (a named entity). When using SAML, there are two parties: the relying party and the asserting party. The asserting party asserts information about a particular subject, such as whether or not a user has been authenticated or has a particular attribute. The relying party uses the information supplied by the asserting party to make decisions, including, but not limited to, whether or not to trust the asserting party's assertion. By trusting the asserting party's information, the relying party can provide services without requiring the principal to authenticate again."
          },
          {
            "text": "SAML assertions contain a number of required elements (except where otherwise noted):\n- ID. Uniquely identifies this assertion\n- IssueInstant. Timestamp indicating when the SAML assertion was created\n- Issuer. Information about the entity that created the assertion\n- Signature. Digital signature of the SAML assertion (optional)\n- Subject. Information about the entity to which this assertion applies (optional)\n- Conditions. Information used to determine the validity of the assertion, such as a validity period (optional)\n- Advice. Information that may be useful in processing the assertion (optional)\n- Statements. SAML statements can provide information about subject authentication, authorization decision or attributes. Additional types of statements can be defined by an extension. (optional)# SAML Assertions and Statements"
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "\nIssuer (optional)\nSignature (optional)\nExtensions (optional)\nStatus: a code representing the status of the response (optional).\n"
      },
      {
        "content": "SAML requests and responses are extended by each of the SAML protocols, providing support for a variety of SAML use cases. The SAML specification defines six protocols, allowing extensions to provide support for future protocols."
      },
      {
        "title": "Assertion Query and Request Protocol",
        "content": [
          {
            "text": "The assertion query and request protocol allows services to request specific assertions from a SAML authority. Services can request an assertion based on its ID, or query for authentication, attribute or authorization decision assertions."
          }
        ]
      },
      {
        "title": "Authentication Request Protocol",
        "content": [
          {
            "text": "The authentication request protocol allows services to request that an entity be authenticated by the identity provider; the subject may be authenticated before, during, or after the identity provider receives the authentication request. The authentication request protocol can play an important role in authenticating users in a seamless fashion when traversing from a publicly available service to a protected service. Similarly, the authentication request protocol can support re-authenticating subjects or requiring stronger authentication when accessing sensitive services."
          }
        ]
      },
      {
        "title": "Artifact Resolution Protocol",
        "content": [
          {
            "text": "The artifact resolution protocol allows a SAML provider to retrieve a SAML message based on its artifact, which is a reference to the message. The SAML-aware service passes the artifact to the provider instead of the SAML message itself. Artifacts are intended to be used when the transport mechanism has size constraints or cannot provide a secure channel through which to send a SAML message. For example, a SAML artifact can be passed as an HTTP GET parameter, allowing a traditional Web browser to pass a SAML assertion from the identity provider to a Web application without requiring the Web browser to be SAML-compliant."
          }
        ]
      },
      {
        "title": "Name Identifier Management Protocol",
        "content": [
          {
            "text": "The name identifier management protocol provides a mechanism through which SAML identity providers and service providers can notify one another that a principal's identifier has a new or modified value or format. Identity providers supply a ManageNameIDRequest element containing a NameID or EncryptedNameID element and NewID, NewEncryptedID, or Terminate element. Privacy concerns may be met by submitting the identifiers in encrypted form. Through the Terminate element, an identity provider can inform service providers that it will no longer supply assertions for the specified principal, or a service provider can inform the identity provider that it will no longer accept assertions for the specified principal."
          }
        ]
      },
      {
        "title": "Single Logout Protocol",
        "content": [
          {
            "text": "The single logout protocol allows a principal to simultaneously log out of multiple sessions from a single service provider. When a principal has authenticated to an identity provider, the identity provider may initiate a session so that the principal does not need to re-authenticate (the identity provider becomes a session authority). When the principal accesses service providers, they may wish to initiate sessions to alleviate the need to communicate with the identity provider for each of the principal's requests (the service provider becomes a session participant). Should the principal wish to...\n```# Terminate All Sessions"
          },
          {
            "text": "Associated with the initial authentication, a LogoutRequest may be sent to any of the session participants. If a session participant received the LogoutRequest, it will forward the LogoutRequest to the session authority. The session authority will send a LogoutRequest to all session participants except for the participant that initiated the LogoutRequest. The single logout protocol ensures that the principal does not need to be aware of all sessions associated with the original authentication."
          }
        ]
      },
      {
        "title": "Name Identifier Mapping Protocol",
        "content": [
          {
            "text": "The name identifier mapping protocol allows a provider to request a principal's name identifier from an identity provider in a specific format. A service provider must send a NameIDMappingRequest to the identity provider with a BaseID, NameID or EncryptedID element identifying the principal and a NameIDPolicy element indicating the format of the identifier to be returned. Use of an EncryptedID element can ensure that the principal's privacy is adequately maintained during the exchange. The identity provider will return a NameID or EncryptedID that satisfies the request parameters."
          },
          {
            "subsection": "3.5.3.4 SAML Profiles",
            "text": []
          },
          {
            "text": "The SAML specification provides a number of profiles that specify how SAML messages, assertions and protocols are to be used in various contexts. Because SAML is a versatile specification, there are five categories of profiles. Some categories only define a single profile, leaving room for future SAML specifications to expand. The five profile categories are:"
          },
          {
            "text": "\nSingle sign-on (SSO). These profiles define the protocols necessary to support SSO across multiple Web applications. There are profiles defining how to support SAML SSO when the client uses a Web browser or a SAML-aware client or proxy, a profile for discovery identity providers, a profile for single logout, and a profile for managing identifiers among multiple service providers.\nArtifact resolution. This profile defines how SAML-aware providers should retrieve the SAML assertion associated with a SAML artifact provided by a requester.\nAssertion query/request. This profile describes how to use the SAML assertion query/request protocol over a synchronous protocol, such as SOAP.\nName identifier mapping. This profile describes how to use the SAML name identifier mapping protocol.\nAttribute. These profiles define how to represent attributes from common attribute stores in SAML assertions.\n"
          },
          {
            "subsection": "3.5.3.5 SAML Attributes",
            "text": []
          },
          {
            "text": "In Web services, attributes are usually disseminated using either SAML attribute assertions or X.509 certificates containing the required attributes. While X.509 certificates only provide a limited set of attributes, SAML attributes can encompass any type of attribute. In most enterprise systems, user attributes are stored in various Lightweight Directory Access Protocol (LDAP) or X.500 directories, Relational Data Base Management Systems (RDBMS), or Active Directories (AD). In the SAML architecture, these are referred to as attribute stores. By abstracting the various forms of attribute stores into a single entity, the SAML request/response protocol can be used to query.# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "any attribute store,\nregardless of its underlying structure.\nThrough the SAML attribute profiles, interoperability between the attribute store's SAML interface and the Web service accessing it is guaranteed. SAML V2.0 provides attribute profiles for X.500/LDAP attributes, Universally Unique Identifiers (UUID), DCE PAC attributes, and XACML attributes. The X.500/LDAP, UUID, and DCE PAC attribute profiles detail how to convert between SAML attributes and the structures of the individual attribute stores. While XACML is not an attribute store, the XACML attributes profile details how SAML assertions can be used as input to XACML authorization decisions. SAML can be extended to support any other form of attribute store, allowing attributes to be accessed in a Web services environment."
          },
          {
            "text": "While SAML provides a mechanism for accessing attributes, it does not provide a mechanism for updating attributes in a SOA. As of this writing, there is no Web services standard for modifying the contents of data stores used by a SOA. For Web services to alter the contents of the various attribute stores, custom Web services would have to be developed using appropriate WS-Security and authorization techniques."
          }
        ]
      },
      {
        "title": "3.5.3.6 SAML Security",
        "content": [
          {
            "text": "The Security and Privacy Considerations for the OASIS Security Assertion Markup Language document outlines the threats faced when using SAML and provides guidance in securing a SAML-based architecture. In particular, it is important to recognize that once a SAML assertion has been issued, it is not possible to control its dissemination. An entity that receives a SAML assertion may pass it on to other, potentially malicious entities as part of the system. It is important to ensure that all SAML assertions and entities that will receive them follow appropriate organizational policies. Because of this, it is possible that a malicious entity may attempt to use SAML assertions in replay attacks (in particular, authentication assertions and authorization decision assertions are likely to be replayed). There are a number of techniques that can mitigate this threat, including:"
          },
          {
            "text": "\nEncrypting the assertion will prevent a third party from viewing it, although a malicious entity may attempt to resend the encrypted assertion.\nSigning the entire message rather than the assertion itself, using WS-Security in a SOAP response or SSL/TLS in a HTTP response. This way, an attacker must resend the whole message to be successful.\nEnforcing validity periods and ensuring that the IssueInstant of the assertion is reasonable. This will minimize the amount of time during which an attacker may successfully execute a replay attack.\n"
          },
          {
            "text": "If a SAML authority is publicly accessible, an attacker may send SAML queries to gain information about the subjects within the system. Similarly, an attacker may construct a malicious SAML authority. In each case, it is especially important that entities using SAML authenticate one another before requesting or providing information about subjects within the SOA."
          }
        ]
      },
      {
        "title": "3.5.4 XACML",
        "content": [
          {
            "text": "Within Web services extensions, a vocabulary is required for expressing the# Rules Needed to Make Authorization Decisions"
          },
          {
            "text": "One such vocabulary is XACML. XACML is a language- and platform-neutral method for representing and enforcing security policies. Using XML as a basis for a security policy language is the natural choice because its syntax can easily be extended to conform to the requirements of individual applications. XACML defines both a policy language and a request/response language for access control decisions. The policy language is used to define the access control requirements of a particular system or organization. The request/response language provides a mechanism for asking whether or not a particular action is allowed. XACML also defines a method for mapping the request to the policy and determining whether or not the policy allows the requested action."
          },
          {
            "text": "XACML is used in conjunction with SAML to provide a means for standardizing access control decisions for resources over a network. XACML uses a context that can easily be mapped on SAML requests to determine if access should be granted to a resource based on XACML policies. Once the policy is evaluated and returns a true or false value to indicate whether or not access is granted, a SAML authorization decision assertion is returned, which is then processed accordingly."
          },
          {
            "text": "The following subsections describe additional details on the XACML specification, including major inherent features and a discussion of how the transparent components of XACML operate in the background. Also provided are summaries on how XACML is implemented in a SOA and examples of practical extensions/implementations of XACML within the community."
          }
        ]
      },
      {
        "title": "3.5.4.1 How XACML Works",
        "content": [
          {
            "text": "XACML defines a language for creating policies. The basic elements for policies are Policy and PolicySet. A PolicySet can contain Policies and references to external policies. A Policy defines a single access control policy that is expressed through one or more Rules. XACML defines several combining algorithms for determining a single decision from the results of multiple rules."
          },
          {
            "text": "Figure 3-11 shows an XACML policy that uses the permit-overrides combining policy in which any result of \"permit\" will grant access. This policy shows that members with a group attribute of \"developers\" can perform the read action on http://server.example.com/code/docs/guide.html."
          },
          {
            "text": "The XACML specification uses the term policy enforcement point (PEP) to refer to the entity that performs the access control, such as a file system or Web server. The PEP sends XACML requests to the PDP and receives XACML responses that it uses to grant or deny access. The PDP is the entity that receives access requests from the PEP. It looks at the request and the applicable policy and sends a response as to whether or not access should be granted."
          },
          {
            "text": "Figure 3-12 shows an XACML request in which the user, jsmith@users.example.com, is attempting to perform a read action on http://server.example.com/docs/guide.html. This request provides the user's group attribute, which is required by the policy to make the access decision. From the request, jsmith@users.example.com's group attribute is \"developers.\" This request is sent.# by the PEP to the PDP."
          },
          {
            "text": "Once the PDP receives the request, it processes the request against the policy provided in Figure 3-11. Because jsmith@users.example.com's group attribute is \"developers\", the resulting decision is \"permit.\" This decision is sent to the PEP in the form of an XACML response as shown in Figure 3-13. The PEP will then permit jsmith@users.example.com to read http://server.example.com/code/docs/guide.html."
          },
          {
            "text": "Access control policies are comprised of Targets and Rules. A Target defines a set of conditions for the Subject, Resource, and Action that must be met for a PolicySet, Policy, or Rule to apply to a request. The Target is used by the PDP to determine whether or not the request applies to this particular rule. Once an applicable policy is found, the Rules are activated. Most Rules consist of an Effect and a Condition. The Effect determines what the results of the Condition mean, while the Condition can test that any attribute meets a certain requirement."
          },
          {
            "text": "Attributes are used in XACML to aid in creating access control policies. In essence, attributes refer to individual properties of the Subject, Resource, Action, or Environment that are applicable to the access request, such as the Subject's user name or the Environment's current time. A Policy uses the AttributeDesignator and the AttributeSelector to retrieve attributes from a request. The AttributeDesignator specifies an attribute with a given name and type that the PDP will retrieve from the request or some external source. AttributeSelectors provide an XPath query for resolving the values in the request or elsewhere. The attributes received are used in Rules to determine whether or not to grant access."
          }
        ]
      },
      {
        "title": "3.5.4.2 Using XACML",
        "content": [
          {
            "text": "XACML does not have the inherent ability to control access to anything. It is used to provide an access control policy and to determine whether or not a requested action is allowed. The policy and requested action can be anything from read-access of a particular element in an XML file to a request for entry through a physical door. When using XACML in a Web service or Web application, it is important to understand that the application itself must be the PEP. All requests for information from the client or requester service must be translated into an access request. In many implementations, XACML is used solely for authentication, in which case only the authentication request needs to be translated while all subsequent requests would be allowed. As mentioned earlier, the PEP needs to send XACML requests to the PDP. The PDP will take the XACML request and determine the appropriate XACML response to send to the PEP, which will then grant or deny the request."
          },
          {
            "text": "Because there is no mechanism for transmitting XACML over a network in the XACML specification, SAML is traditionally used to transmit requests, responses, and attributes over a network. SAML was designed for the secure exchange of authentication and authorization information, but not for performing the actual decisions. This makes it a perfect match for transmitting XACML information over a network. The PEP converts the XACML request into a SAML query and sends it to the PDP.# The PDP converts"
          },
          {
            "text": "The PDP converts the SAML query into an XACML request and processes the request against the XACML policy. The XACML response is converted into a SAML response and sent back to the PEP, which converts it back into an XACML response. SAML does not provide message confidentiality\u2014only message integrity. If any of the data being transmitted is sensitive, it must be transmitted using SSL/TLS or WS-Security. If the SAML protocol is being used without SSL/TLS, all SAML messages must be signed appropriately."
          },
          {
            "text": "The XACML v2.0 specification only supports a configuration where the PDP and PEP are on the same system. There is no standard specified for transmitting XACML policies, requests, or responses over a network. SAML is designed for the secure transmission of security attributes, which are used by XACML to determine whether or not to grant access. To this end, SAML v2.0 includes an XACML binding."
          },
          {
            "text": "Because XACML can be used over a variety of languages and platforms, tools for generating XACML policies can be used for any application and platform that supports XACML, unlike current policy generators that only work with a specific application."
          }
        ]
      },
      {
        "title": "3.5.5 Role of XML Schema in Implementing Access Control",
        "content": [
          {
            "text": "While not developed specifically for access control, XML schemas can be effective for controlling access to Web services. XML parsing libraries often support validating XML documents against a defined XML Schema. Because XML Schemas can rigidly define the types of data and format of XML elements, they can be used to prevent the Web service from processing invalid requests. For example, the SOAP XML Schema could be modified by a Web service developer to only allow portTypes that match a particular regular expression. All other requests would not pass through the XML validator and would not reach the Web service. In addition, the XML parser could be configured to use a different XML Schema based on the identity of the remote Web service, which would not require the developer to implement the necessary authorization functionality in the Web service itself. In fact, use of XML Schema-based access control could prove to be more powerful than programmatic access control since many malicious SOAP requests would not reach the application code. One of the drawbacks of using XML Schema validation for access control is that it could put a heavy load on the system, because Schema validation is processor-intensive; this could lead to a degradation of service."
          }
        ]
      },
      {
        "title": "3.5.6 Use of Specialized Security Metadata for Access Control",
        "content": [
          {
            "text": "If the Web service handles personally identifiable information (PII), proprietary, or other sensitive data, it may need to label or otherwise mark output from the application. For labeling of Web pages, one approach is to use metatags to store the label information directly in the HTML source of the page, to be displayed as part of the page in the user's browser. If the Web page is printed from the browser, this label will be included in the printed output."
          },
          {
            "text": "Some government agencies have defined XML-based markup syntax and schema for implementing security labels in data. The Intelligence Community (IC) Metadata Standards# Working Group (MSWG)"
          },
          {
            "text": "The Working Group (MSWG) develops standards for affixing security labels to online XML and HTML content and downloadable electronic documents posted on the IC's Intelink World Wide Web-like intranet. While these standards are developed specifically for the IC, they can serve as a basis for any organization's metadata standards. In addition, any organization that interacts with the IC may improve communications efficiency by embracing these standards."
          },
          {
            "text": "The IC security metadata standards are intended to be consistent with the key XML security standards (XML-Signature, XML-Encryption and XKMS). The relevant IC standards are:"
          },
          {
            "text": "\nIC Metadata Standard for Publication (IC MSP)\nIC Metadata Standard for Information Security Markings (IC ISM)\nIC Standard for Core Metadata (IC Core).\n"
          },
          {
            "text": "Within DoD, a similar effort has been put forth called the DoD Discovery Metadata Standard (DDMS). DDMS does not directly support embedding metadata tags within XML documents. Instead, it focuses on creating metadata registries that can be accessed in conjunction with DoD resources. As with the IC standards, use of DDMS may improve efficiency in communications for organizations that interact closely with DoD."
          },
          {
            "text": "The DoD and the IC are working on harmonization of security labels based on the labeling specifications defined by the IC's Controlled Access Program Coordination Office (CAPCO) and those based on DoD Directive 5200.1, DoD Information Security Program (13 December 1996)."
          },
          {
            "text": "In the private sector, a number of organizations are developing metadata specifications to address regulations such as the Health Insurance Portability and Accountability Act (HIPAA) of 1996. The Food and Drug Administration (FDA) approved the Structured Product Labeling (SPL) specification from Health Level Seven (HL7) as a mechanism for exchanging medication information. SPL Release 2 provides confidentiality codes that can be used to specify whether a particular entity can view the information in the document."
          },
          {
            "text": "The objective of these standards is to describe XML metadata tags and their possible values. These tags and values can be embedded in XML content to indicate the classification or sensitivity level associated with the tagged data. In addition, the standards describe one or more DTDs or XML Schemas specifying the rules for parsing the metadata security tags."
          }
        ]
      },
      {
        "title": "3.6 Confidentiality and Integrity of Service to Service Interchanges",
        "content": [
          {
            "text": "Although transport layer security mechanisms are provided through using secure transport protocols such as SSL/TLS, message layer security of XML is still needed for the following:"
          },
          {
            "text": "\nEnd-to-End Security. Secure transport protocols can assure the security of messages only during transmission. Because messages are received and processed by intermediaries, secure end-to-end communication is not possible if these intermediaries are not completely trusted.\nTransport Independence. Even if all the communication links are secure and the intermediaries can be trusted, security information such as the authenticity of the originator of the message needs to be translated to the next secure transport protocol along the message path. This could be tedious and...# Security Concerns in Web Services\n"
          },
          {
            "text": "Complex, which may lead to security breaches. It is important to deal with the security concerns at the message layer independently of the transport layers."
          }
        ]
      },
      {
        "title": "Security of Stored Messages",
        "content": [
          {
            "text": "Once a transmission is received and decrypted, transport layer security does not protect data from illicit accesses and alterations. In situations where messages are stored and then forwarded, message layer security is necessary."
          },
          {
            "text": "The following subsections describe technologies that may be leveraged to improve the confidentiality and integrity of Web services. This includes both session/transport level security (i.e., SSL/TLS) as well as message-level security, such as that provided through WS-Security (as described below). Integrity can be enforced to an extent through the use of XML gateways (i.e., XML firewalls), and further explanation of this notion is provided in Section 3.6.4."
          },
          {
            "subsection": "3.6.1 Transport Layer Confidentiality and Integrity: HTTPS",
            "text": []
          },
          {
            "text": "Because Web services rely on HTTP as the transport layer, they can be easily configured to communicate over HTTP Secure (HTTPS). The HTTPS protocol is defined as HTTP over SSL/TLS. SSL/TLS provide socket-layer security, encrypting all communication over a particular TCP connection\u2014immediately granting an insecure application-layer protocol security without altering it. Through SSL/TLS, HTTPS supports authentication, confidentiality, and integrity of data sent between the endpoints. Use of HTTPS provides the following:"
          },
          {
            "text": "\nEach service only needs to have knowledge of those services it directly communicates with, which reduces the certificate distribution problem.\nEach Web service uses the framework's authentication and authorization mechanism rather than implementation-specific code.\n"
          },
          {
            "subsection": "3.6.2 XML Confidentiality and Integrity",
            "text": []
          },
          {
            "text": "The XML security standards define a framework and processing rules that can be shared across applications using common tools, avoiding the need for extensive customization of applications to add security. The XML security standards reuse the concepts, algorithms and core technologies of legacy security systems while introducing changes necessary to support extensible integration with XML. This allows interoperability with a wide range of existing infrastructures and across deployments."
          },
          {
            "text": "The XML security standards define XML vocabularies and processing rules using established cryptographic and security technologies, to provide flexible, extensible and practical ways of satisfying security requirements. The core XML security standards include the following:"
          },
          {
            "text": "\nXML Signature. For integrity and signatures, XML Signature defines digital signatures and related cryptographic integrity and authentication measures for XML.\nXML Encryption. For confidentiality, XML Encryption supports encryption using a variety of both symmetric and asymmetric cryptographic algorithms.\nXML Key Management Specification (XKMS). For key management, XKMS addresses PKI and key management network services in XML.\n"
          },
          {
            "text": "Many other confidentiality and integrity technologies, such as SSL/TLS or virtual private networks (VPN), only provide confidentiality while the information is in transit, not while it is stored at a server.# XML Encryption and XML Signature"
          },
          {
            "text": "XML Encryption and XML Signature use the same cryptographic algorithms as other cryptographic technologies and may be subject to similar attacks. All applications depending on XML Encryption and XML Signature should follow the guidelines set forth in NIST SP 800-21-1, SP 800-32, SP 800-57, FIPS 140-2 and FIPS 186-2."
          }
        ]
      },
      {
        "title": "XKMS",
        "content": [
          {
            "text": "XKMS defines protocols for Public Key management services. Public Key management includes the creation of public and private key pairs, the binding of key pairs with identity and other attributes, and the representation of key pairs in different formats. Public key technology is essential to XML Signature, XML Encryption, and other security applications. When signing, the private key is used to sign and the public key is used to verify signatures. When encrypting, the public key is used to encrypt and the private key is used to decrypt. In both cases, the private key must be maintained under control of the owner and the public key may be shared with others. XKMS is designed to help manage the sharing of the public key to enable signature verification and encryption. XKMS enables users to delegate key management functions to a trust service accessed via SOAP and XML. XKMS enables key management to be provided as a service to the application, without having to use a PKI toolkit to implement the service."
          }
        ]
      },
      {
        "title": "XML Security Standards in Web Services",
        "content": [
          {
            "text": "When using XML Security standards in Web services, both the requester and provider must support the particular algorithms chosen and must decrypt or verify the SOAP messages before acting upon them. Also, because the SOAP specification does not provide support for encrypting portions of SOAP messages, both SOAP endpoints must understand the protocol and tags used to represent encrypted or signed SOAP elements. To prevent proprietary and incompatible Web service security mechanisms, the WS-Security standard was developed by Microsoft, IBM, and Verisign to define a unified mechanism for securing SOAP messages."
          },
          {
            "subsection": "3.6.3 WS-Security for SOAP Confidentiality and Integrity",
            "text": []
          },
          {
            "text": "As mentioned earlier, the WS-Security standard was designed to use the XML Encryption and XML Signature specifications for message-layer confidentiality and integrity. By signing and encrypting at the message level, senders control whether intermediaries can modify or view the content in transit. Additionally, the entire message can be stored intact, maintaining integrity or confidentiality while at rest. Because message integrity is provided by digital signatures, non-repudiation can be achieved by logging individual messages for later retrieval (Section 3.7.2 describes non-repudiation in more detail). To fully support WS-Security, a Web service needs to be able to access public keys for all nodes with which it will interact, not simply those nodes it communicates with directly. This allows WS-Security to prevent man-in-the-middle attacks."
          },
          {
            "text": "One of the main drawbacks associated with WS-Security is its use of asymmetric cryptographic algorithms for encryption, which are computationally intensive. To remedy this situation, the WS-SecureConversation specification was developed, allowing Web services to create a symmetric session key (similar to how SSL/TLS functions) to allow faster symmetric cryptographic algorithms to be used.# for message-level security."
          },
          {
            "text": "WS-SecureConversation is well-suited for Web services that receive or send large volumes of messages to a small number of services."
          }
        ]
      },
      {
        "title": "3.6.4 Role of XML Gateways in Integrity Protection",
        "content": [
          {
            "text": "SOAP travels over HTTP, which is traditionally left open for Web traffic at perimeter firewalls. Additionally, with the advent of Liberty and SAML V2.0's Reverse SOAP (PAOS) specification, SOAP messages can pass through firewalls that limit incoming HTTP traffic but allow outgoing HTTP traffic. Some firewalls have begun to support blocking or allowing SOAP requests based on the source or destination of the request, but more robust and intelligent firewalls are needed to defend networks against malicious SOAP attacks."
          },
          {
            "text": "To this end, XML gateways were developed to offer the functionality of application-level firewalls specifically for Web services. Application-aware firewalls are nothing new; they have been around in the form of HTTP proxies for HTTP-based traffic and allow organizations to limit what an application-layer protocol can and cannot do."
          },
          {
            "text": "An XML gateway acts as the Web service and forwards all communication to the internal Web service, acting as an intermediary between untrusted services and the internal Web service. XML gateways can provide sophisticated authentication and authorization services, potentially improving the security of the Web service by having all SOAP messages pass through a hardened gateway before reaching any of the custom-developed code. XML gateways can restrict access based on source, destination, or WS-Security authentication tokens."
          },
          {
            "text": "XML gateways also support schema validation and some offer support for SOAP intrusion prevention against the following attacks that target vulnerabilities native to XML and XML based services:"
          },
          {
            "text": "\nWSDL scanning. Attempts to retrieve the WSDL of Web services to gain information that may be useful for an attack.\nParameter tampering. Modification of the parameters a Web service expects to receive in an attempt to bypass input validation and gain unauthorized access to some functionality.\nReplay attacks. Attempts to resend SOAP requests to repeat sensitive transactions.\nRecursive/oversized payload attacks. Attempts to perform a denial of service against the Web service by sending messages designed to overload the XML parser.\nExternal reference attacks. Attempts to bypass protections by including external references that will be downloaded after the XML has been validated but before it's processed by the application.\nSchema poisoning. Supplying a schema with the XML document such that the XML validator will use the supplied schema, allowing a malicious XML document to be validated without error.\nStructured Query Language (SQL) injection. Providing specially crafted parameters that will be combined within the Web service to generate a SQL query defined by the attacker.\nBuffer overflows. Providing specially crafted parameters that will overload the input buffers of the application and will crash the Web service\u2014or potentially allow arbitrary code to be executed.```markdown\nAdditionally, Web services behind an XML gateway may not need to implement the security functionality provided by the firewall, allowing developers to focus only on what the firewall does not support. Because SSL/TLS can be used between the firewall and the Web service, all communication between the Web service and the XML gateway can be trusted. If Web services behind the firewall do not implement security mechanisms to support confidentiality, integrity, and authentication, attackers that bypass the XML gateway may be able to subvert internal Web services. As such, it is always beneficial to implement defense-in-depth using XML gateways at the perimeter along with WS-Security or HTTPS for all internal Web services.\n"
          },
          {
            "text": "Finally, XML gateways support in-depth logging facilities for audit purposes. In conjunction with individual audit logs at each Web service, this allows administrators to keep track of what anomalies the XML gateway is experiencing to potentially fine-tune the XML gateway or notice when an attack has been successful and compromised an internal Web service. Nevertheless, the effectiveness of an XML gateway is dependent on the richness of the feature set and the granularity of policy control. Like any Web service, XML gateways are susceptible to threats from external attackers, so it is important to apply updates and define a policy for handling any intrusions related to the XML gateway."
          }
        ]
      },
      {
        "title": "3.7 Accountability End-to-End throughout a Service Chain",
        "content": [
          {
            "text": "Because of the SOA property allowing Web services to dynamically bind to one another, it is difficult to implement accountability in a service chain. Auditing is essential in many transactions to be able to ensure, after the fact, that the transaction took place as expected. For example, financial transactions often require extensive auditing. The lack of auditing standards for Web services serves as the primary hindrance to effectively implementing accountability across a SOA."
          },
          {
            "text": "In a SOA, auditing is accomplished by using a secure, distributed logging facility and WS-Security digital signatures. Through the use of a secure logging facility, all important WS-Security signed elements can be stored for audit purposes to determine which Web service performed what action. One common mechanism for implementing the logging facility is to develop Web service intermediaries that transparently log information about captured SOAP messages. Web services developed from scratch can be implemented to support an organization's distributed logging facility, but many COTS and government off-the-shelf (GOTS) Web services use their own non-standard logging mechanism."
          },
          {
            "text": "Standards efforts are on the horizon to enable interoperability between logging mechanisms, but until they are in place, organizations must support the wide variety of logging mechanisms in use. Regardless of what logging mechanisms are in use within an organization, there is no way in a SOA to require all participants in a service chain to use WS-Security or logging. For example, one member of the service chain may not perform logging but may advertise that it does; while another member of the service chain does not support WS-Security but the service that accesses it.\n```# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "performs signatures itself. It is important that the Web services a requester communicates with be trusted\u2014and that trust should imply that each subsequent service in the chain will be held to the same standard of trust. When going through audit logs it will be apparent which member of a service chain did not follow the requirements of the SOA, as the required logs or signed elements will not be available for examination."
          },
          {
            "text": "Enforcing accountability in a SOA (or other) environment requires the use of diligent auditing mechanisms, such that forensic data can be captured, compiled, and accurately attributed to users. The following subsections explain how auditing can be performed in SOAs. Section 3.7.2 explains the relevance of non-repudiation in a Web services environment and the means by which it can be enforced."
          }
        ]
      },
      {
        "title": "3.7.1 Audit in the SOA Environment",
        "content": [
          {
            "text": "Most COTS Web servers include an audit or security event logging service that provides the application with the mechanism it needs to log security events to multiple destination logs. Configurable property-driven parameters allow the administrator to modify the semantics of the application's log data capture without needing to rewrite the application code. For example, Java's standard logging API provides an extensible event logging service for many Java applications. Logging and audit entries captured may be routed to the local operating system audit trail, or to audit middleware, using pluggable logging modules."
          },
          {
            "text": "As noted, the audit/security event log data must be stored securely to prevent unauthorized tampering or disclosure of the log data. This secure storage may be implemented by channeling the log data via a secure connection to an external audit system, such as a central audit collection server, audit middleware, or the operating system audit trail. The audit/security event logs should be secured, either by transmitting the log data via an encrypted API, socket, or network connection, or by encrypting the log data before transferring them via an unencrypted or encrypted channel. In the case of a COTS audit server or audit middleware, the secure interface will ideally be provided as a standard feature of that product. If it is not, the application could provide it using a secure protocol or tunnel common to both it and the external audit system. Many organizations provide a logging core service within their SOA that other Web services can dynamically bind to securely submit logging data for storage in a central location. In addition to storing audit information on a remote system, it may be beneficial for Web services to store audit information locally in the event the central logging service fails or is temporarily inaccessible. NIST SP 800-92 provides guidance on managing security logs throughout an organization. While this guidance is not specific to SOA, many of the concepts introduced in the guide can be applied to Web services."
          }
        ]
      }
    ]
  },
  {
    "title": "Signature Verification in Web Services",
    "subsections": [
      {
        "content": "Signature can be verified by any subsequent Web service to verify which Web service performed the signature\u2014and verify whether or not the signed element has changed, as a digital signature is only valid if the signed data remains unchanged."
      },
      {
        "content": "WS-Security can provide non-repudiation of both the SOAP message itself and its contents. WS-Security supports signing the SOAP header, to ensure that the recipient and sender of the SOAP message have not changed since the message was sent. The SOAP message can be logged so that an audit can reveal that the SOAP message was valid. Additionally, sensitive information can be signed by another Web service for inclusion in the SOAP message. This allows a Web service to include signed data in different SOAP messages while maintaining that the original Web service signed the data\u2014allowing the message sender to sign the SOAP header for a message that was originally sent by a different Web service. This can be particularly useful in Web service choreographies and orchestrations as the data may pass between a number of Web services before reaching its intended destination."
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "State if it detects that any of the external mechanisms it relies on to accomplish its security functions (e.g., SAML Attribute Authority, PKI components) become unavailable."
      },
      {
        "content": "The following approaches to the design, implementation, and sustainment (operation and maintenance) of the Web service will increase its ability to recognize, resist, and recover from DoS:"
      },
      {
        "content": "\nDesign to include redundancy of critical functions, with diversity of how those critical functions are implemented.\nDesign exception and error handling capabilities that:\nAre specific to the various types of faults expected (do not simply throw general exceptions for every fault)\nDetect, recognize, and respond specifically and appropriately to attack patterns associated with denial of service\nAlways fail into a secure state\nGracefully degrade performance or perform partial shutdown of functions (but not security- or protection-related functions) according to a predefined plan\nAre configurable by the administrator at runtime\nPerform transaction rollback and checkpoint restart (for Web services that update data stores)\nPerform informative event logging\nGenerate only safe error messages to users (i.e., error messages that do not contain information that can be exploited by an attacker to craft a more effective attack).\nUse defensive programming techniques and information hiding to make the Web service software more robust.\nThrough QoS and reliable messaging, Web services can ensure that messages are not lost even if the network is saturated.\n"
      },
      {
        "content": "Web services, due to either their implementation or that of the frameworks on which they depend, may begin to degrade through residual cache data, temporary files, or even a fragmented hard drive. To prevent availability risks due to this degradation, it is useful to perform periodic software rejuvenations and reconfigurations to return the service software to a known reliable state. The techniques used vary among OSs and applications. Rejuvenation is common in organizations taking advantage of virtualization, because it can be performed by taking virtual machine snapshots and reverting back to them after a period of time."
      },
      {
        "content": "Organizations deploying and implementing Web services should also be aware of two of the most common accidental threats against availability: service recursion and service deadlock. Through Web services' support for dynamic discovery and binding, it is possible that a single Web service may attempt to bind to itself, possibly resulting in a DoS. Deadlocks are an equally important threat that arises when multiple entities are requesting access to the same resource."
      },
      {
        "title": "3.8.1 Failover",
        "content": [
          {
            "text": "One of the primary goals of a distributed system is the ability to recover when a node in the system fails. Through dynamic discovery and binding, Web services can be designed to recover if a single service fails, whether the failure is accidental or intentional. UDDI supports listing multiple URIs for each Web service.\n```# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "Service Failover",
        "content": [
          {
            "text": "When one instance of a Web service has failed, requesters can use an alternate URI. Using UDDI to support failover causes the UDDI registry to become a single point of failure. To remedy this, UDDI supports replication. Through replication, UDDI registries can support multiple nodes, where each node is an instance of the UDDI registry. This way, backup nodes can be used when an individual node is faced with a DoS attack."
          }
        ]
      },
      {
        "title": "3.8.2 Quality of Service",
        "content": [
          {
            "text": "Most Web services deployed do not provide guarantees for QoS. QoS defines what the expected level of performance a particular Web service will have. By prioritizing traffic, overall performance of the system can be improved, allowing the system to make informed decisions when faced with few resources. For example, a Web service operating on a saturated network may use prioritization to allow only the highest priority traffic to be processed while letting the other traffic wait until network traffic returns to normal."
          },
          {
            "text": "Standards are beginning to be developed and released to support availability of Web services. In particular, two competing standards are available that provide reliable messaging support: WS-Reliability and WS-ReliableMessaging, discussed in Section 3.8.3. Standards and techniques for providing QoS, detecting, resisting and recovering from DoS attacks are still under development. Sections 3.8.4 and 3.8.5 discuss two common design or implementation defects that can lead to a loss of availability without the malicious intent: deadlock and recursion."
          },
          {
            "text": "The standards state that other QoS parameters, such as rate of failure or average latency, are out of scope because they are usually dealt with by lower layer protocols. For Web services to truly support QoS, existing QoS support must be extended so that the packets corresponding to individual Web service messages can be routed accordingly."
          }
        ]
      },
      {
        "title": "3.8.3 Reliable Messaging",
        "content": [
          {
            "text": "The WS-Reliability and WS-ReliableMessaging standards provide guaranteed message delivery using one of the following semantics:"
          },
          {
            "text": "\nAt-Least-Once semantics, which is a guarantee that a message will be delivered.\nAt-Most-Once semantics, which is a guarantee that a duplicate message will not be delivered.\nExactly-Once semantics, which is a guarantee that a message will be delivered without duplication.\n"
          },
          {
            "text": "In addition to the message guarantee semantics, both standards provide a mechanism for sending messages in order. These features are crucial for critical applications that may rely on Web services. Previously, implementers would have to develop their own reliability mechanisms, which could prove costly or ineffective in practice. With the advent of these standards, robust implementations can be developed and used in the development of reliable Web services. Nevertheless, the existence of two competing standards makes it difficult for organizations to fully adopt either standard."
          }
        ]
      },
      {
        "title": "3.8.4 Handling Service Deadlock",
        "content": [
          {
            "text": "Deadlock is a condition that occurs when two processes are each waiting for the other to complete before proceeding. The result is that neither process can continue. Deadlocks can occur.# Deadlock in Service-Oriented Architectures (SOA)"
          },
          {
            "text": "Whenever the following four conditions are present in a system:"
          },
          {
            "text": "\nMutual exclusion. A resource can only be accessed by one process at a time.\nHold and wait. Processes already holding resources can request more resources.\nNo preemption. Only the process holding a resource has the power to release it.\nCircular wait. Processes form a circular chain of waiting.\n"
          },
          {
            "text": "Ideally, either the programs that experience deadlock or the underlying operating system would be able to automatically detect and recover from the deadlock, but it is difficult for individual systems in a SOA to detect deadlocked SOAP requests. SOA environments are susceptible to both local and distributed deadlocks. In a local deadlock, a provider is poorly designed and has an internal deadlock preventing it from returning a response to the requester. In a distributed deadlock, one Web service that is not responding may lead to the entire choreography stalling until an administrator notices."
          },
          {
            "text": "If deadlock occurs, multiple requesters could have their requests blocked indefinitely and could cause the clients awaiting the responses to suspend all other activities until the responses are received, thus rendering them unavailable to their users. Because Web services can be sequenced (i.e., a provider responding to one requester sometimes needing to act as a requester of services from another provider), the probabilities of a circular chain of waiting are increased. A deadlock may also occur if one of the systems in a circular chain of waiting crashes during a request, leaving some systems endlessly waiting for a response."
          }
        ]
      },
      {
        "title": "3.8.5 Service Recursion",
        "content": [
          {
            "text": "Similar to a deadlock, Web services can also experience an infinite recursion, where Web services keep initiating requests to one another to solve a problem. For example, Web service A implements a service by forwarding it to Web service B, and Web service B searches the UDDI registry to dynamically bind a Web service that performs the required functionality and finds Web service A, so it forwards the request back to Web service A. Because neither Web service implements the required functionality, they will continue to send requests until they run out of resources. Such a situation needs to be carefully avoided, which may be difficult in a highly dynamic SOA."
          },
          {
            "text": "Execution flow diagrams are the method development teams usually use to mitigate deadlock and recursion. These diagrams are fairly effective for predicting interactions within a single application. The interfaces from the Web service under development with other services, especially those provided by third parties (COTS, Open Source Software [OSS]), are more difficult to manage. At the design level, service interface information for third-party services needs to be thoroughly reviewed so shortcomings can be effectively mitigated in the Web service design. At the design level, the most effective antideadlock mechanisms are to implement asynchronous (non-blocking) service-to-service calls and to design the Web service to use message buffering."
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "services. Most Web services are not for public use, so the UDDI specification expanded to include private implementations of the UDDI registry. A private UDDI registry provides a mechanism for internal applications and users to discover and access Web services within an organization with little, if any, human interaction. UDDI v3 was approved as an OASIS Standard in 2005, but as of this writing a number of UDDI registries implement UDDI v2, so UDDI v2 is also discussed. The following subsections provide additional details into the structure, operations, and security inherent to UDDI, as well as explanations of the APIs relevant to UDDI."
      },
      {
        "title": "3.9.1 UDDI Structure",
        "content": [
          {
            "text": "UDDI registries provide information about organizations and the Web services they provide through three different interfaces:"
          },
          {
            "text": "\nWhite pages, which provide the identity and contact information of an organization\nYellow pages, which divide organizations into categories and provide information about their services\nGreen pages, which provide information about an organization's services: the locations of services, and binding information.\n"
          },
          {
            "text": "There are six data types in a UDDI registry that provide all the information:"
          },
          {
            "text": "\nbusinessEntity. Holds the name, address, and contact information of an organization\nbusinessService. Holds technical data about what services and products the organization offers\nbindingTemplate. Provides details on a particular Web service offered\ntModel. Defines how to interact with the target Web service, which is usually done by providing a technical specification, such as a wire protocol, interchange format, or interchange sequencing rule (e.g., WSDL document)\npublisherAssertion. Describes the relationship between businessEntity entries\nsubscription. Describes a request to monitor changes to certain entities within the registry.\n"
          },
          {
            "text": "A WSDL document provides requesters with all the necessary information to send SOAP requests to a provider service. A WSDL document defines services as a collection of endpoints, which are referred to as ports. It also provides an abstract description of the types of messages and operations a Web service performs along with what inputs are required for each operation and as what format the result is returned. A UDDI registry provides a method to search for Web services and provides requester services with the location of the WSDL document for the target Web service."
          },
          {
            "text": "UDDI registries are generally hosted within organizational boundaries and allow access to certain services within an individual SOA to be restricted. There are four types of private registries:"
          },
          {
            "text": "\nInternet-based services registry. Hosted by a group of organizations and provides information about these organizations for public consumption\nPortal registry. Resides outside of an organization's firewall and provides information about that particular organization's Web services\nPartner catalog registry. Resides on an internal network and provides information on the services offered by a particular organization and its partners\nInternal services registry. Resides on an internal network and provides\n```# Information on the Services\n"
          },
          {
            "text": "offered within that network. In addition, UDDI v3 provides a framework for access privileges to keep portions of the registry available only to authorized users."
          }
        ]
      },
      {
        "title": "3.9.2 UDDI Operations",
        "content": [
          {
            "text": "In UDDI, the process of locating Web services through a registry is referred to as discovery. There are two types of discovery: direct discovery and indirect discovery. In direct discovery, the information is retrieved through a registry maintained by the service provider. In indirect discovery, the information is retrieved through a third party registry."
          },
          {
            "text": "UDDI provides three SOAP-based APIs to access the registry:"
          },
          {
            "text": "\nA publishing API is used to place information into the registry. The publishing is restricted, so publishers must be authenticated. Authentication can be performed using a username/password combination, SAML, Kerberos, or some other method.\nAn inquiry API provides read-only access to the registry. The inquiry API allows Web services to search for organization details, services offered, and binding information for the services. This API is usually publicly accessible. In UDDI v2, the inquiry API does not support authentication, but in UDDI v3, authentication can be required for inquiries\u2014limiting access to the registry only to trusted Web services.\nUDDI v3 introduces a new subscription API that provides notifications about additions or updates to the registry. The subscription API is also restricted, requiring authentication by the registry.\n"
          },
          {
            "text": "In addition to the SOAP-based APIs, many implementations of UDDI registries provide a Web interface for publishing to and searching the registry. Because this is not part of the UDDI standard and is not implemented by all UDDI registry vendors, these UDDI Web interfaces are not covered in this guide."
          }
        ]
      },
      {
        "title": "3.9.3 Secure Access to the Registry",
        "content": [
          {
            "text": "As described in Section 3.9.2, some portions of the UDDI API require authentication. SOAP over HTTPS is usually required to make certain that publisher credentials cannot be intercepted during transmission. In addition, all publishers should be designated as Tier 1 publishers. In UDDI v2, Tier 1 publishers have defined restrictions for what services they can publish to the registry. In a private registry, these restrictions can vary based on the needs of the organization. In contrast, the specification does not require restrictions on a Tier 2 publisher."
          },
          {
            "text": "Some UDDI registries provide the ability to restrict publishers' activities at the account level, which provides some control over Tier 2 publishers. UDDI v3 provides the ability to define policies, which provide finer control over publishers than the Tier model available in v2. UDDI v3 adds support for XML Signatures to the registry, providing a way for inquirers to verify the integrity and publisher of data in the registry. In UDDI registries, a publisher is only allowed to alter entries the publisher created, so inquirers can be reasonably certain that any changes made to an entry in the registry were made by the appropriate publisher. Nevertheless, even with digital signatures, there is no guarantee the information in# UDDI Registry Overview"
          }
        ]
      },
      {
        "title": "3.9.4 Service Inquiry API",
        "content": [
          {
            "text": "The inquiry API is used to search for Web services within the UDDI registry that meet the requester's needs. In UDDI v2, the inquiry API is accessed through SOAP over HTTP and requires no authentication. The requester must have a pre-existing trust relationship with the UDDI service, which can be achieved by accessing a private UDDI registry within the organization or a trusted public UDDI registry (e.g., the UBR). Most UDDI registries run from a functioning Web server and are unaware as to whether or not the Web server is using HTTPS. It may be possible to configure a UDDI v2 registry's inquiry API to use SSL/TLS, which in turn can be configured for authentication in addition to encryption."
          },
          {
            "text": "UDDI v3 specifies that the inquiry API can be accessed over HTTPS and supports authorization. If a UDDI v3 service is being used with authentication, the requester has previously established a relationship with the registry and can likely trust its results. In UDDI v3, authentication usually consists of a username and plaintext password transmitted over SSL/TLS, but the UDDI specification states that any authentication method can be used to access the registry, from X.509 certificates to SAML assertions. Also, because UDDI v3 allows the inquiry API to use SSL/TLS, the requesting service can be certain that the results from the registry were not tampered with during transit."
          },
          {
            "text": "In UDDI v2, there is no way for the requester to verify the integrity or origin of data retrieved through the registry. Some integrity assumptions may be made because publishers are required to authenticate to the registry, but it is not possible to determine whether or not a particular publisher is legitimate. In UDDI v3, all data entries stored in the registry can be signed using XML Signatures. After receiving information about a candidate, the requester can retrieve the public key associated with the candidate and verify the integrity of the data from the registry. This is the best solution for verifying that entries in a UDDI registry are valid."
          },
          {
            "text": "In UDDI v2, it is possible to include digital signatures for entries in the optional \"description\" element of each data type, as this element is designed to contain textual information about the entry. Both the requester and the publisher must agree on a protocol for performing this type of signature so that verification can be possible."
          }
        ]
      },
      {
        "title": "3.9.5 Service Publishing API",
        "content": [
          {
            "text": "The publishing API is used to publish information about a Web service in the UDDI registry. According to the UDDI specification, SOAP over HTTPS should be used exclusively for all calls in the publisher API. In addition, the publisher must authenticate with the UDDI registry via the \"get_authToken\" call. All calls within the publisher API require the authentication token to be passed as an argument. The UDDI specification does not define what authentication methods should be used, so they can range from a simple username/password combination to a SAML assertion, depending on the implementation. Once the publisher has received the authorization token, it must be kept securely until it has been...# UDDI and WSDL"
          }
        ]
      },
      {
        "title": "Overview",
        "content": [
          {
            "text": "discarded so that an attacker cannot use the token. In a UDDI registry, there are limits for how much each publisher can publish. In UDDI v2, the limits are broken up between Tier 1 publishers and Tier 2 publishers. Tier 1 publishers are limited to publishing a hard-coded number of UDDI entries. Tier 2 publishers have no hard-coded limit and they are to be strictly monitored by the UDDI registry's operator. In UDDI v3, operators have more fine-grained control over the limits imposed upon publishers through policies."
          },
          {
            "text": "A requester can independently verify the validity of these structures using the UDDI API. In UDDI v3, an additional method for verifying the publisher of any data structure is an XML Signature. When using a UDDI v3 registry, XML Signatures should be used, as they are the best method for verification. If signatures are to be used in a UDDI v2 registry, it may be possible to place them in the description element. The publisher and the inquirer must have a predefined method for calculating signatures in this case."
          }
        ]
      },
      {
        "title": "Publisher Assertions",
        "content": [
          {
            "text": "Publisher assertions are used to establish a relationship between two businessEntities, such as one entity being a subsidiary of the other. For a publisherAssertion to be recognized by the UDDI registry, both entities must create the publisherAssertion. This allows inquirers to be certain that there is a relationship between two entities."
          },
          {
            "text": "The publisher is also responsible for verifying that the records and assertions published are correct. Any mistake made while publishing will result in incorrect results when inquirers access the UDDI registry."
          }
        ]
      },
      {
        "title": "UDDI and WSDL",
        "content": [
          {
            "text": "While UDDI provides a registry for searching for and automatically connecting to Web services, there is no mechanism for describing how to connect to candidate services. This is done through the WSDL document. A Web service's WSDL document is referenced through the bindingTemplate and tModel data structures."
          },
          {
            "text": "When publishing a Web service, a UDDI publisher must make certain that there is a tModel associated with the WSDL for the Web service being published. These are referred to as wsdlSpec tModels. wsdlSpec tModels allow inquirers to locate Web services that correspond to the same published WSDL document. For example, there are standard WSDL specifications for UDDI and NCES services, but there may be multiple Web services that implement them."
          },
          {
            "text": "tModels are referenced from the bindingTemplate data structure by providing a tModelInstanceInfo entry for each tModel that corresponds to the service's WSDL document. A tModel provides the location to a Web service's WSDL document, but the bindingTemplate's accessPoint element specifies the location of the Web service itself. UDDI allows for Web services and WSDL documents to be in separate locations."
          },
          {
            "text": "Once the requester receives the WSDL document for the candidate Web service, it must be validated. The simplest method for doing this is to provide a digital signature of the WSDL document for the requester to use. WSDL v1.1 does not provide an internal mechanism for signing WSDL documents. Until such a mechanism is available, the candidate Web service should provide an...# External Signature for WSDL Document"
          },
          {
            "text": "The requester should independently verify via out-of-band communications that the site providing the WSDL document is a trusted entity. Requesters cannot connect to most providers without some form of authentication. WSDL v1.1 does not provide a method for specifying the security requirements of a Web service. Future versions of WSDL are slated to have this feature. At the moment, the requesting Web service must use some external method for determining what authentication requirements a candidate service has. This can be done using tModels."
          },
          {
            "text": "In a UDDI registry, a bindingTemplate structure can hold zero or more references to tModels. tModels are used to represent the different WSDL service interfaces, but may be used to reference other metadata related to the Web service. Because tModels are used to describe the particular interfaces and behavior of a Web service, an additional unique tModel could be developed for each method of authentication that Web services in the registry may use. When a requesting Web service sees this tModel, the requester will know what methods of authentication the candidate Web service requires. This approach is implemented for the NCES service discovery services."
          }
        ]
      }
    ]
  },
  {
    "title": "Organization",
    "subsections": [
      {
        "content": "For authentication within large organizations or across multiple organizations, using a single TTP may not be feasible. To facilitate authentication across trust boundaries, a trust federation framework should be adopted. Organizations face several options: Liberty Alliance, WS-Federation, and Shibboleth. Liberty Alliance works closely with OASIS, and SAML v2.0 incorporated many of the features from earlier Liberty Alliance specifications. Because the same functionality is provided by each framework, the choice may largely depend on whether COTS products already deployed support one of these frameworks."
      },
      {
        "title": "Distributed Authorization",
        "content": [
          {
            "text": "Distributed authorization is becoming increasingly common in organizational SOAs where each Web service is a PEP that communicates with a PDP to get authorization information. To this end, SAML and XACML were developed to provide support for multiple authorization models. SAML assertions are generated by TTPs and can be used as security tokens by entities within the SOA. When a request is received, PEPs use the SAML protocol to communicate with the PDP to determine whether the requester is authorized. XACML provides a flexible, extensible policy language and mechanisms for querying XACML policies. Similarly, authorization rules may affect individual content or services. Security metadata can be used to determine what entities are authorized to access content or services. By providing policy along with the content or service, PEPs are able to make some authorization decisions without communicating remotely over the network."
          }
        ]
      },
      {
        "title": "Securing the Discovery Process",
        "content": [
          {
            "text": "Securing the discovery process is also important for an organizational SOA. If the registry can be corrupted, or if the provider's WSDL document is wrong, an attacker may gain access to restricted information or the entire SOA may fail. UDDI v3 provides support for digitally signing registry information using XML Signatures, allowing requesters to verify the authenticity and the integrity of the information. WSDL documents, however, do not inherently support digital signatures, meaning that verifying the authenticity and integrity requires an out-of-band mechanism. True automated discovery is still hampered by the fact that even though an individual's identity is trusted, the published service may be malicious or may itself use a malicious service."
          }
        ]
      }
    ]
  },
  {
    "title": "CURRENT_PAGE_RAW_OCR_TEXT",
    "subsections": [
      {
        "content": "Failure. Web services' support for dynamic discovery and binding allows for failover Web services to be accessed when a DoS occurs. Similarly, reliable messaging technologies can be used to ensure that messages will be received in spite of a DoS attack. Finally, QoS technologies can be used to prioritize Web service traffic so that high priority Web services will still remain functional in the face of an attack on the availability of the network."
      },
      {
        "title": "4. Human User's Entry Point into the SOA: Web Portals",
        "content": [
          {
            "text": "A Web portal is a starting point for Web activities. By logging into a Web portal, a user is granted access to the information and services connected to the authenticating portal. Common implementations for portals are Internet search engines that expand into information centers, and Web interfaces for corporate knowledge management systems."
          },
          {
            "text": "Web portals that sit at the boundary of a SOA have multiple roles: a Web server for users and a requester to other Web services in the SOA. This dual role brings with it security implications that could impact Web services interacting with the portal. Some of these implications include:"
          },
          {
            "text": "\nAuthentication. Who is sending this message?\nAuthorization. Is the authenticated subject entitled to access?\nAudit. Can it be proved that this transaction occurred?\nIntegrity. Was the message, or the system, tampered with?\nConfidentiality. Can the information be read while it is in transit? In storage?\nPrivacy. Can personally identifiable information be released to the public?\nAvailability. Is it vulnerable to a denial of service attack (brute force or otherwise)?\nNon-Repudiation. Can it be proven that the sender and the recipient did in fact send and receive the message?\nPolicy Administration. How easy is it to apply or change a security policy rule or configuration parameter?\n"
          },
          {
            "text": "Additionally, Web service faces many challenges to fulfilling these basic security requirements. The threats to Web services security include both the traditional exploits associated with the underlying protocols such as HTTP, as well as new threats associated with new protocols and services, such as SOAP and XML."
          },
          {
            "text": "This section expands on the information provided above, with particular focus on explaining the role of proxy agents, authorization and access control considerations for portals, and potential mechanisms for enforcing XML filtering constraints on content provided to portal users."
          },
          {
            "subsection": "4.1 Proxy Agents",
            "text": []
          },
          {
            "text": "As mentioned above, Web services that reside on the edge of the SOA are used to represent users during communications from the client on the edge of the service and other Web services. A number of Web service invocations are at the request of users through edge applications, such as portals, Web servers, and single sign-on servers. These edge applications are server-based Web applications that interface, as proxy agents on behalf of the user, with the Web services in the SOA. All security functions that require direct interaction with users (via their clients) are expected to be performed by the edge applications. The Web services connected to the portal would then presume that when the edge\n```# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      },
      {
        "title": "applications assert a user's",
        "content": [
          {
            "text": "authenticity and privileges, such an assertion is trustworthy. For Web services to communicate, the interacting parties must trust each other. When communicating using Web services, there are a number of different entities involved: the client application through which the user operates, a portal, a requester, a provider service, an SSO server, and SAML-enabled Web applications."
          },
          {
            "text": "In a Web services trust environment, a user will communicate with an SSO server and one or more SAML-enabled Web applications, as shown in Figure 4-1. For this SSO environment to function correctly, all three entities must trust each other. A user may also access a portal application, which provides Web service proxy agents access to providers on behalf of the user. In addition, requesters will often talk to providers on their own behalf. For all of these interactions to function, the entities involved must trust one another. WS-Security enables two Web services to trust each other, while SAML enables one entity to assert that it trusts another entity. In this type of configuration, it is possible to build a chain of trust, where a Web service trusts another Web service regardless of the fact the two Web services have no direct relationship."
          }
        ]
      },
      {
        "title": "4.2 Using the Portal to Control User Authorization and Access to Web Services",
        "content": [
          {
            "text": "A portal may use SAML assertions to express a user's identity to other Web services, so SAML assertions may be extended into authorization and access controls. Portals can be implemented using one of the available Liberty or SAML libraries or using one of the many COTS products that will act as an identity server. By implementing an identity server, the portal's presentation functions are combined with the SSO and distributed access management services, providing only authorized information to be presented to the user."
          },
          {
            "text": "COTS identity servers provide robust support for the complexities of the SAML specification. Additionally, most COTS identity providers support a wide variety of authentication mechanisms\u2014from certificates to passwords. While these are designed to prevent attacks at the protocol level, COTS identity providers must be configured correctly to be secure."
          }
        ]
      },
      {
        "title": "4.3 Portal Interaction with the SOA's Discovery Service",
        "content": [
          {
            "text": "As described in Section 4.2, pages presented to the user can be tailored to analyze a user's credentials to prevent users from searching for services that the user is not authorized to interact with. If a portal's SAML assertion (on behalf of a user) does not include the proper credentials to access a service (as determined by the discovery service), the user will not be permitted to know that the service exists. Controlling access to services at the discovery level may be beneficial to the service. It can simplify the administration of access controls required to maintain the service's expected level of security."
          }
        ]
      },
      {
        "title": "4.4 Summary",
        "content": [
          {
            "text": "In a SOA, the Web portal is an SSO starting point for users interfacing with a SOA. Web portals interact with provider services and identity providers to perform actions on behalf of the user. By acting as a# Middleman Between the User and the Provider"
          },
          {
            "text": "Services, portals must provide authentication information about the user, coordinate with the provider's authorization mechanisms and policy administration as well as provide auditing services, integrity, confidentiality, availability, and non-repudiation of messages sent to both the user and provider. Through SAML and WS-Security, these goals can be achieved. SAML allows the user to authenticate with the identity provider and will provide SAML assertions that can be sent along with all requests on behalf of the user. Provider services can then verify the contents of the SAML assertions and determine whether the user is authorized to perform the action."
          }
        ]
      }
    ]
  },
  {
    "title": "5.3 Extending Non-Web Applications to Be Able to Participate in SOAs",
    "subsections": [
      {
        "content": "Allowing non-Web applications such as database and directory server applications to securely interact with Web services involves many of the same measures as enabling Web applications. The same procedures are used for creating a Web service and extending an existing application's functionality as a discoverable Web service."
      },
      {
        "content": "Web services can extend any application, as long as there are robust and easy-to-use business objects or an API built into the application. It will be more difficult to Web service-enable applications that have# Business Logic and Web Services"
      },
      {
        "title": "5.4 Public Key Enabling Concerns Specific to Web Services and SOAs",
        "content": [
          {
            "text": "Both SSL/TLS and WS-Security, the primary methods for securing SOAP messages, rely on PKI certificates for authentication. Many legacy applications only support username and password authentication over time. Organizations may benefit from transitioning these legacy applications to PKI authentication. Initially, the legacy application should provide the capability for users to test their certificates while maintaining username password access. Then, the application should allow users who have certificates to authenticate using these certificates while still allowing users to authenticate with their existing usernames and passwords. Once users have become familiar with certificate-based authentication, the application should publish a date after which usernames and passwords will no longer be accepted. In the transition to Web services, an API should be developed that can be used to communicate with the discovery service as well as authenticate users."
          },
          {
            "text": "For applications with a large number of current users, an applet can be written to establish a mapping between an existing username\u2014and associated privileges\u2014and a subscriber certificate. The first time each user is authenticated based on the certificate, the user will be asked to provide the old username and password. The applet will then establish the mapping of the privileges associated with that username to the new certificate, so that the next time the user logs in, those privileges will be granted based on the certificate presented, without the user being required to enter the old username and password."
          }
        ]
      },
      {
        "title": "5.5 Accountability for Legacy Application Transactions",
        "content": [
          {
            "text": "In accordance with the security functions provided by authorization and access control measures, sound Web services security practices also include the maintenance of auditing records. Auditing should be done to maintain appropriate accountability for legacy application transactions in the Web services environment."
          },
          {
            "text": "The legacy application's auditing mechanisms should be developed to provide sufficient information and secure storage for audit data. Verbose logging is beneficial to later analysis of the system. Appropriate review procedures can identify anomalous access control situations, which may indicate an attacker's presence. To support analysis, logs should be stored securely for an appropriate length of time, which is usually determined by the organizational policies. NIST SP 800-92 provides guidance for managing logs within an organization."
          }
        ]
      },
      {
        "title": "5.6 Database Security Challenges in SOA Environments",
        "content": [
          {
            "text": "When a database application is exposed as a service or is simply accessed by a Web service, the security of the database relies entirely on the security of the applications directly accessing it. The exposing application should account for confirming the requester's authorization to access the database. Additionally, the application must filter requests before forwarding them on to the database. Incoming requests may include SQL injection attacks or other attempts to subvert the system.# CURRENT_PAGE_RAW_OCR_TEXT"
          }
        ]
      }
    ]
  },
  {
    "title": "be secure, to prevent",
    "subsections": [
      {
        "content": "introducing new vulnerabilities into the system. Ideally, legacy applications should be modified to support Web service standards, but this may not always be possible. If the application was originally designed as a Web application, it can be configured to use SSL/TLS for authentication, confidentiality and integrity between the Web service front-end and the application itself. In addition, many legacy applications have built-in authentication and authorization mechanisms. If possible, these should be upgraded to support SOA technologies; otherwise the Web service front-end will have to map SOA identities and permissions to those used by the legacy application. While it is important to provide an updated authentication and authorization mechanism, it is equally important to take advantage of logging facilities provided by the application. In addition, these logs should be integrated into the system-wide log management infrastructure. By exposing legacy functionality as a Web service, there are a number of potential attacks that may surface, requiring the Web service front-end to be carefully designed, implemented, and deployed to take full advantage of the legacy application's security functionality while providing the security needed to protect against threats introduced by the SOA."
      },
      {
        "title": "6. Secure Implementation Tools and Technologies",
        "content": [
          {
            "text": "When implementing a secure Web service, developers should be aware of how to use the available development tools, techniques, and languages in a secure manner, in addition to implementing the security functionality already discussed in this guide. While security functionality is an important aspect of secure Web services, security functionality can be compromised by poorly implemented software. See Appendix A for a discussion of some attacks to which Web services are susceptible. The following sections outline the various developer toolkits, XML parsers, available development languages, and security testing methodologies that can aid in testing a Web service."
          },
          {
            "subsection": "6.1 Web Services Developer Toolkits",
            "text": []
          },
          {
            "text": "When choosing an appropriate Web services developer toolkit, it is important to first determine whether there are any language requirements of the Web service. Should it be able to interact with a .NET environment, a Java environment, or natively compiled libraries? In most cases, either a Java or .NET Web service will be able to meet all of the functional requirements of the system, but there are times when a Web service written using C or C++ may be necessary. If the language requirement is not an obstacle, there are further attributes of a Web service development toolkit to consider."
          },
          {
            "text": "The most important aspect of a Web service development toolkit is its ability to interoperate with Web services developed using other toolkits. The SOAP and WSDL specifications developed by W3C left some design choices to individual Web service toolkit developers, making Web services less interoperable. In particular, by default Java and .NET Web services may not be able to communicate with one another. To this end, WS-I developed WS-I Basic Profile 1.1, which specifies exactly how the\n```# WSDL and SOAP Specifications"
          },
          {
            "text": "WSDL and SOAP specifications should be implemented to achieve full interoperability. Toolkits that support WS-I Basic Profile 1.1 will be able to interoperate with Web services from other toolkits with\u2014at most\u2014only minor changes to the Web service being developed. Additionally, WS-I is working on WS-I Basic Security Profile 1.0, which will allow Web services to implement interoperable authentication mechanisms. WS-Security implementations do not always interoperate well with other Web services, so the WS-I Basic Security Profile will aid in developing secure interoperable Web services. As this specification has not yet been ratified, few (if any) Web service toolkits support it. Until the WS-I Basic Security Profile has been released by WS-I, toolkits should be used that provide support for (or have libraries available for) the WS-Security and SAML specifications, which are the most commonly used tools for securing and authenticating Web services."
          },
          {
            "text": "Finally, WS toolkits should ease the burden placed on the Web service developer by providing tools that will create stubs, the Web service-specific code, that the developer can use without having to delve into XML or SOAP specifics. Usually, these tools are in the form of a command-line program that will take either a pre-existing application and develop the WSDL or develop stubs from a pre-existing WSDL."
          }
        ]
      },
      {
        "title": "6.2 XML Parsers",
        "content": [
          {
            "text": "XML parsers are the first portion of a Web service that process input from other Web services. A poorly designed or poorly configured XML parser can be used to compromise the Web service regardless of how secure the Web service is. To this end, it is important to use robust and proven XML parsers."
          },
          {
            "text": "An improperly configured XML Parser is susceptible to several attacks:\n- Large or recursive XML documents can overload the XML parser and lead to a DoS.\n- XML documents can be configured to refer to and use local files. This can lead to an attacker gaining knowledge about the local system.\n- External references to other XML documents or XML schemas can be used to bypass XML validators."
          },
          {
            "text": "All of these XML parser security concerns can be overcome by properly configuring the system. In particular, oversized XML documents can be prevented by configuring the Web server on which the Web service is running to only accept messages up to a certain size. When the oversized XML document is passed to the Web server, it will prevent the entire document from reaching the Web service. The other XML attacks can be prevented by developing robust local XML schemas for the Web service and configuring the XML parser to validate all incoming XML traffic against the local schemas rather than against remote schemas provided by the incoming traffic. Additionally, one of the main functions of an XML gateway is to provide a robust defense against XML attacks that target the XML parser; XML gateways provide a robust system for detecting and validating XML traffic before it reaches the Web service and can be configured to notify appropriate personnel when such an attack has been attempted."
          }
        ]
      },
      {
        "title": "6.3 Languages for Secure Web Service Development# Security-Related Practices for Programming Languages",
        "content": [
          {
            "text": "Each of the languages discussed in this section has its own set of sound security-related practices, but all benefit from a common set of secure coding practices that include the following:"
          },
          {
            "text": "\nDo not include sensitive data in user-viewable source code (i.e., Web page code that can be displayed by the user using the view source function of his/her browser) or configuration files.\nAssemblies that support untrusted or partially trusted callers should never expose objects from assemblies that do not allow untrusted or partially trusted callers.\nAllow untrusted or partially trusted callers only after the developer has carefully reviewed the code, ascertained the security implications, and taken the necessary precautions to defend against attack.\nDisable tracing, debugging, and other diagnostic development or testing-related functions, tools, and hooks before application deployment.\nDo not issue verbose error information to the user.\n"
          }
        ]
      },
      {
        "title": "6.3.1 Procedural Languages",
        "content": [
          {
            "text": "The procedural languages summarized in the following sections are considered to be relevant to Web service design and development. This does not preclude the importance or relevance of other languages that are not explicitly described; rather, these are the languages most commonly used to implement Web services."
          },
          {
            "subsection": "6.3.1.1 C and C++",
            "text": []
          },
          {
            "text": "There are many cases where Java, .NET, or other forms of managed code are not practical, even when implementing Web services. In particular, Web services based on C and C++ do not require the overhead of a framework to implement Web services specifications. Java EE and .NET can take up hundreds of megabytes of space, which may not be available on a particular system (usually a legacy or embedded system). When adding Web service support to legacy systems, Java and .NET may not be available, as .NET does not run on versions of Windows older than Windows 2000, and there may not be a Java Virtual Machine for the legacy system's platform or operating system."
          },
          {
            "text": "To this end, there are a number of Web service frameworks available for C and C++. Web services developed using these frameworks do not have the security benefits provided by managed code such as .NET and Java, so they must rely on operating system-level security support such as restricting user permissions and running the Web service within restricted environments. It is important to ensure that all code is properly written to avoid the potential pitfalls of the language, such as buffer overflows. C and C++ Web services can be implemented without much of the complexity of a Java or .NET Web service and would not be susceptible to vulnerabilities associated with the framework itself. An additional step that can be taken to protect Web services developed in C or C++ would be to place the Web service behind an XML gateway, which would filter XML attacks and protect the C or C++ system from external entities."
          },
          {
            "subsection": "6.3.1.2 Java",
            "text": []
          },
          {
            "text": "Java runs in a secure virtual environment through the Java Security Manager (JSM), which provides a sandbox in which Java applications can run. Java also provides more stringent memory protections than# CURRENT_PAGE_RAW_OCR_TEXT"
          },
          {
            "text": "C or C++, relying on garbage collection and references memory management in place of the more manual approach used by C and C++. Java allows the user to have almost full control of the virtual environment in which the Java bytecode is run. Java code intended for use on the client runs in a different environment, under a different trust model, than code on the server. There are common requirements, whether the Java code runs on the client or server. Input from untrusted sources should always be checked and filtered. Java code that inherits methods from parents, interfaces, or parents' interfaces also inherits vulnerabilities in those methods. For this reason, it is critical that the developer use inheritance with caution."
          },
          {
            "text": "Because the Java language is compiled into a platform-independent bytecode format, much of the information contained in the original Java source code remains in the compiled bytecode. This makes decompilation by attackers easier for Java than natively compiled languages like C and C++. Bytecode obfuscation is a technique designed to help protect Java bytecodes from decompilation. Preventing bytecode decompilation is a countermeasure both against disclosure and tampering (i.e., confidentiality and integrity concerns)."
          },
          {
            "text": "Java bytecode must be able to undergo bytecode verification, which gives it a measure of protection against malicious code, and it is not possible to distribute the bytecode in a more secure form. Application of digital signatures to the native Java code (code signing) is intended to increase the security of the distribution process by providing a means of verification by the execution environment that the received Java code came from a trusted source and has not been tampered with en route."
          },
          {
            "text": "The technique most often proposed for reducing this vulnerability is code obfuscation. Code obfuscation transforms the Java program to make it more difficult to understand, yet functionally identical to the original. The program produces the same results, though it may execute more slowly or have other side effects because of the code added to it by the obfuscation technique. Thus, there are trade-offs that must be considered between the security provided by code obfuscation and the execution time and space penalties imposed on the transformed program."
          },
          {
            "text": "There are a number of COTS and public domain programs and utilities for performing code obfuscation. Some of these apply optimizations to the Java compiler, such as array and loop reordering and procedure inlining. Code obfuscation can be classified according to the kind of information the obfuscation technique targets and how it affects that target."
          }
        ]
      },
      {
        "title": "6.3.1.3 Microsoft's .NET Languages: C# and VB.NET",
        "content": [
          {
            "text": "C# was developed by Microsoft as part of its .NET initiative to provide developers with the power of languages like Java and C++ for rapid application development. Like Java, C# runs in a secure environment through code access security, which provides a sandbox in which to run Common Language Runtime (CLR) applications, such as C# and VB.NET. C# applications also benefit from a garbage collection system, preventing most memory leaks from affecting C# applications.# C# and VB.NET Security Features"
          },
          {
            "text": "C# provides a more type-safe environment than C++, but unlike Java, C# applications support accessing raw memory\u2014although this requires certain code access security permissions to be enabled. .NET's code access security offers security features similar to Java's, such as code signing, stringent access control and sandboxing."
          }
        ]
      },
      {
        "title": "Visual Basic .NET",
        "content": [
          {
            "text": "Visual Basic .NET was released alongside of C# as a successor to the legacy Visual Basic language. While the VB.NET syntax is similar to the original Visual Basic language, VB.NET provides a fully object-oriented language in place of the COM-based language of Visual Basic. While Visual Basic has some security concerns, VB.NET's support of garbage collection, object-oriented design, code access security, and the .NET framework make VB.NET similar to C# and Java. Through the .NET framework and the CLR, C# and VB.NET have access to the same security libraries and both C# and VB.NET applications are subject to code access security."
          }
        ]
      },
      {
        "title": "Code Access Security",
        "content": [
          {
            "text": "As in Java, code written in C# or VB.NET can be downloaded and run from untrusted sources. To alleviate this problem, Microsoft has integrated code access security into the .NET Framework. Code access security provides varying levels of trust for code based on where the code originates and allows individual users to specify what permissions will be given to an application. Because code access security is part of the .NET Framework, all applications that access the .NET Framework can be subject to code access security. Because policies are defined on a per-machine basis, libraries are provided that allow applications to determine whether the application has a particular permission prior to performing a potentially restricted act\u2014allowing .NET applications to alter their behavior rather than simply generate a security exception."
          }
        ]
      },
      {
        "title": "XML",
        "content": [
          {
            "text": "Content within SOAP messages is expressed in XML. Because of this, the security technologies used by Web services are based on those developed for XML. XML was designed so that it could be easily extensible and combined with itself. It should be natural to provide integrity, confidentiality and other security benefits to entire XML documents or portions of these documents in a way that does not prevent further processing by standard XML tools."
          },
          {
            "text": "In general, most of the risks posed by XML are not unique. They can appear with many other technologies and systems, new and old. Some of the risks are more severe for XML than for older systems simply because XML is more expressive, flexible and powerful. Some of the risks derive from the ways in which XML is used (e.g., for metadata) and would appear whether using XML or some other technology."
          },
          {
            "subsection": "Recognized Vulnerabilities and Attacks",
            "text": []
          },
          {
            "text": "Some recognized vulnerabilities and attacks specific to XML and XML Style Sheets (XSL) include the inability to:"
          },
          {
            "text": "\nProve validity of XML content and originator. Not all XML parsers validate the URIs of entity references before accessing them.\nPrevent exploitation of XML entities to steal information. Because some...# Parsers Reference Entities\n"
          },
          {
            "text": "Without first validating their URIs, it may be possible to inject references to other locations on the target server from which secret information could then be extracted."
          },
          {
            "text": "\nPrevent exploitation of XML entities to launch DoS attacks. Because some parsers reference entities without first validating their URIs, it may be possible to create DoS attacks by flooding the XML parser with illegitimate entity references.\nEnforce validation. An attacker may be able to subvert the validate command called by the XML application when it has loaded the schema cache with namespaces. Attackers do this by using a root element from a different namespace to redirect xsi:schemaLocation to point to their own schema, in which they include the declaration <xs:any namespace=##any,, processContents=\"skip\"/>.\n"
          }
        ]
      },
      {
        "title": "6.4 Security Testing: Tools and Techniques",
        "content": [
          {
            "text": "Security testing in the Web services realm should be included in the overall test plan, and should be performed iteratively throughout the Web service's lifecycle, not just after implementation or deployment. The characteristics of Web services make security testing more difficult than for more traditional applications. The Web services model provides a completely implementation-independent mechanism through which applications can interact. The tester can make no accurate assumptions about how that application software is built. Thus, the reliance on black box testing is much heavier than it is for other application testing. Testers must also rely heavily for their understanding of the software on its interface and system specifications."
          },
          {
            "text": "The highly distributed nature of Web services technology creates a dependence on complex interactions, which must be testable. The tester will need to adopt new techniques and processes for many aspects of Web services security testing. Security function testing in particular will require greater use of distributed test agents and associated technology, comparable to how load testing is done."
          },
          {
            "text": "How much security-focused testing is enough? Ideally, the tester would trace all paths through the code and all internal interfaces among components within the service and all external interfaces between the service and other services, and would try out every possible input to ensure it didn't cause an unexpected security violation. Depending on the complexity of the service, testing every possible path, interface, and input may not be feasible. A more practical goal is to cover every path through each unit, and every inter-unit and external interface at least once."
          },
          {
            "text": "Each of the categories of Web services security tests is discussed below."
          },
          {
            "text": "\nWeb Service Security Protocol Conformance Testing. This type of testing is generally performed by an independent testing organization on specific implementations of Web services security protocols by specific vendors in their Web service products, as well as some open source implementations. The objective of this testing is to ensure that individual protocol implementations conform to the relevant published standards from OASIS or W3C.\nCorrectness Testing of Web Service Security Functionality. This type of testing is focused on ensuring that the security functionality performed by a Web service meets its stated requirements.# Security Testing of Web Services\n"
          }
        ]
      },
      {
        "title": "Security Focused Unit Testing",
        "content": [
          {
            "text": "This type of testing focuses on the smallest unit of the Web service application, such as individual classes or functions, apart from the rest of the application. Through unit testing, it is considerably easier to test all of the possible paths that attackers could take to reach unexposed methods or perform illegal operations."
          }
        ]
      },
      {
        "title": "Whole-Application Vulnerability Assessment",
        "content": [
          {
            "text": "The objective of this testing is to seek residual vulnerabilities that appear in the Web service as a whole, as a result of the interactions between the service and other Web services, instead of tracking down vulnerabilities within and among individual unit components of a single Web service."
          }
        ]
      },
      {
        "title": "Web Service Software Security Assessment",
        "content": [
          {
            "text": "This type of testing usually includes threat modeling, requirements risk analysis, and security modeling. Software security test techniques include security-oriented code reviews, security fault injection tests, fuzz testing, and penetration testing."
          },
          {
            "text": "From a security standpoint, Web services adoption today is focused on the corporate intranet, with Web services used to simplify and reduce the cost of integration of existing applications and databases behind the firewall. Web services that communicate outside the firewall are showing up in pilot projects, but are typically limited to service interactions with trusted business partners and known IT organizations."
          },
          {
            "text": "Given this current state of the art, three capabilities are important in the tools used for testing the security of Web services:\n- Generation and testing of SOAP and XML messages, with examination of both messaging interfaces and individual message format\n- Automatic generation of test plans from WSDL files containing metadata about the interfaces of the Web services to be tested\n- Simulation of the actions of both requesters and providers."
          },
          {
            "text": "There is little automated tool support specifically designed for Web services security testing. This dearth is consistent with the relatively small number of automated software and application security testing tools in general. This said, current Web services security testers will need to rely on the somewhat more prevalent software security testing and application vulnerability assessment techniques and tools to fill in the gaps until a more complete, robust set of Web service specific security testing tools emerges."
          },
          {
            "text": "Tools for security testing of groups of Web services interacting across SOAs do not yet exist, nor do tools for testing security of Web services that are dynamically defined at runtime (e.g., through orchestration or choreography)."
          }
        ]
      },
      {
        "title": "Summary",
        "content": [
          {
            "text": "Web services provide interoperability among a variety of development platforms and operating systems, giving organizations flexibility when implementing them. To maximize this flexibility, it is important to understand the security benefits provided by some of the most widely used Web service development languages and what tools are available in those languages to aid in the development of Web services. Web service toolkits can prove to be essential to developing secure Web services, particularly if they are WS-I Basic Profile and WS-I Basic Security Profile compliant\u2014allowing for...# Interoperability with Little or No Change to the Code"
          },
          {
            "text": "In addition, a robust XML parser is essential for developing Web services to prevent attacks designed to compromise the parser. There are several languages commonly used to develop Web services: Java, C#, VB.NET, C, and C++."
          }
        ]
      },
      {
        "title": "Managed Code Frameworks",
        "content": [
          {
            "text": "Java, C#, and VB.NET rely on managed code frameworks to provide many of the support functions necessary to implement Web services. C and C++ can provide performance improvements over their managed code counterparts and may be the only option when Web service-enabling a legacy application."
          }
        ]
      },
      {
        "title": "Secure Software Development Techniques",
        "content": [
          {
            "text": "Regardless of what language is being used, the use of secure software development techniques is essential to preventing a number of vulnerabilities from being introduced into the Web service. To minimize the number of vulnerabilities in a Web service, testing tools and techniques can be used to perform penetration testing, functionality testing, source code review, and other tests."
          }
        ]
      }
    ]
  }
]